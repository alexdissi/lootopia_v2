/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Verification
 *
 */
export type Verification =
  $Result.DefaultSelection<Prisma.$VerificationPayload>;
/**
 * Model TreasureHunt
 *
 */
export type TreasureHunt =
  $Result.DefaultSelection<Prisma.$TreasureHuntPayload>;
/**
 * Model Participation
 *
 */
export type Participation =
  $Result.DefaultSelection<Prisma.$ParticipationPayload>;
/**
 * Model Artefact
 *
 */
export type Artefact = $Result.DefaultSelection<Prisma.$ArtefactPayload>;
/**
 * Model HuntStep
 *
 */
export type HuntStep = $Result.DefaultSelection<Prisma.$HuntStepPayload>;
/**
 * Model Reward
 *
 */
export type Reward = $Result.DefaultSelection<Prisma.$RewardPayload>;
/**
 * Model VirtualCurrency
 *
 */
export type VirtualCurrency =
  $Result.DefaultSelection<Prisma.$VirtualCurrencyPayload>;
/**
 * Model TransactionHistory
 *
 */
export type TransactionHistory =
  $Result.DefaultSelection<Prisma.$TransactionHistoryPayload>;
/**
 * Model Craft
 *
 */
export type Craft = $Result.DefaultSelection<Prisma.$CraftPayload>;
/**
 * Model CraftMaterial
 *
 */
export type CraftMaterial =
  $Result.DefaultSelection<Prisma.$CraftMaterialPayload>;
/**
 * Model LeaderboardEntry
 *
 */
export type LeaderboardEntry =
  $Result.DefaultSelection<Prisma.$LeaderboardEntryPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
    PLAYER: "PLAYER";
    ORGANIZER: "ORGANIZER";
    ADMIN: "ADMIN";
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const HuntMode: {
    PUBLIC: "PUBLIC";
    PRIVATE: "PRIVATE";
  };

  export type HuntMode = (typeof HuntMode)[keyof typeof HuntMode];

  export const HuntStatus: {
    PENDING: "PENDING";
    IN_PROGRESS: "IN_PROGRESS";
    COMPLETED: "COMPLETED";
    CANCELLED: "CANCELLED";
  };

  export type HuntStatus = (typeof HuntStatus)[keyof typeof HuntStatus];

  export const ParticipationStatus: {
    ONGOING: "ONGOING";
    COMPLETED: "COMPLETED";
    ABANDONED: "ABANDONED";
  };

  export type ParticipationStatus =
    (typeof ParticipationStatus)[keyof typeof ParticipationStatus];

  export const ArtefactSource: {
    CACHE: "CACHE";
    SHOP: "SHOP";
    CRAFT: "CRAFT";
    EVENT: "EVENT";
  };

  export type ArtefactSource =
    (typeof ArtefactSource)[keyof typeof ArtefactSource];

  export const ArtefactRarity: {
    COMMON: "COMMON";
    RARE: "RARE";
    EPIC: "EPIC";
    LEGENDARY: "LEGENDARY";
  };

  export type ArtefactRarity =
    (typeof ArtefactRarity)[keyof typeof ArtefactRarity];

  export const RewardType: {
    VIRTUAL_CURRENCY: "VIRTUAL_CURRENCY";
    ARTEFACT: "ARTEFACT";
    DISCOUNT: "DISCOUNT";
    PHYSICAL_ITEM: "PHYSICAL_ITEM";
  };

  export type RewardType = (typeof RewardType)[keyof typeof RewardType];

  export const CurrencySourceType: {
    EARNED: "EARNED";
    PURCHASED: "PURCHASED";
    GIFTED: "GIFTED";
  };

  export type CurrencySourceType =
    (typeof CurrencySourceType)[keyof typeof CurrencySourceType];

  export const TransactionType: {
    EARNED: "EARNED";
    SPENT: "SPENT";
    BOUGHT: "BOUGHT";
  };

  export type TransactionType =
    (typeof TransactionType)[keyof typeof TransactionType];
}

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type HuntMode = $Enums.HuntMode;

export const HuntMode: typeof $Enums.HuntMode;

export type HuntStatus = $Enums.HuntStatus;

export const HuntStatus: typeof $Enums.HuntStatus;

export type ParticipationStatus = $Enums.ParticipationStatus;

export const ParticipationStatus: typeof $Enums.ParticipationStatus;

export type ArtefactSource = $Enums.ArtefactSource;

export const ArtefactSource: typeof $Enums.ArtefactSource;

export type ArtefactRarity = $Enums.ArtefactRarity;

export const ArtefactRarity: typeof $Enums.ArtefactRarity;

export type RewardType = $Enums.RewardType;

export const RewardType: typeof $Enums.RewardType;

export type CurrencySourceType = $Enums.CurrencySourceType;

export const CurrencySourceType: typeof $Enums.CurrencySourceType;

export type TransactionType = $Enums.TransactionType;

export const TransactionType: typeof $Enums.TransactionType;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Verifications
   * const verifications = await prisma.verification.findMany()
   * ```
   */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treasureHunt`: Exposes CRUD operations for the **TreasureHunt** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TreasureHunts
   * const treasureHunts = await prisma.treasureHunt.findMany()
   * ```
   */
  get treasureHunt(): Prisma.TreasureHuntDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.participation`: Exposes CRUD operations for the **Participation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Participations
   * const participations = await prisma.participation.findMany()
   * ```
   */
  get participation(): Prisma.ParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artefact`: Exposes CRUD operations for the **Artefact** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Artefacts
   * const artefacts = await prisma.artefact.findMany()
   * ```
   */
  get artefact(): Prisma.ArtefactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.huntStep`: Exposes CRUD operations for the **HuntStep** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more HuntSteps
   * const huntSteps = await prisma.huntStep.findMany()
   * ```
   */
  get huntStep(): Prisma.HuntStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Rewards
   * const rewards = await prisma.reward.findMany()
   * ```
   */
  get reward(): Prisma.RewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virtualCurrency`: Exposes CRUD operations for the **VirtualCurrency** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VirtualCurrencies
   * const virtualCurrencies = await prisma.virtualCurrency.findMany()
   * ```
   */
  get virtualCurrency(): Prisma.VirtualCurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionHistory`: Exposes CRUD operations for the **TransactionHistory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TransactionHistories
   * const transactionHistories = await prisma.transactionHistory.findMany()
   * ```
   */
  get transactionHistory(): Prisma.TransactionHistoryDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.craft`: Exposes CRUD operations for the **Craft** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Crafts
   * const crafts = await prisma.craft.findMany()
   * ```
   */
  get craft(): Prisma.CraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.craftMaterial`: Exposes CRUD operations for the **CraftMaterial** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CraftMaterials
   * const craftMaterials = await prisma.craftMaterial.findMany()
   * ```
   */
  get craftMaterial(): Prisma.CraftMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderboardEntry`: Exposes CRUD operations for the **LeaderboardEntry** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LeaderboardEntries
   * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
   * ```
   */
  get leaderboardEntry(): Prisma.LeaderboardEntryDelegate<
    ExtArgs,
    ClientOptions
  >;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Session: "Session";
    Account: "Account";
    Verification: "Verification";
    TreasureHunt: "TreasureHunt";
    Participation: "Participation";
    Artefact: "Artefact";
    HuntStep: "HuntStep";
    Reward: "Reward";
    VirtualCurrency: "VirtualCurrency";
    TransactionHistory: "TransactionHistory";
    Craft: "Craft";
    CraftMaterial: "CraftMaterial";
    LeaderboardEntry: "LeaderboardEntry";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "session"
        | "account"
        | "verification"
        | "treasureHunt"
        | "participation"
        | "artefact"
        | "huntStep"
        | "reward"
        | "virtualCurrency"
        | "transactionHistory"
        | "craft"
        | "craftMaterial"
        | "leaderboardEntry";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>;
        fields: Prisma.VerificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>;
          };
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>;
          };
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[];
          };
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>;
          };
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[];
          };
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>;
          };
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[];
          };
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>;
          };
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerification>;
          };
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VerificationCountAggregateOutputType>
              | number;
          };
        };
      };
      TreasureHunt: {
        payload: Prisma.$TreasureHuntPayload<ExtArgs>;
        fields: Prisma.TreasureHuntFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TreasureHuntFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TreasureHuntFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>;
          };
          findFirst: {
            args: Prisma.TreasureHuntFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TreasureHuntFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>;
          };
          findMany: {
            args: Prisma.TreasureHuntFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>[];
          };
          create: {
            args: Prisma.TreasureHuntCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>;
          };
          createMany: {
            args: Prisma.TreasureHuntCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TreasureHuntCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>[];
          };
          delete: {
            args: Prisma.TreasureHuntDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>;
          };
          update: {
            args: Prisma.TreasureHuntUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>;
          };
          deleteMany: {
            args: Prisma.TreasureHuntDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TreasureHuntUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TreasureHuntUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>[];
          };
          upsert: {
            args: Prisma.TreasureHuntUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TreasureHuntPayload>;
          };
          aggregate: {
            args: Prisma.TreasureHuntAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTreasureHunt>;
          };
          groupBy: {
            args: Prisma.TreasureHuntGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TreasureHuntGroupByOutputType>[];
          };
          count: {
            args: Prisma.TreasureHuntCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TreasureHuntCountAggregateOutputType>
              | number;
          };
        };
      };
      Participation: {
        payload: Prisma.$ParticipationPayload<ExtArgs>;
        fields: Prisma.ParticipationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ParticipationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ParticipationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>;
          };
          findFirst: {
            args: Prisma.ParticipationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ParticipationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>;
          };
          findMany: {
            args: Prisma.ParticipationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>[];
          };
          create: {
            args: Prisma.ParticipationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>;
          };
          createMany: {
            args: Prisma.ParticipationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ParticipationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>[];
          };
          delete: {
            args: Prisma.ParticipationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>;
          };
          update: {
            args: Prisma.ParticipationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>;
          };
          deleteMany: {
            args: Prisma.ParticipationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ParticipationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ParticipationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>[];
          };
          upsert: {
            args: Prisma.ParticipationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ParticipationPayload>;
          };
          aggregate: {
            args: Prisma.ParticipationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateParticipation>;
          };
          groupBy: {
            args: Prisma.ParticipationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ParticipationGroupByOutputType>[];
          };
          count: {
            args: Prisma.ParticipationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ParticipationCountAggregateOutputType>
              | number;
          };
        };
      };
      Artefact: {
        payload: Prisma.$ArtefactPayload<ExtArgs>;
        fields: Prisma.ArtefactFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ArtefactFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ArtefactFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>;
          };
          findFirst: {
            args: Prisma.ArtefactFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ArtefactFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>;
          };
          findMany: {
            args: Prisma.ArtefactFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>[];
          };
          create: {
            args: Prisma.ArtefactCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>;
          };
          createMany: {
            args: Prisma.ArtefactCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ArtefactCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>[];
          };
          delete: {
            args: Prisma.ArtefactDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>;
          };
          update: {
            args: Prisma.ArtefactUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>;
          };
          deleteMany: {
            args: Prisma.ArtefactDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ArtefactUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ArtefactUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>[];
          };
          upsert: {
            args: Prisma.ArtefactUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ArtefactPayload>;
          };
          aggregate: {
            args: Prisma.ArtefactAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateArtefact>;
          };
          groupBy: {
            args: Prisma.ArtefactGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ArtefactGroupByOutputType>[];
          };
          count: {
            args: Prisma.ArtefactCountArgs<ExtArgs>;
            result: $Utils.Optional<ArtefactCountAggregateOutputType> | number;
          };
        };
      };
      HuntStep: {
        payload: Prisma.$HuntStepPayload<ExtArgs>;
        fields: Prisma.HuntStepFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.HuntStepFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.HuntStepFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>;
          };
          findFirst: {
            args: Prisma.HuntStepFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.HuntStepFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>;
          };
          findMany: {
            args: Prisma.HuntStepFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>[];
          };
          create: {
            args: Prisma.HuntStepCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>;
          };
          createMany: {
            args: Prisma.HuntStepCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.HuntStepCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>[];
          };
          delete: {
            args: Prisma.HuntStepDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>;
          };
          update: {
            args: Prisma.HuntStepUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>;
          };
          deleteMany: {
            args: Prisma.HuntStepDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.HuntStepUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.HuntStepUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>[];
          };
          upsert: {
            args: Prisma.HuntStepUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HuntStepPayload>;
          };
          aggregate: {
            args: Prisma.HuntStepAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateHuntStep>;
          };
          groupBy: {
            args: Prisma.HuntStepGroupByArgs<ExtArgs>;
            result: $Utils.Optional<HuntStepGroupByOutputType>[];
          };
          count: {
            args: Prisma.HuntStepCountArgs<ExtArgs>;
            result: $Utils.Optional<HuntStepCountAggregateOutputType> | number;
          };
        };
      };
      Reward: {
        payload: Prisma.$RewardPayload<ExtArgs>;
        fields: Prisma.RewardFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>;
          };
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>;
          };
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[];
          };
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>;
          };
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RewardCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[];
          };
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>;
          };
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>;
          };
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RewardUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[];
          };
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>;
          };
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReward>;
          };
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RewardGroupByOutputType>[];
          };
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>;
            result: $Utils.Optional<RewardCountAggregateOutputType> | number;
          };
        };
      };
      VirtualCurrency: {
        payload: Prisma.$VirtualCurrencyPayload<ExtArgs>;
        fields: Prisma.VirtualCurrencyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VirtualCurrencyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VirtualCurrencyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>;
          };
          findFirst: {
            args: Prisma.VirtualCurrencyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VirtualCurrencyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>;
          };
          findMany: {
            args: Prisma.VirtualCurrencyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>[];
          };
          create: {
            args: Prisma.VirtualCurrencyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>;
          };
          createMany: {
            args: Prisma.VirtualCurrencyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VirtualCurrencyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>[];
          };
          delete: {
            args: Prisma.VirtualCurrencyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>;
          };
          update: {
            args: Prisma.VirtualCurrencyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>;
          };
          deleteMany: {
            args: Prisma.VirtualCurrencyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VirtualCurrencyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VirtualCurrencyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>[];
          };
          upsert: {
            args: Prisma.VirtualCurrencyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VirtualCurrencyPayload>;
          };
          aggregate: {
            args: Prisma.VirtualCurrencyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVirtualCurrency>;
          };
          groupBy: {
            args: Prisma.VirtualCurrencyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VirtualCurrencyGroupByOutputType>[];
          };
          count: {
            args: Prisma.VirtualCurrencyCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VirtualCurrencyCountAggregateOutputType>
              | number;
          };
        };
      };
      TransactionHistory: {
        payload: Prisma.$TransactionHistoryPayload<ExtArgs>;
        fields: Prisma.TransactionHistoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TransactionHistoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TransactionHistoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>;
          };
          findFirst: {
            args: Prisma.TransactionHistoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TransactionHistoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>;
          };
          findMany: {
            args: Prisma.TransactionHistoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>[];
          };
          create: {
            args: Prisma.TransactionHistoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>;
          };
          createMany: {
            args: Prisma.TransactionHistoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TransactionHistoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>[];
          };
          delete: {
            args: Prisma.TransactionHistoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>;
          };
          update: {
            args: Prisma.TransactionHistoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>;
          };
          deleteMany: {
            args: Prisma.TransactionHistoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TransactionHistoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TransactionHistoryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>[];
          };
          upsert: {
            args: Prisma.TransactionHistoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>;
          };
          aggregate: {
            args: Prisma.TransactionHistoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTransactionHistory>;
          };
          groupBy: {
            args: Prisma.TransactionHistoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TransactionHistoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.TransactionHistoryCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TransactionHistoryCountAggregateOutputType>
              | number;
          };
        };
      };
      Craft: {
        payload: Prisma.$CraftPayload<ExtArgs>;
        fields: Prisma.CraftFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CraftFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CraftFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>;
          };
          findFirst: {
            args: Prisma.CraftFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CraftFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>;
          };
          findMany: {
            args: Prisma.CraftFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>[];
          };
          create: {
            args: Prisma.CraftCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>;
          };
          createMany: {
            args: Prisma.CraftCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CraftCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>[];
          };
          delete: {
            args: Prisma.CraftDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>;
          };
          update: {
            args: Prisma.CraftUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>;
          };
          deleteMany: {
            args: Prisma.CraftDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CraftUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CraftUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>[];
          };
          upsert: {
            args: Prisma.CraftUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftPayload>;
          };
          aggregate: {
            args: Prisma.CraftAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCraft>;
          };
          groupBy: {
            args: Prisma.CraftGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CraftGroupByOutputType>[];
          };
          count: {
            args: Prisma.CraftCountArgs<ExtArgs>;
            result: $Utils.Optional<CraftCountAggregateOutputType> | number;
          };
        };
      };
      CraftMaterial: {
        payload: Prisma.$CraftMaterialPayload<ExtArgs>;
        fields: Prisma.CraftMaterialFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CraftMaterialFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CraftMaterialFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>;
          };
          findFirst: {
            args: Prisma.CraftMaterialFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CraftMaterialFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>;
          };
          findMany: {
            args: Prisma.CraftMaterialFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>[];
          };
          create: {
            args: Prisma.CraftMaterialCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>;
          };
          createMany: {
            args: Prisma.CraftMaterialCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CraftMaterialCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>[];
          };
          delete: {
            args: Prisma.CraftMaterialDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>;
          };
          update: {
            args: Prisma.CraftMaterialUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>;
          };
          deleteMany: {
            args: Prisma.CraftMaterialDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CraftMaterialUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CraftMaterialUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>[];
          };
          upsert: {
            args: Prisma.CraftMaterialUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CraftMaterialPayload>;
          };
          aggregate: {
            args: Prisma.CraftMaterialAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCraftMaterial>;
          };
          groupBy: {
            args: Prisma.CraftMaterialGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CraftMaterialGroupByOutputType>[];
          };
          count: {
            args: Prisma.CraftMaterialCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CraftMaterialCountAggregateOutputType>
              | number;
          };
        };
      };
      LeaderboardEntry: {
        payload: Prisma.$LeaderboardEntryPayload<ExtArgs>;
        fields: Prisma.LeaderboardEntryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>;
          };
          findFirst: {
            args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>;
          };
          findMany: {
            args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[];
          };
          create: {
            args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>;
          };
          createMany: {
            args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[];
          };
          delete: {
            args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>;
          };
          update: {
            args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>;
          };
          deleteMany: {
            args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LeaderboardEntryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[];
          };
          upsert: {
            args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>;
          };
          aggregate: {
            args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLeaderboardEntry>;
          };
          groupBy: {
            args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LeaderboardEntryGroupByOutputType>[];
          };
          count: {
            args: Prisma.LeaderboardEntryCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LeaderboardEntryCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    session?: SessionOmit;
    account?: AccountOmit;
    verification?: VerificationOmit;
    treasureHunt?: TreasureHuntOmit;
    participation?: ParticipationOmit;
    artefact?: ArtefactOmit;
    huntStep?: HuntStepOmit;
    reward?: RewardOmit;
    virtualCurrency?: VirtualCurrencyOmit;
    transactionHistory?: TransactionHistoryOmit;
    craft?: CraftOmit;
    craftMaterial?: CraftMaterialOmit;
    leaderboardEntry?: LeaderboardEntryOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T["emit"] extends "event"
        ? T["level"]
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number;
    accounts: number;
    participations: number;
    createdChasses: number;
    collectedArtefacts: number;
    virtualCurrency: number;
    transactionHistory: number;
    Craft: number;
    LeaderboardEntry: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    participations?: boolean | UserCountOutputTypeCountParticipationsArgs;
    createdChasses?: boolean | UserCountOutputTypeCountCreatedChassesArgs;
    collectedArtefacts?:
      | boolean
      | UserCountOutputTypeCountCollectedArtefactsArgs;
    virtualCurrency?: boolean | UserCountOutputTypeCountVirtualCurrencyArgs;
    transactionHistory?:
      | boolean
      | UserCountOutputTypeCountTransactionHistoryArgs;
    Craft?: boolean | UserCountOutputTypeCountCraftArgs;
    LeaderboardEntry?: boolean | UserCountOutputTypeCountLeaderboardEntryArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParticipationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ParticipationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedChassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TreasureHuntWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollectedArtefactsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ArtefactWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVirtualCurrencyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VirtualCurrencyWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TransactionHistoryWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCraftArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CraftWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeaderboardEntryWhereInput;
  };

  /**
   * Count Type TreasureHuntCountOutputType
   */

  export type TreasureHuntCountOutputType = {
    participants: number;
    steps: number;
    rewards: number;
    artefacts: number;
    LeaderboardEntry: number;
  };

  export type TreasureHuntCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    participants?: boolean | TreasureHuntCountOutputTypeCountParticipantsArgs;
    steps?: boolean | TreasureHuntCountOutputTypeCountStepsArgs;
    rewards?: boolean | TreasureHuntCountOutputTypeCountRewardsArgs;
    artefacts?: boolean | TreasureHuntCountOutputTypeCountArtefactsArgs;
    LeaderboardEntry?:
      | boolean
      | TreasureHuntCountOutputTypeCountLeaderboardEntryArgs;
  };

  // Custom InputTypes
  /**
   * TreasureHuntCountOutputType without action
   */
  export type TreasureHuntCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHuntCountOutputType
     */
    select?: TreasureHuntCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TreasureHuntCountOutputType without action
   */
  export type TreasureHuntCountOutputTypeCountParticipantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ParticipationWhereInput;
  };

  /**
   * TreasureHuntCountOutputType without action
   */
  export type TreasureHuntCountOutputTypeCountStepsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: HuntStepWhereInput;
  };

  /**
   * TreasureHuntCountOutputType without action
   */
  export type TreasureHuntCountOutputTypeCountRewardsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RewardWhereInput;
  };

  /**
   * TreasureHuntCountOutputType without action
   */
  export type TreasureHuntCountOutputTypeCountArtefactsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ArtefactWhereInput;
  };

  /**
   * TreasureHuntCountOutputType without action
   */
  export type TreasureHuntCountOutputTypeCountLeaderboardEntryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeaderboardEntryWhereInput;
  };

  /**
   * Count Type ArtefactCountOutputType
   */

  export type ArtefactCountOutputType = {
    Craft: number;
    CraftMaterial: number;
  };

  export type ArtefactCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    Craft?: boolean | ArtefactCountOutputTypeCountCraftArgs;
    CraftMaterial?: boolean | ArtefactCountOutputTypeCountCraftMaterialArgs;
  };

  // Custom InputTypes
  /**
   * ArtefactCountOutputType without action
   */
  export type ArtefactCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ArtefactCountOutputType
     */
    select?: ArtefactCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ArtefactCountOutputType without action
   */
  export type ArtefactCountOutputTypeCountCraftArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CraftWhereInput;
  };

  /**
   * ArtefactCountOutputType without action
   */
  export type ArtefactCountOutputTypeCountCraftMaterialArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CraftMaterialWhereInput;
  };

  /**
   * Count Type VirtualCurrencyCountOutputType
   */

  export type VirtualCurrencyCountOutputType = {
    transactionHistory: number;
  };

  export type VirtualCurrencyCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    transactionHistory?:
      | boolean
      | VirtualCurrencyCountOutputTypeCountTransactionHistoryArgs;
  };

  // Custom InputTypes
  /**
   * VirtualCurrencyCountOutputType without action
   */
  export type VirtualCurrencyCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrencyCountOutputType
     */
    select?: VirtualCurrencyCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * VirtualCurrencyCountOutputType without action
   */
  export type VirtualCurrencyCountOutputTypeCountTransactionHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TransactionHistoryWhereInput;
  };

  /**
   * Count Type CraftCountOutputType
   */

  export type CraftCountOutputType = {
    materials: number;
  };

  export type CraftCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    materials?: boolean | CraftCountOutputTypeCountMaterialsArgs;
  };

  // Custom InputTypes
  /**
   * CraftCountOutputType without action
   */
  export type CraftCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftCountOutputType
     */
    select?: CraftCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CraftCountOutputType without action
   */
  export type CraftCountOutputTypeCountMaterialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CraftMaterialWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: boolean | null;
    image: string | null;
    stripeCustomerId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    nickname: string | null;
    role: $Enums.UserRole | null;
    isMfaEnabled: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: boolean | null;
    image: string | null;
    stripeCustomerId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    nickname: string | null;
    role: $Enums.UserRole | null;
    isMfaEnabled: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    emailVerified: number;
    image: number;
    stripeCustomerId: number;
    createdAt: number;
    updatedAt: number;
    nickname: number;
    role: number;
    isMfaEnabled: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    stripeCustomerId?: true;
    createdAt?: true;
    updatedAt?: true;
    nickname?: true;
    role?: true;
    isMfaEnabled?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    stripeCustomerId?: true;
    createdAt?: true;
    updatedAt?: true;
    nickname?: true;
    role?: true;
    isMfaEnabled?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    stripeCustomerId?: true;
    createdAt?: true;
    updatedAt?: true;
    nickname?: true;
    role?: true;
    isMfaEnabled?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    email: string;
    emailVerified: boolean;
    image: string | null;
    stripeCustomerId: string | null;
    createdAt: Date;
    updatedAt: Date;
    nickname: string | null;
    role: $Enums.UserRole;
    isMfaEnabled: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      stripeCustomerId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      nickname?: boolean;
      role?: boolean;
      isMfaEnabled?: boolean;
      sessions?: boolean | User$sessionsArgs<ExtArgs>;
      accounts?: boolean | User$accountsArgs<ExtArgs>;
      participations?: boolean | User$participationsArgs<ExtArgs>;
      createdChasses?: boolean | User$createdChassesArgs<ExtArgs>;
      collectedArtefacts?: boolean | User$collectedArtefactsArgs<ExtArgs>;
      virtualCurrency?: boolean | User$virtualCurrencyArgs<ExtArgs>;
      transactionHistory?: boolean | User$transactionHistoryArgs<ExtArgs>;
      Craft?: boolean | User$CraftArgs<ExtArgs>;
      LeaderboardEntry?: boolean | User$LeaderboardEntryArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      stripeCustomerId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      nickname?: boolean;
      role?: boolean;
      isMfaEnabled?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      stripeCustomerId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      nickname?: boolean;
      role?: boolean;
      isMfaEnabled?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    image?: boolean;
    stripeCustomerId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    nickname?: boolean;
    role?: boolean;
    isMfaEnabled?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "email"
    | "emailVerified"
    | "image"
    | "stripeCustomerId"
    | "createdAt"
    | "updatedAt"
    | "nickname"
    | "role"
    | "isMfaEnabled",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    participations?: boolean | User$participationsArgs<ExtArgs>;
    createdChasses?: boolean | User$createdChassesArgs<ExtArgs>;
    collectedArtefacts?: boolean | User$collectedArtefactsArgs<ExtArgs>;
    virtualCurrency?: boolean | User$virtualCurrencyArgs<ExtArgs>;
    transactionHistory?: boolean | User$transactionHistoryArgs<ExtArgs>;
    Craft?: boolean | User$CraftArgs<ExtArgs>;
    LeaderboardEntry?: boolean | User$LeaderboardEntryArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      participations: Prisma.$ParticipationPayload<ExtArgs>[];
      createdChasses: Prisma.$TreasureHuntPayload<ExtArgs>[];
      collectedArtefacts: Prisma.$ArtefactPayload<ExtArgs>[];
      virtualCurrency: Prisma.$VirtualCurrencyPayload<ExtArgs>[];
      transactionHistory: Prisma.$TransactionHistoryPayload<ExtArgs>[];
      Craft: Prisma.$CraftPayload<ExtArgs>[];
      LeaderboardEntry: Prisma.$LeaderboardEntryPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        email: string;
        emailVerified: boolean;
        image: string | null;
        stripeCustomerId: string | null;
        createdAt: Date;
        updatedAt: Date;
        nickname: string | null;
        role: $Enums.UserRole;
        isMfaEnabled: boolean;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AccountPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    participations<T extends User$participationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$participationsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ParticipationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    createdChasses<T extends User$createdChassesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdChassesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TreasureHuntPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    collectedArtefacts<T extends User$collectedArtefactsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$collectedArtefactsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ArtefactPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    virtualCurrency<T extends User$virtualCurrencyArgs<ExtArgs> = {}>(
      args?: Subset<T, User$virtualCurrencyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$VirtualCurrencyPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    transactionHistory<T extends User$transactionHistoryArgs<ExtArgs> = {}>(
      args?: Subset<T, User$transactionHistoryArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TransactionHistoryPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Craft<T extends User$CraftArgs<ExtArgs> = {}>(
      args?: Subset<T, User$CraftArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CraftPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    LeaderboardEntry<T extends User$LeaderboardEntryArgs<ExtArgs> = {}>(
      args?: Subset<T, User$LeaderboardEntryArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LeaderboardEntryPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly emailVerified: FieldRef<"User", "Boolean">;
    readonly image: FieldRef<"User", "String">;
    readonly stripeCustomerId: FieldRef<"User", "String">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
    readonly nickname: FieldRef<"User", "String">;
    readonly role: FieldRef<"User", "UserRole">;
    readonly isMfaEnabled: FieldRef<"User", "Boolean">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.participations
   */
  export type User$participationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    where?: ParticipationWhereInput;
    orderBy?:
      | ParticipationOrderByWithRelationInput
      | ParticipationOrderByWithRelationInput[];
    cursor?: ParticipationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ParticipationScalarFieldEnum | ParticipationScalarFieldEnum[];
  };

  /**
   * User.createdChasses
   */
  export type User$createdChassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    where?: TreasureHuntWhereInput;
    orderBy?:
      | TreasureHuntOrderByWithRelationInput
      | TreasureHuntOrderByWithRelationInput[];
    cursor?: TreasureHuntWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TreasureHuntScalarFieldEnum | TreasureHuntScalarFieldEnum[];
  };

  /**
   * User.collectedArtefacts
   */
  export type User$collectedArtefactsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    where?: ArtefactWhereInput;
    orderBy?:
      | ArtefactOrderByWithRelationInput
      | ArtefactOrderByWithRelationInput[];
    cursor?: ArtefactWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ArtefactScalarFieldEnum | ArtefactScalarFieldEnum[];
  };

  /**
   * User.virtualCurrency
   */
  export type User$virtualCurrencyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    where?: VirtualCurrencyWhereInput;
    orderBy?:
      | VirtualCurrencyOrderByWithRelationInput
      | VirtualCurrencyOrderByWithRelationInput[];
    cursor?: VirtualCurrencyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | VirtualCurrencyScalarFieldEnum
      | VirtualCurrencyScalarFieldEnum[];
  };

  /**
   * User.transactionHistory
   */
  export type User$transactionHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    where?: TransactionHistoryWhereInput;
    orderBy?:
      | TransactionHistoryOrderByWithRelationInput
      | TransactionHistoryOrderByWithRelationInput[];
    cursor?: TransactionHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TransactionHistoryScalarFieldEnum
      | TransactionHistoryScalarFieldEnum[];
  };

  /**
   * User.Craft
   */
  export type User$CraftArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    where?: CraftWhereInput;
    orderBy?: CraftOrderByWithRelationInput | CraftOrderByWithRelationInput[];
    cursor?: CraftWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CraftScalarFieldEnum | CraftScalarFieldEnum[];
  };

  /**
   * User.LeaderboardEntry
   */
  export type User$LeaderboardEntryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    where?: LeaderboardEntryWhereInput;
    orderBy?:
      | LeaderboardEntryOrderByWithRelationInput
      | LeaderboardEntryOrderByWithRelationInput[];
    cursor?: LeaderboardEntryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | LeaderboardEntryScalarFieldEnum
      | LeaderboardEntryScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    expiresAt: Date | null;
    token: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    expiresAt: Date | null;
    token: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    expiresAt: number;
    token: number;
    createdAt: number;
    updatedAt: number;
    ipAddress: number;
    userAgent: number;
    userId: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    expiresAt?: true;
    token?: true;
    createdAt?: true;
    updatedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    expiresAt?: true;
    token?: true;
    createdAt?: true;
    updatedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    expiresAt?: true;
    token?: true;
    createdAt?: true;
    updatedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithAggregationInput
      | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    expiresAt: Date;
    token: string;
    createdAt: Date;
    updatedAt: Date;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type SessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      expiresAt?: boolean;
      token?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      expiresAt?: boolean;
      token?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      expiresAt?: boolean;
      token?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    expiresAt?: boolean;
    token?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    userId?: boolean;
  };

  export type SessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "expiresAt"
    | "token"
    | "createdAt"
    | "updatedAt"
    | "ipAddress"
    | "userAgent"
    | "userId",
    ExtArgs["result"]["session"]
  >;
  export type SessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Session";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        expiresAt: Date;
        token: string;
        createdAt: Date;
        updatedAt: Date;
        ipAddress: string | null;
        userAgent: string | null;
        userId: string;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type SessionGetPayload<
    S extends boolean | null | undefined | SessionDefaultArgs,
  > = $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Session"];
      meta: { name: "Session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>,
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs["orderBy"] }
        : { orderBy?: SessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", "String">;
    readonly expiresAt: FieldRef<"Session", "DateTime">;
    readonly token: FieldRef<"Session", "String">;
    readonly createdAt: FieldRef<"Session", "DateTime">;
    readonly updatedAt: FieldRef<"Session", "DateTime">;
    readonly ipAddress: FieldRef<"Session", "String">;
    readonly userAgent: FieldRef<"Session", "String">;
    readonly userId: FieldRef<"Session", "String">;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    accountId: string | null;
    providerId: string | null;
    userId: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    idToken: string | null;
    accessTokenExpiresAt: Date | null;
    refreshTokenExpiresAt: Date | null;
    scope: string | null;
    password: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    accountId: string | null;
    providerId: string | null;
    userId: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    idToken: string | null;
    accessTokenExpiresAt: Date | null;
    refreshTokenExpiresAt: Date | null;
    scope: string | null;
    password: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    accountId: number;
    providerId: number;
    userId: number;
    accessToken: number;
    refreshToken: number;
    idToken: number;
    accessTokenExpiresAt: number;
    refreshTokenExpiresAt: number;
    scope: number;
    password: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    accountId?: true;
    providerId?: true;
    userId?: true;
    accessToken?: true;
    refreshToken?: true;
    idToken?: true;
    accessTokenExpiresAt?: true;
    refreshTokenExpiresAt?: true;
    scope?: true;
    password?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    accountId?: true;
    providerId?: true;
    userId?: true;
    accessToken?: true;
    refreshToken?: true;
    idToken?: true;
    accessTokenExpiresAt?: true;
    refreshTokenExpiresAt?: true;
    scope?: true;
    password?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    accountId?: true;
    providerId?: true;
    userId?: true;
    accessToken?: true;
    refreshToken?: true;
    idToken?: true;
    accessTokenExpiresAt?: true;
    refreshTokenExpiresAt?: true;
    scope?: true;
    password?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithAggregationInput
      | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    accountId: string;
    providerId: string;
    userId: string;
    accessToken: string | null;
    refreshToken: string | null;
    idToken: string | null;
    accessTokenExpiresAt: Date | null;
    refreshTokenExpiresAt: Date | null;
    scope: string | null;
    password: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AccountCountAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AccountGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AccountGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>;
        }
      >
    >;

  export type AccountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      accountId?: boolean;
      providerId?: boolean;
      userId?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      idToken?: boolean;
      accessTokenExpiresAt?: boolean;
      refreshTokenExpiresAt?: boolean;
      scope?: boolean;
      password?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      accountId?: boolean;
      providerId?: boolean;
      userId?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      idToken?: boolean;
      accessTokenExpiresAt?: boolean;
      refreshTokenExpiresAt?: boolean;
      scope?: boolean;
      password?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      accountId?: boolean;
      providerId?: boolean;
      userId?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      idToken?: boolean;
      accessTokenExpiresAt?: boolean;
      refreshTokenExpiresAt?: boolean;
      scope?: boolean;
      password?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    accountId?: boolean;
    providerId?: boolean;
    userId?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    idToken?: boolean;
    accessTokenExpiresAt?: boolean;
    refreshTokenExpiresAt?: boolean;
    scope?: boolean;
    password?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AccountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "accountId"
    | "providerId"
    | "userId"
    | "accessToken"
    | "refreshToken"
    | "idToken"
    | "accessTokenExpiresAt"
    | "refreshTokenExpiresAt"
    | "scope"
    | "password"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["account"]
  >;
  export type AccountInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Account";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        accountId: string;
        providerId: string;
        userId: string;
        accessToken: string | null;
        refreshToken: string | null;
        idToken: string | null;
        accessTokenExpiresAt: Date | null;
        refreshTokenExpiresAt: Date | null;
        scope: string | null;
        password: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["account"]
    >;
    composites: {};
  };

  type AccountGetPayload<
    S extends boolean | null | undefined | AccountDefaultArgs,
  > = $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AccountFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Account"];
      meta: { name: "Account" };
    };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>,
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>,
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs["orderBy"] }
        : { orderBy?: AccountGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAccountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", "String">;
    readonly accountId: FieldRef<"Account", "String">;
    readonly providerId: FieldRef<"Account", "String">;
    readonly userId: FieldRef<"Account", "String">;
    readonly accessToken: FieldRef<"Account", "String">;
    readonly refreshToken: FieldRef<"Account", "String">;
    readonly idToken: FieldRef<"Account", "String">;
    readonly accessTokenExpiresAt: FieldRef<"Account", "DateTime">;
    readonly refreshTokenExpiresAt: FieldRef<"Account", "DateTime">;
    readonly scope: FieldRef<"Account", "String">;
    readonly password: FieldRef<"Account", "String">;
    readonly createdAt: FieldRef<"Account", "DateTime">;
    readonly updatedAt: FieldRef<"Account", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null;
    _min: VerificationMinAggregateOutputType | null;
    _max: VerificationMaxAggregateOutputType | null;
  };

  export type VerificationMinAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    value: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VerificationMaxAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    value: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VerificationCountAggregateOutputType = {
    id: number;
    identifier: number;
    value: number;
    expiresAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type VerificationMinAggregateInputType = {
    id?: true;
    identifier?: true;
    value?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VerificationMaxAggregateInputType = {
    id?: true;
    identifier?: true;
    value?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VerificationCountAggregateInputType = {
    id?: true;
    identifier?: true;
    value?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type VerificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Verifications to fetch.
     */
    orderBy?:
      | VerificationOrderByWithRelationInput
      | VerificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Verifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Verifications
     **/
    _count?: true | VerificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationMaxAggregateInputType;
  };

  export type GetVerificationAggregateType<
    T extends VerificationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVerification]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>;
  };

  export type VerificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationWhereInput;
    orderBy?:
      | VerificationOrderByWithAggregationInput
      | VerificationOrderByWithAggregationInput[];
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum;
    having?: VerificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationCountAggregateInputType | true;
    _min?: VerificationMinAggregateInputType;
    _max?: VerificationMaxAggregateInputType;
  };

  export type VerificationGroupByOutputType = {
    id: string;
    identifier: string;
    value: string;
    expiresAt: Date;
    createdAt: Date | null;
    updatedAt: Date | null;
    _count: VerificationCountAggregateOutputType | null;
    _min: VerificationMinAggregateOutputType | null;
    _max: VerificationMaxAggregateOutputType | null;
  };

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VerificationGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof VerificationGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>;
        }
      >
    >;

  export type VerificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      identifier?: boolean;
      value?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["verification"]
  >;

  export type VerificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      identifier?: boolean;
      value?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["verification"]
  >;

  export type VerificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      identifier?: boolean;
      value?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["verification"]
  >;

  export type VerificationSelectScalar = {
    id?: boolean;
    identifier?: boolean;
    value?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type VerificationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt",
    ExtArgs["result"]["verification"]
  >;

  export type $VerificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Verification";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        identifier: string;
        value: string;
        expiresAt: Date;
        createdAt: Date | null;
        updatedAt: Date | null;
      },
      ExtArgs["result"]["verification"]
    >;
    composites: {};
  };

  type VerificationGetPayload<
    S extends boolean | null | undefined | VerificationDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationPayload, S>;

  type VerificationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    VerificationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: VerificationCountAggregateInputType | true;
  };

  export interface VerificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Verification"];
      meta: { name: "Verification" };
    };
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(
      args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(
      args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     *
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends VerificationFindManyArgs>(
      args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     *
     */
    create<T extends VerificationCreateArgs>(
      args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationCreateManyArgs>(
      args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     *
     */
    delete<T extends VerificationDeleteArgs>(
      args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationUpdateArgs>(
      args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationDeleteManyArgs>(
      args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationUpdateManyArgs>(
      args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(
      args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>,
    ): Prisma__VerificationClient<
      $Result.GetResult<
        Prisma.$VerificationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
     **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], VerificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationAggregateArgs>(
      args: Subset<T, VerificationAggregateArgs>,
    ): Prisma.PrismaPromise<GetVerificationAggregateType<T>>;

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs["orderBy"] }
        : { orderBy?: VerificationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetVerificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Verification model
     */
    readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", "String">;
    readonly identifier: FieldRef<"Verification", "String">;
    readonly value: FieldRef<"Verification", "String">;
    readonly expiresAt: FieldRef<"Verification", "DateTime">;
    readonly createdAt: FieldRef<"Verification", "DateTime">;
    readonly updatedAt: FieldRef<"Verification", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput;
  };

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput;
  };

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Verifications to fetch.
     */
    orderBy?:
      | VerificationOrderByWithRelationInput
      | VerificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Verifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[];
  };

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Verifications to fetch.
     */
    orderBy?:
      | VerificationOrderByWithRelationInput
      | VerificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Verifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[];
  };

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Verifications to fetch.
     */
    orderBy?:
      | VerificationOrderByWithRelationInput
      | VerificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Verifications.
     */
    skip?: number;
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[];
  };

  /**
   * Verification create
   */
  export type VerificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>;
  };

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>;
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput;
  };

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<
      VerificationUpdateManyMutationInput,
      VerificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput;
    /**
     * Limit how many Verifications to update.
     */
    limit?: number;
  };

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * The data used to update Verifications.
     */
    data: XOR<
      VerificationUpdateManyMutationInput,
      VerificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput;
    /**
     * Limit how many Verifications to update.
     */
    limit?: number;
  };

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput;
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>;
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>;
  };

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput;
  };

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput;
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number;
  };

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null;
  };

  /**
   * Model TreasureHunt
   */

  export type AggregateTreasureHunt = {
    _count: TreasureHuntCountAggregateOutputType | null;
    _avg: TreasureHuntAvgAggregateOutputType | null;
    _sum: TreasureHuntSumAggregateOutputType | null;
    _min: TreasureHuntMinAggregateOutputType | null;
    _max: TreasureHuntMaxAggregateOutputType | null;
  };

  export type TreasureHuntAvgAggregateOutputType = {
    fee: number | null;
  };

  export type TreasureHuntSumAggregateOutputType = {
    fee: number | null;
  };

  export type TreasureHuntMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    createdById: string | null;
    startDate: Date | null;
    endDate: Date | null;
    location: string | null;
    mode: $Enums.HuntMode | null;
    fee: number | null;
    mapStyle: string | null;
    isFinished: boolean | null;
    status: $Enums.HuntStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TreasureHuntMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    createdById: string | null;
    startDate: Date | null;
    endDate: Date | null;
    location: string | null;
    mode: $Enums.HuntMode | null;
    fee: number | null;
    mapStyle: string | null;
    isFinished: boolean | null;
    status: $Enums.HuntStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TreasureHuntCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    createdById: number;
    startDate: number;
    endDate: number;
    location: number;
    mode: number;
    fee: number;
    mapStyle: number;
    isFinished: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TreasureHuntAvgAggregateInputType = {
    fee?: true;
  };

  export type TreasureHuntSumAggregateInputType = {
    fee?: true;
  };

  export type TreasureHuntMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    createdById?: true;
    startDate?: true;
    endDate?: true;
    location?: true;
    mode?: true;
    fee?: true;
    mapStyle?: true;
    isFinished?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TreasureHuntMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    createdById?: true;
    startDate?: true;
    endDate?: true;
    location?: true;
    mode?: true;
    fee?: true;
    mapStyle?: true;
    isFinished?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TreasureHuntCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    createdById?: true;
    startDate?: true;
    endDate?: true;
    location?: true;
    mode?: true;
    fee?: true;
    mapStyle?: true;
    isFinished?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TreasureHuntAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TreasureHunt to aggregate.
     */
    where?: TreasureHuntWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TreasureHunts to fetch.
     */
    orderBy?:
      | TreasureHuntOrderByWithRelationInput
      | TreasureHuntOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TreasureHuntWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TreasureHunts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TreasureHunts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TreasureHunts
     **/
    _count?: true | TreasureHuntCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TreasureHuntAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TreasureHuntSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TreasureHuntMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TreasureHuntMaxAggregateInputType;
  };

  export type GetTreasureHuntAggregateType<
    T extends TreasureHuntAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTreasureHunt]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreasureHunt[P]>
      : GetScalarType<T[P], AggregateTreasureHunt[P]>;
  };

  export type TreasureHuntGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TreasureHuntWhereInput;
    orderBy?:
      | TreasureHuntOrderByWithAggregationInput
      | TreasureHuntOrderByWithAggregationInput[];
    by: TreasureHuntScalarFieldEnum[] | TreasureHuntScalarFieldEnum;
    having?: TreasureHuntScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TreasureHuntCountAggregateInputType | true;
    _avg?: TreasureHuntAvgAggregateInputType;
    _sum?: TreasureHuntSumAggregateInputType;
    _min?: TreasureHuntMinAggregateInputType;
    _max?: TreasureHuntMaxAggregateInputType;
  };

  export type TreasureHuntGroupByOutputType = {
    id: string;
    title: string;
    description: string | null;
    createdById: string;
    startDate: Date | null;
    endDate: Date | null;
    location: string | null;
    mode: $Enums.HuntMode;
    fee: number | null;
    mapStyle: string | null;
    isFinished: boolean;
    status: $Enums.HuntStatus;
    createdAt: Date;
    updatedAt: Date;
    _count: TreasureHuntCountAggregateOutputType | null;
    _avg: TreasureHuntAvgAggregateOutputType | null;
    _sum: TreasureHuntSumAggregateOutputType | null;
    _min: TreasureHuntMinAggregateOutputType | null;
    _max: TreasureHuntMaxAggregateOutputType | null;
  };

  type GetTreasureHuntGroupByPayload<T extends TreasureHuntGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TreasureHuntGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof TreasureHuntGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreasureHuntGroupByOutputType[P]>
            : GetScalarType<T[P], TreasureHuntGroupByOutputType[P]>;
        }
      >
    >;

  export type TreasureHuntSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      createdById?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      location?: boolean;
      mode?: boolean;
      fee?: boolean;
      mapStyle?: boolean;
      isFinished?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      participants?: boolean | TreasureHunt$participantsArgs<ExtArgs>;
      steps?: boolean | TreasureHunt$stepsArgs<ExtArgs>;
      rewards?: boolean | TreasureHunt$rewardsArgs<ExtArgs>;
      artefacts?: boolean | TreasureHunt$artefactsArgs<ExtArgs>;
      LeaderboardEntry?: boolean | TreasureHunt$LeaderboardEntryArgs<ExtArgs>;
      _count?: boolean | TreasureHuntCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["treasureHunt"]
  >;

  export type TreasureHuntSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      createdById?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      location?: boolean;
      mode?: boolean;
      fee?: boolean;
      mapStyle?: boolean;
      isFinished?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["treasureHunt"]
  >;

  export type TreasureHuntSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      createdById?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      location?: boolean;
      mode?: boolean;
      fee?: boolean;
      mapStyle?: boolean;
      isFinished?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["treasureHunt"]
  >;

  export type TreasureHuntSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    createdById?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    location?: boolean;
    mode?: boolean;
    fee?: boolean;
    mapStyle?: boolean;
    isFinished?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TreasureHuntOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "title"
    | "description"
    | "createdById"
    | "startDate"
    | "endDate"
    | "location"
    | "mode"
    | "fee"
    | "mapStyle"
    | "isFinished"
    | "status"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["treasureHunt"]
  >;
  export type TreasureHuntInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    participants?: boolean | TreasureHunt$participantsArgs<ExtArgs>;
    steps?: boolean | TreasureHunt$stepsArgs<ExtArgs>;
    rewards?: boolean | TreasureHunt$rewardsArgs<ExtArgs>;
    artefacts?: boolean | TreasureHunt$artefactsArgs<ExtArgs>;
    LeaderboardEntry?: boolean | TreasureHunt$LeaderboardEntryArgs<ExtArgs>;
    _count?: boolean | TreasureHuntCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TreasureHuntIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type TreasureHuntIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TreasureHuntPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TreasureHunt";
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>;
      participants: Prisma.$ParticipationPayload<ExtArgs>[];
      steps: Prisma.$HuntStepPayload<ExtArgs>[];
      rewards: Prisma.$RewardPayload<ExtArgs>[];
      artefacts: Prisma.$ArtefactPayload<ExtArgs>[];
      LeaderboardEntry: Prisma.$LeaderboardEntryPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string | null;
        createdById: string;
        startDate: Date | null;
        endDate: Date | null;
        location: string | null;
        mode: $Enums.HuntMode;
        fee: number | null;
        mapStyle: string | null;
        isFinished: boolean;
        status: $Enums.HuntStatus;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["treasureHunt"]
    >;
    composites: {};
  };

  type TreasureHuntGetPayload<
    S extends boolean | null | undefined | TreasureHuntDefaultArgs,
  > = $Result.GetResult<Prisma.$TreasureHuntPayload, S>;

  type TreasureHuntCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TreasureHuntFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TreasureHuntCountAggregateInputType | true;
  };

  export interface TreasureHuntDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TreasureHunt"];
      meta: { name: "TreasureHunt" };
    };
    /**
     * Find zero or one TreasureHunt that matches the filter.
     * @param {TreasureHuntFindUniqueArgs} args - Arguments to find a TreasureHunt
     * @example
     * // Get one TreasureHunt
     * const treasureHunt = await prisma.treasureHunt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreasureHuntFindUniqueArgs>(
      args: SelectSubset<T, TreasureHuntFindUniqueArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TreasureHunt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TreasureHuntFindUniqueOrThrowArgs} args - Arguments to find a TreasureHunt
     * @example
     * // Get one TreasureHunt
     * const treasureHunt = await prisma.treasureHunt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreasureHuntFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TreasureHuntFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TreasureHunt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntFindFirstArgs} args - Arguments to find a TreasureHunt
     * @example
     * // Get one TreasureHunt
     * const treasureHunt = await prisma.treasureHunt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreasureHuntFindFirstArgs>(
      args?: SelectSubset<T, TreasureHuntFindFirstArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TreasureHunt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntFindFirstOrThrowArgs} args - Arguments to find a TreasureHunt
     * @example
     * // Get one TreasureHunt
     * const treasureHunt = await prisma.treasureHunt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreasureHuntFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TreasureHuntFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TreasureHunts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreasureHunts
     * const treasureHunts = await prisma.treasureHunt.findMany()
     *
     * // Get first 10 TreasureHunts
     * const treasureHunts = await prisma.treasureHunt.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const treasureHuntWithIdOnly = await prisma.treasureHunt.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TreasureHuntFindManyArgs>(
      args?: SelectSubset<T, TreasureHuntFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TreasureHunt.
     * @param {TreasureHuntCreateArgs} args - Arguments to create a TreasureHunt.
     * @example
     * // Create one TreasureHunt
     * const TreasureHunt = await prisma.treasureHunt.create({
     *   data: {
     *     // ... data to create a TreasureHunt
     *   }
     * })
     *
     */
    create<T extends TreasureHuntCreateArgs>(
      args: SelectSubset<T, TreasureHuntCreateArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TreasureHunts.
     * @param {TreasureHuntCreateManyArgs} args - Arguments to create many TreasureHunts.
     * @example
     * // Create many TreasureHunts
     * const treasureHunt = await prisma.treasureHunt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TreasureHuntCreateManyArgs>(
      args?: SelectSubset<T, TreasureHuntCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TreasureHunts and returns the data saved in the database.
     * @param {TreasureHuntCreateManyAndReturnArgs} args - Arguments to create many TreasureHunts.
     * @example
     * // Create many TreasureHunts
     * const treasureHunt = await prisma.treasureHunt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TreasureHunts and only return the `id`
     * const treasureHuntWithIdOnly = await prisma.treasureHunt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TreasureHuntCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TreasureHuntCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a TreasureHunt.
     * @param {TreasureHuntDeleteArgs} args - Arguments to delete one TreasureHunt.
     * @example
     * // Delete one TreasureHunt
     * const TreasureHunt = await prisma.treasureHunt.delete({
     *   where: {
     *     // ... filter to delete one TreasureHunt
     *   }
     * })
     *
     */
    delete<T extends TreasureHuntDeleteArgs>(
      args: SelectSubset<T, TreasureHuntDeleteArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TreasureHunt.
     * @param {TreasureHuntUpdateArgs} args - Arguments to update one TreasureHunt.
     * @example
     * // Update one TreasureHunt
     * const treasureHunt = await prisma.treasureHunt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TreasureHuntUpdateArgs>(
      args: SelectSubset<T, TreasureHuntUpdateArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TreasureHunts.
     * @param {TreasureHuntDeleteManyArgs} args - Arguments to filter TreasureHunts to delete.
     * @example
     * // Delete a few TreasureHunts
     * const { count } = await prisma.treasureHunt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TreasureHuntDeleteManyArgs>(
      args?: SelectSubset<T, TreasureHuntDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TreasureHunts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreasureHunts
     * const treasureHunt = await prisma.treasureHunt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TreasureHuntUpdateManyArgs>(
      args: SelectSubset<T, TreasureHuntUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TreasureHunts and returns the data updated in the database.
     * @param {TreasureHuntUpdateManyAndReturnArgs} args - Arguments to update many TreasureHunts.
     * @example
     * // Update many TreasureHunts
     * const treasureHunt = await prisma.treasureHunt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TreasureHunts and only return the `id`
     * const treasureHuntWithIdOnly = await prisma.treasureHunt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TreasureHuntUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TreasureHuntUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one TreasureHunt.
     * @param {TreasureHuntUpsertArgs} args - Arguments to update or create a TreasureHunt.
     * @example
     * // Update or create a TreasureHunt
     * const treasureHunt = await prisma.treasureHunt.upsert({
     *   create: {
     *     // ... data to create a TreasureHunt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreasureHunt we want to update
     *   }
     * })
     */
    upsert<T extends TreasureHuntUpsertArgs>(
      args: SelectSubset<T, TreasureHuntUpsertArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TreasureHunts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntCountArgs} args - Arguments to filter TreasureHunts to count.
     * @example
     * // Count the number of TreasureHunts
     * const count = await prisma.treasureHunt.count({
     *   where: {
     *     // ... the filter for the TreasureHunts we want to count
     *   }
     * })
     **/
    count<T extends TreasureHuntCountArgs>(
      args?: Subset<T, TreasureHuntCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TreasureHuntCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TreasureHunt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TreasureHuntAggregateArgs>(
      args: Subset<T, TreasureHuntAggregateArgs>,
    ): Prisma.PrismaPromise<GetTreasureHuntAggregateType<T>>;

    /**
     * Group by TreasureHunt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasureHuntGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TreasureHuntGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreasureHuntGroupByArgs["orderBy"] }
        : { orderBy?: TreasureHuntGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TreasureHuntGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTreasureHuntGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TreasureHunt model
     */
    readonly fields: TreasureHuntFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreasureHunt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreasureHuntClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    participants<T extends TreasureHunt$participantsArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHunt$participantsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ParticipationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    steps<T extends TreasureHunt$stepsArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHunt$stepsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$HuntStepPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    rewards<T extends TreasureHunt$rewardsArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHunt$rewardsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RewardPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    artefacts<T extends TreasureHunt$artefactsArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHunt$artefactsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ArtefactPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    LeaderboardEntry<T extends TreasureHunt$LeaderboardEntryArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHunt$LeaderboardEntryArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LeaderboardEntryPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TreasureHunt model
   */
  interface TreasureHuntFieldRefs {
    readonly id: FieldRef<"TreasureHunt", "String">;
    readonly title: FieldRef<"TreasureHunt", "String">;
    readonly description: FieldRef<"TreasureHunt", "String">;
    readonly createdById: FieldRef<"TreasureHunt", "String">;
    readonly startDate: FieldRef<"TreasureHunt", "DateTime">;
    readonly endDate: FieldRef<"TreasureHunt", "DateTime">;
    readonly location: FieldRef<"TreasureHunt", "String">;
    readonly mode: FieldRef<"TreasureHunt", "HuntMode">;
    readonly fee: FieldRef<"TreasureHunt", "Int">;
    readonly mapStyle: FieldRef<"TreasureHunt", "String">;
    readonly isFinished: FieldRef<"TreasureHunt", "Boolean">;
    readonly status: FieldRef<"TreasureHunt", "HuntStatus">;
    readonly createdAt: FieldRef<"TreasureHunt", "DateTime">;
    readonly updatedAt: FieldRef<"TreasureHunt", "DateTime">;
  }

  // Custom InputTypes
  /**
   * TreasureHunt findUnique
   */
  export type TreasureHuntFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * Filter, which TreasureHunt to fetch.
     */
    where: TreasureHuntWhereUniqueInput;
  };

  /**
   * TreasureHunt findUniqueOrThrow
   */
  export type TreasureHuntFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * Filter, which TreasureHunt to fetch.
     */
    where: TreasureHuntWhereUniqueInput;
  };

  /**
   * TreasureHunt findFirst
   */
  export type TreasureHuntFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * Filter, which TreasureHunt to fetch.
     */
    where?: TreasureHuntWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TreasureHunts to fetch.
     */
    orderBy?:
      | TreasureHuntOrderByWithRelationInput
      | TreasureHuntOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TreasureHunts.
     */
    cursor?: TreasureHuntWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TreasureHunts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TreasureHunts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TreasureHunts.
     */
    distinct?: TreasureHuntScalarFieldEnum | TreasureHuntScalarFieldEnum[];
  };

  /**
   * TreasureHunt findFirstOrThrow
   */
  export type TreasureHuntFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * Filter, which TreasureHunt to fetch.
     */
    where?: TreasureHuntWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TreasureHunts to fetch.
     */
    orderBy?:
      | TreasureHuntOrderByWithRelationInput
      | TreasureHuntOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TreasureHunts.
     */
    cursor?: TreasureHuntWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TreasureHunts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TreasureHunts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TreasureHunts.
     */
    distinct?: TreasureHuntScalarFieldEnum | TreasureHuntScalarFieldEnum[];
  };

  /**
   * TreasureHunt findMany
   */
  export type TreasureHuntFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * Filter, which TreasureHunts to fetch.
     */
    where?: TreasureHuntWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TreasureHunts to fetch.
     */
    orderBy?:
      | TreasureHuntOrderByWithRelationInput
      | TreasureHuntOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TreasureHunts.
     */
    cursor?: TreasureHuntWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TreasureHunts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TreasureHunts.
     */
    skip?: number;
    distinct?: TreasureHuntScalarFieldEnum | TreasureHuntScalarFieldEnum[];
  };

  /**
   * TreasureHunt create
   */
  export type TreasureHuntCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * The data needed to create a TreasureHunt.
     */
    data: XOR<TreasureHuntCreateInput, TreasureHuntUncheckedCreateInput>;
  };

  /**
   * TreasureHunt createMany
   */
  export type TreasureHuntCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TreasureHunts.
     */
    data: TreasureHuntCreateManyInput | TreasureHuntCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TreasureHunt createManyAndReturn
   */
  export type TreasureHuntCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * The data used to create many TreasureHunts.
     */
    data: TreasureHuntCreateManyInput | TreasureHuntCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TreasureHunt update
   */
  export type TreasureHuntUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * The data needed to update a TreasureHunt.
     */
    data: XOR<TreasureHuntUpdateInput, TreasureHuntUncheckedUpdateInput>;
    /**
     * Choose, which TreasureHunt to update.
     */
    where: TreasureHuntWhereUniqueInput;
  };

  /**
   * TreasureHunt updateMany
   */
  export type TreasureHuntUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TreasureHunts.
     */
    data: XOR<
      TreasureHuntUpdateManyMutationInput,
      TreasureHuntUncheckedUpdateManyInput
    >;
    /**
     * Filter which TreasureHunts to update
     */
    where?: TreasureHuntWhereInput;
    /**
     * Limit how many TreasureHunts to update.
     */
    limit?: number;
  };

  /**
   * TreasureHunt updateManyAndReturn
   */
  export type TreasureHuntUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * The data used to update TreasureHunts.
     */
    data: XOR<
      TreasureHuntUpdateManyMutationInput,
      TreasureHuntUncheckedUpdateManyInput
    >;
    /**
     * Filter which TreasureHunts to update
     */
    where?: TreasureHuntWhereInput;
    /**
     * Limit how many TreasureHunts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TreasureHunt upsert
   */
  export type TreasureHuntUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * The filter to search for the TreasureHunt to update in case it exists.
     */
    where: TreasureHuntWhereUniqueInput;
    /**
     * In case the TreasureHunt found by the `where` argument doesn't exist, create a new TreasureHunt with this data.
     */
    create: XOR<TreasureHuntCreateInput, TreasureHuntUncheckedCreateInput>;
    /**
     * In case the TreasureHunt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreasureHuntUpdateInput, TreasureHuntUncheckedUpdateInput>;
  };

  /**
   * TreasureHunt delete
   */
  export type TreasureHuntDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    /**
     * Filter which TreasureHunt to delete.
     */
    where: TreasureHuntWhereUniqueInput;
  };

  /**
   * TreasureHunt deleteMany
   */
  export type TreasureHuntDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TreasureHunts to delete
     */
    where?: TreasureHuntWhereInput;
    /**
     * Limit how many TreasureHunts to delete.
     */
    limit?: number;
  };

  /**
   * TreasureHunt.participants
   */
  export type TreasureHunt$participantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    where?: ParticipationWhereInput;
    orderBy?:
      | ParticipationOrderByWithRelationInput
      | ParticipationOrderByWithRelationInput[];
    cursor?: ParticipationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ParticipationScalarFieldEnum | ParticipationScalarFieldEnum[];
  };

  /**
   * TreasureHunt.steps
   */
  export type TreasureHunt$stepsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    where?: HuntStepWhereInput;
    orderBy?:
      | HuntStepOrderByWithRelationInput
      | HuntStepOrderByWithRelationInput[];
    cursor?: HuntStepWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: HuntStepScalarFieldEnum | HuntStepScalarFieldEnum[];
  };

  /**
   * TreasureHunt.rewards
   */
  export type TreasureHunt$rewardsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    where?: RewardWhereInput;
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[];
    cursor?: RewardWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[];
  };

  /**
   * TreasureHunt.artefacts
   */
  export type TreasureHunt$artefactsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    where?: ArtefactWhereInput;
    orderBy?:
      | ArtefactOrderByWithRelationInput
      | ArtefactOrderByWithRelationInput[];
    cursor?: ArtefactWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ArtefactScalarFieldEnum | ArtefactScalarFieldEnum[];
  };

  /**
   * TreasureHunt.LeaderboardEntry
   */
  export type TreasureHunt$LeaderboardEntryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    where?: LeaderboardEntryWhereInput;
    orderBy?:
      | LeaderboardEntryOrderByWithRelationInput
      | LeaderboardEntryOrderByWithRelationInput[];
    cursor?: LeaderboardEntryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | LeaderboardEntryScalarFieldEnum
      | LeaderboardEntryScalarFieldEnum[];
  };

  /**
   * TreasureHunt without action
   */
  export type TreasureHuntDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
  };

  /**
   * Model Participation
   */

  export type AggregateParticipation = {
    _count: ParticipationCountAggregateOutputType | null;
    _min: ParticipationMinAggregateOutputType | null;
    _max: ParticipationMaxAggregateOutputType | null;
  };

  export type ParticipationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    huntId: string | null;
    status: $Enums.ParticipationStatus | null;
    joinDate: Date | null;
  };

  export type ParticipationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    huntId: string | null;
    status: $Enums.ParticipationStatus | null;
    joinDate: Date | null;
  };

  export type ParticipationCountAggregateOutputType = {
    id: number;
    userId: number;
    huntId: number;
    status: number;
    joinDate: number;
    _all: number;
  };

  export type ParticipationMinAggregateInputType = {
    id?: true;
    userId?: true;
    huntId?: true;
    status?: true;
    joinDate?: true;
  };

  export type ParticipationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    huntId?: true;
    status?: true;
    joinDate?: true;
  };

  export type ParticipationCountAggregateInputType = {
    id?: true;
    userId?: true;
    huntId?: true;
    status?: true;
    joinDate?: true;
    _all?: true;
  };

  export type ParticipationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Participation to aggregate.
     */
    where?: ParticipationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Participations to fetch.
     */
    orderBy?:
      | ParticipationOrderByWithRelationInput
      | ParticipationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ParticipationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Participations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Participations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Participations
     **/
    _count?: true | ParticipationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ParticipationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ParticipationMaxAggregateInputType;
  };

  export type GetParticipationAggregateType<
    T extends ParticipationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateParticipation]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipation[P]>
      : GetScalarType<T[P], AggregateParticipation[P]>;
  };

  export type ParticipationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ParticipationWhereInput;
    orderBy?:
      | ParticipationOrderByWithAggregationInput
      | ParticipationOrderByWithAggregationInput[];
    by: ParticipationScalarFieldEnum[] | ParticipationScalarFieldEnum;
    having?: ParticipationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ParticipationCountAggregateInputType | true;
    _min?: ParticipationMinAggregateInputType;
    _max?: ParticipationMaxAggregateInputType;
  };

  export type ParticipationGroupByOutputType = {
    id: string;
    userId: string;
    huntId: string;
    status: $Enums.ParticipationStatus;
    joinDate: Date;
    _count: ParticipationCountAggregateOutputType | null;
    _min: ParticipationMinAggregateOutputType | null;
    _max: ParticipationMaxAggregateOutputType | null;
  };

  type GetParticipationGroupByPayload<T extends ParticipationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ParticipationGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ParticipationGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipationGroupByOutputType[P]>;
        }
      >
    >;

  export type ParticipationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      huntId?: boolean;
      status?: boolean;
      joinDate?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["participation"]
  >;

  export type ParticipationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      huntId?: boolean;
      status?: boolean;
      joinDate?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["participation"]
  >;

  export type ParticipationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      huntId?: boolean;
      status?: boolean;
      joinDate?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["participation"]
  >;

  export type ParticipationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    huntId?: boolean;
    status?: boolean;
    joinDate?: boolean;
  };

  export type ParticipationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "huntId" | "status" | "joinDate",
    ExtArgs["result"]["participation"]
  >;
  export type ParticipationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type ParticipationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type ParticipationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };

  export type $ParticipationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Participation";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      treasureHunt: Prisma.$TreasureHuntPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        huntId: string;
        status: $Enums.ParticipationStatus;
        joinDate: Date;
      },
      ExtArgs["result"]["participation"]
    >;
    composites: {};
  };

  type ParticipationGetPayload<
    S extends boolean | null | undefined | ParticipationDefaultArgs,
  > = $Result.GetResult<Prisma.$ParticipationPayload, S>;

  type ParticipationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ParticipationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ParticipationCountAggregateInputType | true;
  };

  export interface ParticipationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Participation"];
      meta: { name: "Participation" };
    };
    /**
     * Find zero or one Participation that matches the filter.
     * @param {ParticipationFindUniqueArgs} args - Arguments to find a Participation
     * @example
     * // Get one Participation
     * const participation = await prisma.participation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipationFindUniqueArgs>(
      args: SelectSubset<T, ParticipationFindUniqueArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Participation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParticipationFindUniqueOrThrowArgs} args - Arguments to find a Participation
     * @example
     * // Get one Participation
     * const participation = await prisma.participation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ParticipationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Participation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationFindFirstArgs} args - Arguments to find a Participation
     * @example
     * // Get one Participation
     * const participation = await prisma.participation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipationFindFirstArgs>(
      args?: SelectSubset<T, ParticipationFindFirstArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Participation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationFindFirstOrThrowArgs} args - Arguments to find a Participation
     * @example
     * // Get one Participation
     * const participation = await prisma.participation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ParticipationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Participations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participations
     * const participations = await prisma.participation.findMany()
     *
     * // Get first 10 Participations
     * const participations = await prisma.participation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const participationWithIdOnly = await prisma.participation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ParticipationFindManyArgs>(
      args?: SelectSubset<T, ParticipationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Participation.
     * @param {ParticipationCreateArgs} args - Arguments to create a Participation.
     * @example
     * // Create one Participation
     * const Participation = await prisma.participation.create({
     *   data: {
     *     // ... data to create a Participation
     *   }
     * })
     *
     */
    create<T extends ParticipationCreateArgs>(
      args: SelectSubset<T, ParticipationCreateArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Participations.
     * @param {ParticipationCreateManyArgs} args - Arguments to create many Participations.
     * @example
     * // Create many Participations
     * const participation = await prisma.participation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ParticipationCreateManyArgs>(
      args?: SelectSubset<T, ParticipationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Participations and returns the data saved in the database.
     * @param {ParticipationCreateManyAndReturnArgs} args - Arguments to create many Participations.
     * @example
     * // Create many Participations
     * const participation = await prisma.participation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Participations and only return the `id`
     * const participationWithIdOnly = await prisma.participation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ParticipationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ParticipationCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Participation.
     * @param {ParticipationDeleteArgs} args - Arguments to delete one Participation.
     * @example
     * // Delete one Participation
     * const Participation = await prisma.participation.delete({
     *   where: {
     *     // ... filter to delete one Participation
     *   }
     * })
     *
     */
    delete<T extends ParticipationDeleteArgs>(
      args: SelectSubset<T, ParticipationDeleteArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Participation.
     * @param {ParticipationUpdateArgs} args - Arguments to update one Participation.
     * @example
     * // Update one Participation
     * const participation = await prisma.participation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ParticipationUpdateArgs>(
      args: SelectSubset<T, ParticipationUpdateArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Participations.
     * @param {ParticipationDeleteManyArgs} args - Arguments to filter Participations to delete.
     * @example
     * // Delete a few Participations
     * const { count } = await prisma.participation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ParticipationDeleteManyArgs>(
      args?: SelectSubset<T, ParticipationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Participations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participations
     * const participation = await prisma.participation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ParticipationUpdateManyArgs>(
      args: SelectSubset<T, ParticipationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Participations and returns the data updated in the database.
     * @param {ParticipationUpdateManyAndReturnArgs} args - Arguments to update many Participations.
     * @example
     * // Update many Participations
     * const participation = await prisma.participation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Participations and only return the `id`
     * const participationWithIdOnly = await prisma.participation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ParticipationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ParticipationUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Participation.
     * @param {ParticipationUpsertArgs} args - Arguments to update or create a Participation.
     * @example
     * // Update or create a Participation
     * const participation = await prisma.participation.upsert({
     *   create: {
     *     // ... data to create a Participation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participation we want to update
     *   }
     * })
     */
    upsert<T extends ParticipationUpsertArgs>(
      args: SelectSubset<T, ParticipationUpsertArgs<ExtArgs>>,
    ): Prisma__ParticipationClient<
      $Result.GetResult<
        Prisma.$ParticipationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Participations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationCountArgs} args - Arguments to filter Participations to count.
     * @example
     * // Count the number of Participations
     * const count = await prisma.participation.count({
     *   where: {
     *     // ... the filter for the Participations we want to count
     *   }
     * })
     **/
    count<T extends ParticipationCountArgs>(
      args?: Subset<T, ParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ParticipationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Participation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ParticipationAggregateArgs>(
      args: Subset<T, ParticipationAggregateArgs>,
    ): Prisma.PrismaPromise<GetParticipationAggregateType<T>>;

    /**
     * Group by Participation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipationGroupByArgs["orderBy"] }
        : { orderBy?: ParticipationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ParticipationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetParticipationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Participation model
     */
    readonly fields: ParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Participation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    treasureHunt<T extends TreasureHuntDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHuntDefaultArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      | $Result.GetResult<
          Prisma.$TreasureHuntPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Participation model
   */
  interface ParticipationFieldRefs {
    readonly id: FieldRef<"Participation", "String">;
    readonly userId: FieldRef<"Participation", "String">;
    readonly huntId: FieldRef<"Participation", "String">;
    readonly status: FieldRef<"Participation", "ParticipationStatus">;
    readonly joinDate: FieldRef<"Participation", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Participation findUnique
   */
  export type ParticipationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * Filter, which Participation to fetch.
     */
    where: ParticipationWhereUniqueInput;
  };

  /**
   * Participation findUniqueOrThrow
   */
  export type ParticipationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * Filter, which Participation to fetch.
     */
    where: ParticipationWhereUniqueInput;
  };

  /**
   * Participation findFirst
   */
  export type ParticipationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * Filter, which Participation to fetch.
     */
    where?: ParticipationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Participations to fetch.
     */
    orderBy?:
      | ParticipationOrderByWithRelationInput
      | ParticipationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Participations.
     */
    cursor?: ParticipationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Participations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Participations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Participations.
     */
    distinct?: ParticipationScalarFieldEnum | ParticipationScalarFieldEnum[];
  };

  /**
   * Participation findFirstOrThrow
   */
  export type ParticipationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * Filter, which Participation to fetch.
     */
    where?: ParticipationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Participations to fetch.
     */
    orderBy?:
      | ParticipationOrderByWithRelationInput
      | ParticipationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Participations.
     */
    cursor?: ParticipationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Participations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Participations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Participations.
     */
    distinct?: ParticipationScalarFieldEnum | ParticipationScalarFieldEnum[];
  };

  /**
   * Participation findMany
   */
  export type ParticipationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * Filter, which Participations to fetch.
     */
    where?: ParticipationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Participations to fetch.
     */
    orderBy?:
      | ParticipationOrderByWithRelationInput
      | ParticipationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Participations.
     */
    cursor?: ParticipationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Participations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Participations.
     */
    skip?: number;
    distinct?: ParticipationScalarFieldEnum | ParticipationScalarFieldEnum[];
  };

  /**
   * Participation create
   */
  export type ParticipationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Participation.
     */
    data: XOR<ParticipationCreateInput, ParticipationUncheckedCreateInput>;
  };

  /**
   * Participation createMany
   */
  export type ParticipationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Participations.
     */
    data: ParticipationCreateManyInput | ParticipationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Participation createManyAndReturn
   */
  export type ParticipationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * The data used to create many Participations.
     */
    data: ParticipationCreateManyInput | ParticipationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Participation update
   */
  export type ParticipationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Participation.
     */
    data: XOR<ParticipationUpdateInput, ParticipationUncheckedUpdateInput>;
    /**
     * Choose, which Participation to update.
     */
    where: ParticipationWhereUniqueInput;
  };

  /**
   * Participation updateMany
   */
  export type ParticipationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Participations.
     */
    data: XOR<
      ParticipationUpdateManyMutationInput,
      ParticipationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Participations to update
     */
    where?: ParticipationWhereInput;
    /**
     * Limit how many Participations to update.
     */
    limit?: number;
  };

  /**
   * Participation updateManyAndReturn
   */
  export type ParticipationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * The data used to update Participations.
     */
    data: XOR<
      ParticipationUpdateManyMutationInput,
      ParticipationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Participations to update
     */
    where?: ParticipationWhereInput;
    /**
     * Limit how many Participations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Participation upsert
   */
  export type ParticipationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Participation to update in case it exists.
     */
    where: ParticipationWhereUniqueInput;
    /**
     * In case the Participation found by the `where` argument doesn't exist, create a new Participation with this data.
     */
    create: XOR<ParticipationCreateInput, ParticipationUncheckedCreateInput>;
    /**
     * In case the Participation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipationUpdateInput, ParticipationUncheckedUpdateInput>;
  };

  /**
   * Participation delete
   */
  export type ParticipationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
    /**
     * Filter which Participation to delete.
     */
    where: ParticipationWhereUniqueInput;
  };

  /**
   * Participation deleteMany
   */
  export type ParticipationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Participations to delete
     */
    where?: ParticipationWhereInput;
    /**
     * Limit how many Participations to delete.
     */
    limit?: number;
  };

  /**
   * Participation without action
   */
  export type ParticipationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Participation
     */
    select?: ParticipationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Participation
     */
    omit?: ParticipationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipationInclude<ExtArgs> | null;
  };

  /**
   * Model Artefact
   */

  export type AggregateArtefact = {
    _count: ArtefactCountAggregateOutputType | null;
    _min: ArtefactMinAggregateOutputType | null;
    _max: ArtefactMaxAggregateOutputType | null;
  };

  export type ArtefactMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    rarity: $Enums.ArtefactRarity | null;
    description: string | null;
    imageUrl: string | null;
    isHidden: boolean | null;
    source: $Enums.ArtefactSource | null;
    userId: string | null;
    huntId: string | null;
    foundAt: Date | null;
  };

  export type ArtefactMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    rarity: $Enums.ArtefactRarity | null;
    description: string | null;
    imageUrl: string | null;
    isHidden: boolean | null;
    source: $Enums.ArtefactSource | null;
    userId: string | null;
    huntId: string | null;
    foundAt: Date | null;
  };

  export type ArtefactCountAggregateOutputType = {
    id: number;
    name: number;
    rarity: number;
    description: number;
    imageUrl: number;
    isHidden: number;
    source: number;
    userId: number;
    huntId: number;
    foundAt: number;
    _all: number;
  };

  export type ArtefactMinAggregateInputType = {
    id?: true;
    name?: true;
    rarity?: true;
    description?: true;
    imageUrl?: true;
    isHidden?: true;
    source?: true;
    userId?: true;
    huntId?: true;
    foundAt?: true;
  };

  export type ArtefactMaxAggregateInputType = {
    id?: true;
    name?: true;
    rarity?: true;
    description?: true;
    imageUrl?: true;
    isHidden?: true;
    source?: true;
    userId?: true;
    huntId?: true;
    foundAt?: true;
  };

  export type ArtefactCountAggregateInputType = {
    id?: true;
    name?: true;
    rarity?: true;
    description?: true;
    imageUrl?: true;
    isHidden?: true;
    source?: true;
    userId?: true;
    huntId?: true;
    foundAt?: true;
    _all?: true;
  };

  export type ArtefactAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Artefact to aggregate.
     */
    where?: ArtefactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artefacts to fetch.
     */
    orderBy?:
      | ArtefactOrderByWithRelationInput
      | ArtefactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ArtefactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Artefacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artefacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Artefacts
     **/
    _count?: true | ArtefactCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ArtefactMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ArtefactMaxAggregateInputType;
  };

  export type GetArtefactAggregateType<T extends ArtefactAggregateArgs> = {
    [P in keyof T & keyof AggregateArtefact]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtefact[P]>
      : GetScalarType<T[P], AggregateArtefact[P]>;
  };

  export type ArtefactGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ArtefactWhereInput;
    orderBy?:
      | ArtefactOrderByWithAggregationInput
      | ArtefactOrderByWithAggregationInput[];
    by: ArtefactScalarFieldEnum[] | ArtefactScalarFieldEnum;
    having?: ArtefactScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ArtefactCountAggregateInputType | true;
    _min?: ArtefactMinAggregateInputType;
    _max?: ArtefactMaxAggregateInputType;
  };

  export type ArtefactGroupByOutputType = {
    id: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description: string | null;
    imageUrl: string | null;
    isHidden: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    huntId: string | null;
    foundAt: Date;
    _count: ArtefactCountAggregateOutputType | null;
    _min: ArtefactMinAggregateOutputType | null;
    _max: ArtefactMaxAggregateOutputType | null;
  };

  type GetArtefactGroupByPayload<T extends ArtefactGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ArtefactGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ArtefactGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtefactGroupByOutputType[P]>
            : GetScalarType<T[P], ArtefactGroupByOutputType[P]>;
        }
      >
    >;

  export type ArtefactSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      rarity?: boolean;
      description?: boolean;
      imageUrl?: boolean;
      isHidden?: boolean;
      source?: boolean;
      userId?: boolean;
      huntId?: boolean;
      foundAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hunt?: boolean | Artefact$huntArgs<ExtArgs>;
      Craft?: boolean | Artefact$CraftArgs<ExtArgs>;
      CraftMaterial?: boolean | Artefact$CraftMaterialArgs<ExtArgs>;
      _count?: boolean | ArtefactCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["artefact"]
  >;

  export type ArtefactSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      rarity?: boolean;
      description?: boolean;
      imageUrl?: boolean;
      isHidden?: boolean;
      source?: boolean;
      userId?: boolean;
      huntId?: boolean;
      foundAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hunt?: boolean | Artefact$huntArgs<ExtArgs>;
    },
    ExtArgs["result"]["artefact"]
  >;

  export type ArtefactSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      rarity?: boolean;
      description?: boolean;
      imageUrl?: boolean;
      isHidden?: boolean;
      source?: boolean;
      userId?: boolean;
      huntId?: boolean;
      foundAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hunt?: boolean | Artefact$huntArgs<ExtArgs>;
    },
    ExtArgs["result"]["artefact"]
  >;

  export type ArtefactSelectScalar = {
    id?: boolean;
    name?: boolean;
    rarity?: boolean;
    description?: boolean;
    imageUrl?: boolean;
    isHidden?: boolean;
    source?: boolean;
    userId?: boolean;
    huntId?: boolean;
    foundAt?: boolean;
  };

  export type ArtefactOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "rarity"
    | "description"
    | "imageUrl"
    | "isHidden"
    | "source"
    | "userId"
    | "huntId"
    | "foundAt",
    ExtArgs["result"]["artefact"]
  >;
  export type ArtefactInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hunt?: boolean | Artefact$huntArgs<ExtArgs>;
    Craft?: boolean | Artefact$CraftArgs<ExtArgs>;
    CraftMaterial?: boolean | Artefact$CraftMaterialArgs<ExtArgs>;
    _count?: boolean | ArtefactCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ArtefactIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hunt?: boolean | Artefact$huntArgs<ExtArgs>;
  };
  export type ArtefactIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hunt?: boolean | Artefact$huntArgs<ExtArgs>;
  };

  export type $ArtefactPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Artefact";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      hunt: Prisma.$TreasureHuntPayload<ExtArgs> | null;
      Craft: Prisma.$CraftPayload<ExtArgs>[];
      CraftMaterial: Prisma.$CraftMaterialPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        rarity: $Enums.ArtefactRarity;
        description: string | null;
        imageUrl: string | null;
        isHidden: boolean;
        source: $Enums.ArtefactSource;
        userId: string;
        huntId: string | null;
        foundAt: Date;
      },
      ExtArgs["result"]["artefact"]
    >;
    composites: {};
  };

  type ArtefactGetPayload<
    S extends boolean | null | undefined | ArtefactDefaultArgs,
  > = $Result.GetResult<Prisma.$ArtefactPayload, S>;

  type ArtefactCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ArtefactFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ArtefactCountAggregateInputType | true;
  };

  export interface ArtefactDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Artefact"];
      meta: { name: "Artefact" };
    };
    /**
     * Find zero or one Artefact that matches the filter.
     * @param {ArtefactFindUniqueArgs} args - Arguments to find a Artefact
     * @example
     * // Get one Artefact
     * const artefact = await prisma.artefact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtefactFindUniqueArgs>(
      args: SelectSubset<T, ArtefactFindUniqueArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Artefact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtefactFindUniqueOrThrowArgs} args - Arguments to find a Artefact
     * @example
     * // Get one Artefact
     * const artefact = await prisma.artefact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtefactFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ArtefactFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Artefact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactFindFirstArgs} args - Arguments to find a Artefact
     * @example
     * // Get one Artefact
     * const artefact = await prisma.artefact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtefactFindFirstArgs>(
      args?: SelectSubset<T, ArtefactFindFirstArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Artefact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactFindFirstOrThrowArgs} args - Arguments to find a Artefact
     * @example
     * // Get one Artefact
     * const artefact = await prisma.artefact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtefactFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArtefactFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Artefacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artefacts
     * const artefacts = await prisma.artefact.findMany()
     *
     * // Get first 10 Artefacts
     * const artefacts = await prisma.artefact.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const artefactWithIdOnly = await prisma.artefact.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ArtefactFindManyArgs>(
      args?: SelectSubset<T, ArtefactFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Artefact.
     * @param {ArtefactCreateArgs} args - Arguments to create a Artefact.
     * @example
     * // Create one Artefact
     * const Artefact = await prisma.artefact.create({
     *   data: {
     *     // ... data to create a Artefact
     *   }
     * })
     *
     */
    create<T extends ArtefactCreateArgs>(
      args: SelectSubset<T, ArtefactCreateArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Artefacts.
     * @param {ArtefactCreateManyArgs} args - Arguments to create many Artefacts.
     * @example
     * // Create many Artefacts
     * const artefact = await prisma.artefact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ArtefactCreateManyArgs>(
      args?: SelectSubset<T, ArtefactCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Artefacts and returns the data saved in the database.
     * @param {ArtefactCreateManyAndReturnArgs} args - Arguments to create many Artefacts.
     * @example
     * // Create many Artefacts
     * const artefact = await prisma.artefact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Artefacts and only return the `id`
     * const artefactWithIdOnly = await prisma.artefact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ArtefactCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ArtefactCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Artefact.
     * @param {ArtefactDeleteArgs} args - Arguments to delete one Artefact.
     * @example
     * // Delete one Artefact
     * const Artefact = await prisma.artefact.delete({
     *   where: {
     *     // ... filter to delete one Artefact
     *   }
     * })
     *
     */
    delete<T extends ArtefactDeleteArgs>(
      args: SelectSubset<T, ArtefactDeleteArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Artefact.
     * @param {ArtefactUpdateArgs} args - Arguments to update one Artefact.
     * @example
     * // Update one Artefact
     * const artefact = await prisma.artefact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ArtefactUpdateArgs>(
      args: SelectSubset<T, ArtefactUpdateArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Artefacts.
     * @param {ArtefactDeleteManyArgs} args - Arguments to filter Artefacts to delete.
     * @example
     * // Delete a few Artefacts
     * const { count } = await prisma.artefact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ArtefactDeleteManyArgs>(
      args?: SelectSubset<T, ArtefactDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Artefacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artefacts
     * const artefact = await prisma.artefact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ArtefactUpdateManyArgs>(
      args: SelectSubset<T, ArtefactUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Artefacts and returns the data updated in the database.
     * @param {ArtefactUpdateManyAndReturnArgs} args - Arguments to update many Artefacts.
     * @example
     * // Update many Artefacts
     * const artefact = await prisma.artefact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Artefacts and only return the `id`
     * const artefactWithIdOnly = await prisma.artefact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ArtefactUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ArtefactUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Artefact.
     * @param {ArtefactUpsertArgs} args - Arguments to update or create a Artefact.
     * @example
     * // Update or create a Artefact
     * const artefact = await prisma.artefact.upsert({
     *   create: {
     *     // ... data to create a Artefact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artefact we want to update
     *   }
     * })
     */
    upsert<T extends ArtefactUpsertArgs>(
      args: SelectSubset<T, ArtefactUpsertArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      $Result.GetResult<
        Prisma.$ArtefactPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Artefacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactCountArgs} args - Arguments to filter Artefacts to count.
     * @example
     * // Count the number of Artefacts
     * const count = await prisma.artefact.count({
     *   where: {
     *     // ... the filter for the Artefacts we want to count
     *   }
     * })
     **/
    count<T extends ArtefactCountArgs>(
      args?: Subset<T, ArtefactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ArtefactCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Artefact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ArtefactAggregateArgs>(
      args: Subset<T, ArtefactAggregateArgs>,
    ): Prisma.PrismaPromise<GetArtefactAggregateType<T>>;

    /**
     * Group by Artefact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtefactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ArtefactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtefactGroupByArgs["orderBy"] }
        : { orderBy?: ArtefactGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ArtefactGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetArtefactGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Artefact model
     */
    readonly fields: ArtefactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artefact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtefactClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    hunt<T extends Artefact$huntArgs<ExtArgs> = {}>(
      args?: Subset<T, Artefact$huntArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      $Result.GetResult<
        Prisma.$TreasureHuntPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    Craft<T extends Artefact$CraftArgs<ExtArgs> = {}>(
      args?: Subset<T, Artefact$CraftArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CraftPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    CraftMaterial<T extends Artefact$CraftMaterialArgs<ExtArgs> = {}>(
      args?: Subset<T, Artefact$CraftMaterialArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CraftMaterialPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Artefact model
   */
  interface ArtefactFieldRefs {
    readonly id: FieldRef<"Artefact", "String">;
    readonly name: FieldRef<"Artefact", "String">;
    readonly rarity: FieldRef<"Artefact", "ArtefactRarity">;
    readonly description: FieldRef<"Artefact", "String">;
    readonly imageUrl: FieldRef<"Artefact", "String">;
    readonly isHidden: FieldRef<"Artefact", "Boolean">;
    readonly source: FieldRef<"Artefact", "ArtefactSource">;
    readonly userId: FieldRef<"Artefact", "String">;
    readonly huntId: FieldRef<"Artefact", "String">;
    readonly foundAt: FieldRef<"Artefact", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Artefact findUnique
   */
  export type ArtefactFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * Filter, which Artefact to fetch.
     */
    where: ArtefactWhereUniqueInput;
  };

  /**
   * Artefact findUniqueOrThrow
   */
  export type ArtefactFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * Filter, which Artefact to fetch.
     */
    where: ArtefactWhereUniqueInput;
  };

  /**
   * Artefact findFirst
   */
  export type ArtefactFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * Filter, which Artefact to fetch.
     */
    where?: ArtefactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artefacts to fetch.
     */
    orderBy?:
      | ArtefactOrderByWithRelationInput
      | ArtefactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Artefacts.
     */
    cursor?: ArtefactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Artefacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artefacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Artefacts.
     */
    distinct?: ArtefactScalarFieldEnum | ArtefactScalarFieldEnum[];
  };

  /**
   * Artefact findFirstOrThrow
   */
  export type ArtefactFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * Filter, which Artefact to fetch.
     */
    where?: ArtefactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artefacts to fetch.
     */
    orderBy?:
      | ArtefactOrderByWithRelationInput
      | ArtefactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Artefacts.
     */
    cursor?: ArtefactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Artefacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artefacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Artefacts.
     */
    distinct?: ArtefactScalarFieldEnum | ArtefactScalarFieldEnum[];
  };

  /**
   * Artefact findMany
   */
  export type ArtefactFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * Filter, which Artefacts to fetch.
     */
    where?: ArtefactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artefacts to fetch.
     */
    orderBy?:
      | ArtefactOrderByWithRelationInput
      | ArtefactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Artefacts.
     */
    cursor?: ArtefactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Artefacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artefacts.
     */
    skip?: number;
    distinct?: ArtefactScalarFieldEnum | ArtefactScalarFieldEnum[];
  };

  /**
   * Artefact create
   */
  export type ArtefactCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * The data needed to create a Artefact.
     */
    data: XOR<ArtefactCreateInput, ArtefactUncheckedCreateInput>;
  };

  /**
   * Artefact createMany
   */
  export type ArtefactCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Artefacts.
     */
    data: ArtefactCreateManyInput | ArtefactCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Artefact createManyAndReturn
   */
  export type ArtefactCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * The data used to create many Artefacts.
     */
    data: ArtefactCreateManyInput | ArtefactCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Artefact update
   */
  export type ArtefactUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * The data needed to update a Artefact.
     */
    data: XOR<ArtefactUpdateInput, ArtefactUncheckedUpdateInput>;
    /**
     * Choose, which Artefact to update.
     */
    where: ArtefactWhereUniqueInput;
  };

  /**
   * Artefact updateMany
   */
  export type ArtefactUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Artefacts.
     */
    data: XOR<
      ArtefactUpdateManyMutationInput,
      ArtefactUncheckedUpdateManyInput
    >;
    /**
     * Filter which Artefacts to update
     */
    where?: ArtefactWhereInput;
    /**
     * Limit how many Artefacts to update.
     */
    limit?: number;
  };

  /**
   * Artefact updateManyAndReturn
   */
  export type ArtefactUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * The data used to update Artefacts.
     */
    data: XOR<
      ArtefactUpdateManyMutationInput,
      ArtefactUncheckedUpdateManyInput
    >;
    /**
     * Filter which Artefacts to update
     */
    where?: ArtefactWhereInput;
    /**
     * Limit how many Artefacts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Artefact upsert
   */
  export type ArtefactUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * The filter to search for the Artefact to update in case it exists.
     */
    where: ArtefactWhereUniqueInput;
    /**
     * In case the Artefact found by the `where` argument doesn't exist, create a new Artefact with this data.
     */
    create: XOR<ArtefactCreateInput, ArtefactUncheckedCreateInput>;
    /**
     * In case the Artefact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtefactUpdateInput, ArtefactUncheckedUpdateInput>;
  };

  /**
   * Artefact delete
   */
  export type ArtefactDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
    /**
     * Filter which Artefact to delete.
     */
    where: ArtefactWhereUniqueInput;
  };

  /**
   * Artefact deleteMany
   */
  export type ArtefactDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Artefacts to delete
     */
    where?: ArtefactWhereInput;
    /**
     * Limit how many Artefacts to delete.
     */
    limit?: number;
  };

  /**
   * Artefact.hunt
   */
  export type Artefact$huntArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TreasureHunt
     */
    select?: TreasureHuntSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TreasureHunt
     */
    omit?: TreasureHuntOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreasureHuntInclude<ExtArgs> | null;
    where?: TreasureHuntWhereInput;
  };

  /**
   * Artefact.Craft
   */
  export type Artefact$CraftArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    where?: CraftWhereInput;
    orderBy?: CraftOrderByWithRelationInput | CraftOrderByWithRelationInput[];
    cursor?: CraftWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CraftScalarFieldEnum | CraftScalarFieldEnum[];
  };

  /**
   * Artefact.CraftMaterial
   */
  export type Artefact$CraftMaterialArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    where?: CraftMaterialWhereInput;
    orderBy?:
      | CraftMaterialOrderByWithRelationInput
      | CraftMaterialOrderByWithRelationInput[];
    cursor?: CraftMaterialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CraftMaterialScalarFieldEnum | CraftMaterialScalarFieldEnum[];
  };

  /**
   * Artefact without action
   */
  export type ArtefactDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Artefact
     */
    select?: ArtefactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Artefact
     */
    omit?: ArtefactOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtefactInclude<ExtArgs> | null;
  };

  /**
   * Model HuntStep
   */

  export type AggregateHuntStep = {
    _count: HuntStepCountAggregateOutputType | null;
    _avg: HuntStepAvgAggregateOutputType | null;
    _sum: HuntStepSumAggregateOutputType | null;
    _min: HuntStepMinAggregateOutputType | null;
    _max: HuntStepMaxAggregateOutputType | null;
  };

  export type HuntStepAvgAggregateOutputType = {
    stepOrder: number | null;
  };

  export type HuntStepSumAggregateOutputType = {
    stepOrder: number | null;
  };

  export type HuntStepMinAggregateOutputType = {
    id: string | null;
    description: string | null;
    huntId: string | null;
    stepOrder: number | null;
    createdAt: Date | null;
  };

  export type HuntStepMaxAggregateOutputType = {
    id: string | null;
    description: string | null;
    huntId: string | null;
    stepOrder: number | null;
    createdAt: Date | null;
  };

  export type HuntStepCountAggregateOutputType = {
    id: number;
    description: number;
    huntId: number;
    stepOrder: number;
    createdAt: number;
    _all: number;
  };

  export type HuntStepAvgAggregateInputType = {
    stepOrder?: true;
  };

  export type HuntStepSumAggregateInputType = {
    stepOrder?: true;
  };

  export type HuntStepMinAggregateInputType = {
    id?: true;
    description?: true;
    huntId?: true;
    stepOrder?: true;
    createdAt?: true;
  };

  export type HuntStepMaxAggregateInputType = {
    id?: true;
    description?: true;
    huntId?: true;
    stepOrder?: true;
    createdAt?: true;
  };

  export type HuntStepCountAggregateInputType = {
    id?: true;
    description?: true;
    huntId?: true;
    stepOrder?: true;
    createdAt?: true;
    _all?: true;
  };

  export type HuntStepAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HuntStep to aggregate.
     */
    where?: HuntStepWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HuntSteps to fetch.
     */
    orderBy?:
      | HuntStepOrderByWithRelationInput
      | HuntStepOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HuntStepWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HuntSteps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HuntSteps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned HuntSteps
     **/
    _count?: true | HuntStepCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: HuntStepAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: HuntStepSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: HuntStepMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: HuntStepMaxAggregateInputType;
  };

  export type GetHuntStepAggregateType<T extends HuntStepAggregateArgs> = {
    [P in keyof T & keyof AggregateHuntStep]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHuntStep[P]>
      : GetScalarType<T[P], AggregateHuntStep[P]>;
  };

  export type HuntStepGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: HuntStepWhereInput;
    orderBy?:
      | HuntStepOrderByWithAggregationInput
      | HuntStepOrderByWithAggregationInput[];
    by: HuntStepScalarFieldEnum[] | HuntStepScalarFieldEnum;
    having?: HuntStepScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HuntStepCountAggregateInputType | true;
    _avg?: HuntStepAvgAggregateInputType;
    _sum?: HuntStepSumAggregateInputType;
    _min?: HuntStepMinAggregateInputType;
    _max?: HuntStepMaxAggregateInputType;
  };

  export type HuntStepGroupByOutputType = {
    id: string;
    description: string;
    huntId: string;
    stepOrder: number;
    createdAt: Date;
    _count: HuntStepCountAggregateOutputType | null;
    _avg: HuntStepAvgAggregateOutputType | null;
    _sum: HuntStepSumAggregateOutputType | null;
    _min: HuntStepMinAggregateOutputType | null;
    _max: HuntStepMaxAggregateOutputType | null;
  };

  type GetHuntStepGroupByPayload<T extends HuntStepGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<HuntStepGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof HuntStepGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HuntStepGroupByOutputType[P]>
            : GetScalarType<T[P], HuntStepGroupByOutputType[P]>;
        }
      >
    >;

  export type HuntStepSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      description?: boolean;
      huntId?: boolean;
      stepOrder?: boolean;
      createdAt?: boolean;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["huntStep"]
  >;

  export type HuntStepSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      description?: boolean;
      huntId?: boolean;
      stepOrder?: boolean;
      createdAt?: boolean;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["huntStep"]
  >;

  export type HuntStepSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      description?: boolean;
      huntId?: boolean;
      stepOrder?: boolean;
      createdAt?: boolean;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["huntStep"]
  >;

  export type HuntStepSelectScalar = {
    id?: boolean;
    description?: boolean;
    huntId?: boolean;
    stepOrder?: boolean;
    createdAt?: boolean;
  };

  export type HuntStepOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "description" | "huntId" | "stepOrder" | "createdAt",
    ExtArgs["result"]["huntStep"]
  >;
  export type HuntStepInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type HuntStepIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type HuntStepIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };

  export type $HuntStepPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "HuntStep";
    objects: {
      treasureHunt: Prisma.$TreasureHuntPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        description: string;
        huntId: string;
        stepOrder: number;
        createdAt: Date;
      },
      ExtArgs["result"]["huntStep"]
    >;
    composites: {};
  };

  type HuntStepGetPayload<
    S extends boolean | null | undefined | HuntStepDefaultArgs,
  > = $Result.GetResult<Prisma.$HuntStepPayload, S>;

  type HuntStepCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<HuntStepFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: HuntStepCountAggregateInputType | true;
  };

  export interface HuntStepDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["HuntStep"];
      meta: { name: "HuntStep" };
    };
    /**
     * Find zero or one HuntStep that matches the filter.
     * @param {HuntStepFindUniqueArgs} args - Arguments to find a HuntStep
     * @example
     * // Get one HuntStep
     * const huntStep = await prisma.huntStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HuntStepFindUniqueArgs>(
      args: SelectSubset<T, HuntStepFindUniqueArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one HuntStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HuntStepFindUniqueOrThrowArgs} args - Arguments to find a HuntStep
     * @example
     * // Get one HuntStep
     * const huntStep = await prisma.huntStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HuntStepFindUniqueOrThrowArgs>(
      args: SelectSubset<T, HuntStepFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first HuntStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepFindFirstArgs} args - Arguments to find a HuntStep
     * @example
     * // Get one HuntStep
     * const huntStep = await prisma.huntStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HuntStepFindFirstArgs>(
      args?: SelectSubset<T, HuntStepFindFirstArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first HuntStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepFindFirstOrThrowArgs} args - Arguments to find a HuntStep
     * @example
     * // Get one HuntStep
     * const huntStep = await prisma.huntStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HuntStepFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HuntStepFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more HuntSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HuntSteps
     * const huntSteps = await prisma.huntStep.findMany()
     *
     * // Get first 10 HuntSteps
     * const huntSteps = await prisma.huntStep.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const huntStepWithIdOnly = await prisma.huntStep.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HuntStepFindManyArgs>(
      args?: SelectSubset<T, HuntStepFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a HuntStep.
     * @param {HuntStepCreateArgs} args - Arguments to create a HuntStep.
     * @example
     * // Create one HuntStep
     * const HuntStep = await prisma.huntStep.create({
     *   data: {
     *     // ... data to create a HuntStep
     *   }
     * })
     *
     */
    create<T extends HuntStepCreateArgs>(
      args: SelectSubset<T, HuntStepCreateArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many HuntSteps.
     * @param {HuntStepCreateManyArgs} args - Arguments to create many HuntSteps.
     * @example
     * // Create many HuntSteps
     * const huntStep = await prisma.huntStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HuntStepCreateManyArgs>(
      args?: SelectSubset<T, HuntStepCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many HuntSteps and returns the data saved in the database.
     * @param {HuntStepCreateManyAndReturnArgs} args - Arguments to create many HuntSteps.
     * @example
     * // Create many HuntSteps
     * const huntStep = await prisma.huntStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many HuntSteps and only return the `id`
     * const huntStepWithIdOnly = await prisma.huntStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends HuntStepCreateManyAndReturnArgs>(
      args?: SelectSubset<T, HuntStepCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a HuntStep.
     * @param {HuntStepDeleteArgs} args - Arguments to delete one HuntStep.
     * @example
     * // Delete one HuntStep
     * const HuntStep = await prisma.huntStep.delete({
     *   where: {
     *     // ... filter to delete one HuntStep
     *   }
     * })
     *
     */
    delete<T extends HuntStepDeleteArgs>(
      args: SelectSubset<T, HuntStepDeleteArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one HuntStep.
     * @param {HuntStepUpdateArgs} args - Arguments to update one HuntStep.
     * @example
     * // Update one HuntStep
     * const huntStep = await prisma.huntStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HuntStepUpdateArgs>(
      args: SelectSubset<T, HuntStepUpdateArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more HuntSteps.
     * @param {HuntStepDeleteManyArgs} args - Arguments to filter HuntSteps to delete.
     * @example
     * // Delete a few HuntSteps
     * const { count } = await prisma.huntStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HuntStepDeleteManyArgs>(
      args?: SelectSubset<T, HuntStepDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more HuntSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HuntSteps
     * const huntStep = await prisma.huntStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HuntStepUpdateManyArgs>(
      args: SelectSubset<T, HuntStepUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more HuntSteps and returns the data updated in the database.
     * @param {HuntStepUpdateManyAndReturnArgs} args - Arguments to update many HuntSteps.
     * @example
     * // Update many HuntSteps
     * const huntStep = await prisma.huntStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more HuntSteps and only return the `id`
     * const huntStepWithIdOnly = await prisma.huntStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends HuntStepUpdateManyAndReturnArgs>(
      args: SelectSubset<T, HuntStepUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one HuntStep.
     * @param {HuntStepUpsertArgs} args - Arguments to update or create a HuntStep.
     * @example
     * // Update or create a HuntStep
     * const huntStep = await prisma.huntStep.upsert({
     *   create: {
     *     // ... data to create a HuntStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HuntStep we want to update
     *   }
     * })
     */
    upsert<T extends HuntStepUpsertArgs>(
      args: SelectSubset<T, HuntStepUpsertArgs<ExtArgs>>,
    ): Prisma__HuntStepClient<
      $Result.GetResult<
        Prisma.$HuntStepPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of HuntSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepCountArgs} args - Arguments to filter HuntSteps to count.
     * @example
     * // Count the number of HuntSteps
     * const count = await prisma.huntStep.count({
     *   where: {
     *     // ... the filter for the HuntSteps we want to count
     *   }
     * })
     **/
    count<T extends HuntStepCountArgs>(
      args?: Subset<T, HuntStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], HuntStepCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a HuntStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends HuntStepAggregateArgs>(
      args: Subset<T, HuntStepAggregateArgs>,
    ): Prisma.PrismaPromise<GetHuntStepAggregateType<T>>;

    /**
     * Group by HuntStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HuntStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends HuntStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HuntStepGroupByArgs["orderBy"] }
        : { orderBy?: HuntStepGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, HuntStepGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetHuntStepGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the HuntStep model
     */
    readonly fields: HuntStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HuntStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HuntStepClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    treasureHunt<T extends TreasureHuntDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHuntDefaultArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      | $Result.GetResult<
          Prisma.$TreasureHuntPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the HuntStep model
   */
  interface HuntStepFieldRefs {
    readonly id: FieldRef<"HuntStep", "String">;
    readonly description: FieldRef<"HuntStep", "String">;
    readonly huntId: FieldRef<"HuntStep", "String">;
    readonly stepOrder: FieldRef<"HuntStep", "Int">;
    readonly createdAt: FieldRef<"HuntStep", "DateTime">;
  }

  // Custom InputTypes
  /**
   * HuntStep findUnique
   */
  export type HuntStepFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * Filter, which HuntStep to fetch.
     */
    where: HuntStepWhereUniqueInput;
  };

  /**
   * HuntStep findUniqueOrThrow
   */
  export type HuntStepFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * Filter, which HuntStep to fetch.
     */
    where: HuntStepWhereUniqueInput;
  };

  /**
   * HuntStep findFirst
   */
  export type HuntStepFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * Filter, which HuntStep to fetch.
     */
    where?: HuntStepWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HuntSteps to fetch.
     */
    orderBy?:
      | HuntStepOrderByWithRelationInput
      | HuntStepOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HuntSteps.
     */
    cursor?: HuntStepWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HuntSteps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HuntSteps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HuntSteps.
     */
    distinct?: HuntStepScalarFieldEnum | HuntStepScalarFieldEnum[];
  };

  /**
   * HuntStep findFirstOrThrow
   */
  export type HuntStepFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * Filter, which HuntStep to fetch.
     */
    where?: HuntStepWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HuntSteps to fetch.
     */
    orderBy?:
      | HuntStepOrderByWithRelationInput
      | HuntStepOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HuntSteps.
     */
    cursor?: HuntStepWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HuntSteps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HuntSteps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HuntSteps.
     */
    distinct?: HuntStepScalarFieldEnum | HuntStepScalarFieldEnum[];
  };

  /**
   * HuntStep findMany
   */
  export type HuntStepFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * Filter, which HuntSteps to fetch.
     */
    where?: HuntStepWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HuntSteps to fetch.
     */
    orderBy?:
      | HuntStepOrderByWithRelationInput
      | HuntStepOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing HuntSteps.
     */
    cursor?: HuntStepWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HuntSteps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HuntSteps.
     */
    skip?: number;
    distinct?: HuntStepScalarFieldEnum | HuntStepScalarFieldEnum[];
  };

  /**
   * HuntStep create
   */
  export type HuntStepCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * The data needed to create a HuntStep.
     */
    data: XOR<HuntStepCreateInput, HuntStepUncheckedCreateInput>;
  };

  /**
   * HuntStep createMany
   */
  export type HuntStepCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many HuntSteps.
     */
    data: HuntStepCreateManyInput | HuntStepCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * HuntStep createManyAndReturn
   */
  export type HuntStepCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * The data used to create many HuntSteps.
     */
    data: HuntStepCreateManyInput | HuntStepCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * HuntStep update
   */
  export type HuntStepUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * The data needed to update a HuntStep.
     */
    data: XOR<HuntStepUpdateInput, HuntStepUncheckedUpdateInput>;
    /**
     * Choose, which HuntStep to update.
     */
    where: HuntStepWhereUniqueInput;
  };

  /**
   * HuntStep updateMany
   */
  export type HuntStepUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update HuntSteps.
     */
    data: XOR<
      HuntStepUpdateManyMutationInput,
      HuntStepUncheckedUpdateManyInput
    >;
    /**
     * Filter which HuntSteps to update
     */
    where?: HuntStepWhereInput;
    /**
     * Limit how many HuntSteps to update.
     */
    limit?: number;
  };

  /**
   * HuntStep updateManyAndReturn
   */
  export type HuntStepUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * The data used to update HuntSteps.
     */
    data: XOR<
      HuntStepUpdateManyMutationInput,
      HuntStepUncheckedUpdateManyInput
    >;
    /**
     * Filter which HuntSteps to update
     */
    where?: HuntStepWhereInput;
    /**
     * Limit how many HuntSteps to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * HuntStep upsert
   */
  export type HuntStepUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * The filter to search for the HuntStep to update in case it exists.
     */
    where: HuntStepWhereUniqueInput;
    /**
     * In case the HuntStep found by the `where` argument doesn't exist, create a new HuntStep with this data.
     */
    create: XOR<HuntStepCreateInput, HuntStepUncheckedCreateInput>;
    /**
     * In case the HuntStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HuntStepUpdateInput, HuntStepUncheckedUpdateInput>;
  };

  /**
   * HuntStep delete
   */
  export type HuntStepDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
    /**
     * Filter which HuntStep to delete.
     */
    where: HuntStepWhereUniqueInput;
  };

  /**
   * HuntStep deleteMany
   */
  export type HuntStepDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HuntSteps to delete
     */
    where?: HuntStepWhereInput;
    /**
     * Limit how many HuntSteps to delete.
     */
    limit?: number;
  };

  /**
   * HuntStep without action
   */
  export type HuntStepDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HuntStep
     */
    select?: HuntStepSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HuntStep
     */
    omit?: HuntStepOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HuntStepInclude<ExtArgs> | null;
  };

  /**
   * Model Reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null;
    _avg: RewardAvgAggregateOutputType | null;
    _sum: RewardSumAggregateOutputType | null;
    _min: RewardMinAggregateOutputType | null;
    _max: RewardMaxAggregateOutputType | null;
  };

  export type RewardAvgAggregateOutputType = {
    value: number | null;
  };

  export type RewardSumAggregateOutputType = {
    value: number | null;
  };

  export type RewardMinAggregateOutputType = {
    id: string | null;
    type: $Enums.RewardType | null;
    value: number | null;
    description: string | null;
    huntId: string | null;
  };

  export type RewardMaxAggregateOutputType = {
    id: string | null;
    type: $Enums.RewardType | null;
    value: number | null;
    description: string | null;
    huntId: string | null;
  };

  export type RewardCountAggregateOutputType = {
    id: number;
    type: number;
    value: number;
    description: number;
    huntId: number;
    _all: number;
  };

  export type RewardAvgAggregateInputType = {
    value?: true;
  };

  export type RewardSumAggregateInputType = {
    value?: true;
  };

  export type RewardMinAggregateInputType = {
    id?: true;
    type?: true;
    value?: true;
    description?: true;
    huntId?: true;
  };

  export type RewardMaxAggregateInputType = {
    id?: true;
    type?: true;
    value?: true;
    description?: true;
    huntId?: true;
  };

  export type RewardCountAggregateInputType = {
    id?: true;
    type?: true;
    value?: true;
    description?: true;
    huntId?: true;
    _all?: true;
  };

  export type RewardAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Rewards.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Rewards
     **/
    _count?: true | RewardCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RewardAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RewardSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RewardMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RewardMaxAggregateInputType;
  };

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
    [P in keyof T & keyof AggregateReward]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>;
  };

  export type RewardGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RewardWhereInput;
    orderBy?:
      | RewardOrderByWithAggregationInput
      | RewardOrderByWithAggregationInput[];
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum;
    having?: RewardScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RewardCountAggregateInputType | true;
    _avg?: RewardAvgAggregateInputType;
    _sum?: RewardSumAggregateInputType;
    _min?: RewardMinAggregateInputType;
    _max?: RewardMaxAggregateInputType;
  };

  export type RewardGroupByOutputType = {
    id: string;
    type: $Enums.RewardType;
    value: number;
    description: string | null;
    huntId: string;
    _count: RewardCountAggregateOutputType | null;
    _avg: RewardAvgAggregateOutputType | null;
    _sum: RewardSumAggregateOutputType | null;
    _min: RewardMinAggregateOutputType | null;
    _max: RewardMaxAggregateOutputType | null;
  };

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RewardGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof RewardGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>;
        }
      >
    >;

  export type RewardSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      value?: boolean;
      description?: boolean;
      huntId?: boolean;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["reward"]
  >;

  export type RewardSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      value?: boolean;
      description?: boolean;
      huntId?: boolean;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["reward"]
  >;

  export type RewardSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      value?: boolean;
      description?: boolean;
      huntId?: boolean;
      treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["reward"]
  >;

  export type RewardSelectScalar = {
    id?: boolean;
    type?: boolean;
    value?: boolean;
    description?: boolean;
    huntId?: boolean;
  };

  export type RewardOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "type" | "value" | "description" | "huntId",
    ExtArgs["result"]["reward"]
  >;
  export type RewardInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type RewardIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type RewardIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    treasureHunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };

  export type $RewardPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Reward";
    objects: {
      treasureHunt: Prisma.$TreasureHuntPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        type: $Enums.RewardType;
        value: number;
        description: string | null;
        huntId: string;
      },
      ExtArgs["result"]["reward"]
    >;
    composites: {};
  };

  type RewardGetPayload<
    S extends boolean | null | undefined | RewardDefaultArgs,
  > = $Result.GetResult<Prisma.$RewardPayload, S>;

  type RewardCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RewardFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: RewardCountAggregateInputType | true;
  };

  export interface RewardDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Reward"];
      meta: { name: "Reward" };
    };
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardFindUniqueArgs>(
      args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardFindFirstArgs>(
      args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     *
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RewardFindManyArgs>(
      args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     *
     */
    create<T extends RewardCreateArgs>(
      args: SelectSubset<T, RewardCreateArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Rewards.
     * @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RewardCreateManyArgs>(
      args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {RewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RewardCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RewardCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     *
     */
    delete<T extends RewardDeleteArgs>(
      args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RewardUpdateArgs>(
      args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RewardDeleteManyArgs>(
      args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RewardUpdateManyArgs>(
      args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Rewards and returns the data updated in the database.
     * @param {RewardUpdateManyAndReturnArgs} args - Arguments to update many Rewards.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RewardUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RewardUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends RewardUpsertArgs>(
      args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>,
    ): Prisma__RewardClient<
      $Result.GetResult<
        Prisma.$RewardPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
     **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RewardCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RewardAggregateArgs>(
      args: Subset<T, RewardAggregateArgs>,
    ): Prisma.PrismaPromise<GetRewardAggregateType<T>>;

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs["orderBy"] }
        : { orderBy?: RewardGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRewardGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Reward model
     */
    readonly fields: RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    treasureHunt<T extends TreasureHuntDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHuntDefaultArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      | $Result.GetResult<
          Prisma.$TreasureHuntPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Reward model
   */
  interface RewardFieldRefs {
    readonly id: FieldRef<"Reward", "String">;
    readonly type: FieldRef<"Reward", "RewardType">;
    readonly value: FieldRef<"Reward", "Int">;
    readonly description: FieldRef<"Reward", "String">;
    readonly huntId: FieldRef<"Reward", "String">;
  }

  // Custom InputTypes
  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput;
  };

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput;
  };

  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Rewards.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[];
  };

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Rewards.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[];
  };

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Rewards.
     */
    skip?: number;
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[];
  };

  /**
   * Reward create
   */
  export type RewardCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>;
  };

  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Reward createManyAndReturn
   */
  export type RewardCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Reward update
   */
  export type RewardUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>;
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput;
  };

  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>;
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput;
    /**
     * Limit how many Rewards to update.
     */
    limit?: number;
  };

  /**
   * Reward updateManyAndReturn
   */
  export type RewardUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>;
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput;
    /**
     * Limit how many Rewards to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput;
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>;
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>;
  };

  /**
   * Reward delete
   */
  export type RewardDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput;
  };

  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput;
    /**
     * Limit how many Rewards to delete.
     */
    limit?: number;
  };

  /**
   * Reward without action
   */
  export type RewardDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null;
  };

  /**
   * Model VirtualCurrency
   */

  export type AggregateVirtualCurrency = {
    _count: VirtualCurrencyCountAggregateOutputType | null;
    _avg: VirtualCurrencyAvgAggregateOutputType | null;
    _sum: VirtualCurrencySumAggregateOutputType | null;
    _min: VirtualCurrencyMinAggregateOutputType | null;
    _max: VirtualCurrencyMaxAggregateOutputType | null;
  };

  export type VirtualCurrencyAvgAggregateOutputType = {
    amount: number | null;
  };

  export type VirtualCurrencySumAggregateOutputType = {
    amount: number | null;
  };

  export type VirtualCurrencyMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    amount: number | null;
    type: $Enums.CurrencySourceType | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VirtualCurrencyMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    amount: number | null;
    type: $Enums.CurrencySourceType | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VirtualCurrencyCountAggregateOutputType = {
    id: number;
    userId: number;
    amount: number;
    type: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type VirtualCurrencyAvgAggregateInputType = {
    amount?: true;
  };

  export type VirtualCurrencySumAggregateInputType = {
    amount?: true;
  };

  export type VirtualCurrencyMinAggregateInputType = {
    id?: true;
    userId?: true;
    amount?: true;
    type?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VirtualCurrencyMaxAggregateInputType = {
    id?: true;
    userId?: true;
    amount?: true;
    type?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VirtualCurrencyCountAggregateInputType = {
    id?: true;
    userId?: true;
    amount?: true;
    type?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type VirtualCurrencyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VirtualCurrency to aggregate.
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VirtualCurrencies to fetch.
     */
    orderBy?:
      | VirtualCurrencyOrderByWithRelationInput
      | VirtualCurrencyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VirtualCurrencyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VirtualCurrencies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VirtualCurrencies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VirtualCurrencies
     **/
    _count?: true | VirtualCurrencyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: VirtualCurrencyAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: VirtualCurrencySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VirtualCurrencyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VirtualCurrencyMaxAggregateInputType;
  };

  export type GetVirtualCurrencyAggregateType<
    T extends VirtualCurrencyAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVirtualCurrency]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualCurrency[P]>
      : GetScalarType<T[P], AggregateVirtualCurrency[P]>;
  };

  export type VirtualCurrencyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VirtualCurrencyWhereInput;
    orderBy?:
      | VirtualCurrencyOrderByWithAggregationInput
      | VirtualCurrencyOrderByWithAggregationInput[];
    by: VirtualCurrencyScalarFieldEnum[] | VirtualCurrencyScalarFieldEnum;
    having?: VirtualCurrencyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VirtualCurrencyCountAggregateInputType | true;
    _avg?: VirtualCurrencyAvgAggregateInputType;
    _sum?: VirtualCurrencySumAggregateInputType;
    _min?: VirtualCurrencyMinAggregateInputType;
    _max?: VirtualCurrencyMaxAggregateInputType;
  };

  export type VirtualCurrencyGroupByOutputType = {
    id: string;
    userId: string;
    amount: number;
    type: $Enums.CurrencySourceType;
    createdAt: Date;
    updatedAt: Date;
    _count: VirtualCurrencyCountAggregateOutputType | null;
    _avg: VirtualCurrencyAvgAggregateOutputType | null;
    _sum: VirtualCurrencySumAggregateOutputType | null;
    _min: VirtualCurrencyMinAggregateOutputType | null;
    _max: VirtualCurrencyMaxAggregateOutputType | null;
  };

  type GetVirtualCurrencyGroupByPayload<T extends VirtualCurrencyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VirtualCurrencyGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof VirtualCurrencyGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualCurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualCurrencyGroupByOutputType[P]>;
        }
      >
    >;

  export type VirtualCurrencySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      amount?: boolean;
      type?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      transactionHistory?:
        | boolean
        | VirtualCurrency$transactionHistoryArgs<ExtArgs>;
      _count?: boolean | VirtualCurrencyCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["virtualCurrency"]
  >;

  export type VirtualCurrencySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      amount?: boolean;
      type?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["virtualCurrency"]
  >;

  export type VirtualCurrencySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      amount?: boolean;
      type?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["virtualCurrency"]
  >;

  export type VirtualCurrencySelectScalar = {
    id?: boolean;
    userId?: boolean;
    amount?: boolean;
    type?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type VirtualCurrencyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "amount" | "type" | "createdAt" | "updatedAt",
    ExtArgs["result"]["virtualCurrency"]
  >;
  export type VirtualCurrencyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    transactionHistory?:
      | boolean
      | VirtualCurrency$transactionHistoryArgs<ExtArgs>;
    _count?: boolean | VirtualCurrencyCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type VirtualCurrencyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type VirtualCurrencyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $VirtualCurrencyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "VirtualCurrency";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      transactionHistory: Prisma.$TransactionHistoryPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        amount: number;
        type: $Enums.CurrencySourceType;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["virtualCurrency"]
    >;
    composites: {};
  };

  type VirtualCurrencyGetPayload<
    S extends boolean | null | undefined | VirtualCurrencyDefaultArgs,
  > = $Result.GetResult<Prisma.$VirtualCurrencyPayload, S>;

  type VirtualCurrencyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    VirtualCurrencyFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: VirtualCurrencyCountAggregateInputType | true;
  };

  export interface VirtualCurrencyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["VirtualCurrency"];
      meta: { name: "VirtualCurrency" };
    };
    /**
     * Find zero or one VirtualCurrency that matches the filter.
     * @param {VirtualCurrencyFindUniqueArgs} args - Arguments to find a VirtualCurrency
     * @example
     * // Get one VirtualCurrency
     * const virtualCurrency = await prisma.virtualCurrency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualCurrencyFindUniqueArgs>(
      args: SelectSubset<T, VirtualCurrencyFindUniqueArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VirtualCurrency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VirtualCurrencyFindUniqueOrThrowArgs} args - Arguments to find a VirtualCurrency
     * @example
     * // Get one VirtualCurrency
     * const virtualCurrency = await prisma.virtualCurrency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualCurrencyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VirtualCurrencyFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VirtualCurrency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyFindFirstArgs} args - Arguments to find a VirtualCurrency
     * @example
     * // Get one VirtualCurrency
     * const virtualCurrency = await prisma.virtualCurrency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualCurrencyFindFirstArgs>(
      args?: SelectSubset<T, VirtualCurrencyFindFirstArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VirtualCurrency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyFindFirstOrThrowArgs} args - Arguments to find a VirtualCurrency
     * @example
     * // Get one VirtualCurrency
     * const virtualCurrency = await prisma.virtualCurrency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualCurrencyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VirtualCurrencyFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VirtualCurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualCurrencies
     * const virtualCurrencies = await prisma.virtualCurrency.findMany()
     *
     * // Get first 10 VirtualCurrencies
     * const virtualCurrencies = await prisma.virtualCurrency.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const virtualCurrencyWithIdOnly = await prisma.virtualCurrency.findMany({ select: { id: true } })
     *
     */
    findMany<T extends VirtualCurrencyFindManyArgs>(
      args?: SelectSubset<T, VirtualCurrencyFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a VirtualCurrency.
     * @param {VirtualCurrencyCreateArgs} args - Arguments to create a VirtualCurrency.
     * @example
     * // Create one VirtualCurrency
     * const VirtualCurrency = await prisma.virtualCurrency.create({
     *   data: {
     *     // ... data to create a VirtualCurrency
     *   }
     * })
     *
     */
    create<T extends VirtualCurrencyCreateArgs>(
      args: SelectSubset<T, VirtualCurrencyCreateArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VirtualCurrencies.
     * @param {VirtualCurrencyCreateManyArgs} args - Arguments to create many VirtualCurrencies.
     * @example
     * // Create many VirtualCurrencies
     * const virtualCurrency = await prisma.virtualCurrency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VirtualCurrencyCreateManyArgs>(
      args?: SelectSubset<T, VirtualCurrencyCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VirtualCurrencies and returns the data saved in the database.
     * @param {VirtualCurrencyCreateManyAndReturnArgs} args - Arguments to create many VirtualCurrencies.
     * @example
     * // Create many VirtualCurrencies
     * const virtualCurrency = await prisma.virtualCurrency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VirtualCurrencies and only return the `id`
     * const virtualCurrencyWithIdOnly = await prisma.virtualCurrency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VirtualCurrencyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VirtualCurrencyCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a VirtualCurrency.
     * @param {VirtualCurrencyDeleteArgs} args - Arguments to delete one VirtualCurrency.
     * @example
     * // Delete one VirtualCurrency
     * const VirtualCurrency = await prisma.virtualCurrency.delete({
     *   where: {
     *     // ... filter to delete one VirtualCurrency
     *   }
     * })
     *
     */
    delete<T extends VirtualCurrencyDeleteArgs>(
      args: SelectSubset<T, VirtualCurrencyDeleteArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VirtualCurrency.
     * @param {VirtualCurrencyUpdateArgs} args - Arguments to update one VirtualCurrency.
     * @example
     * // Update one VirtualCurrency
     * const virtualCurrency = await prisma.virtualCurrency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VirtualCurrencyUpdateArgs>(
      args: SelectSubset<T, VirtualCurrencyUpdateArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VirtualCurrencies.
     * @param {VirtualCurrencyDeleteManyArgs} args - Arguments to filter VirtualCurrencies to delete.
     * @example
     * // Delete a few VirtualCurrencies
     * const { count } = await prisma.virtualCurrency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VirtualCurrencyDeleteManyArgs>(
      args?: SelectSubset<T, VirtualCurrencyDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VirtualCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualCurrencies
     * const virtualCurrency = await prisma.virtualCurrency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VirtualCurrencyUpdateManyArgs>(
      args: SelectSubset<T, VirtualCurrencyUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VirtualCurrencies and returns the data updated in the database.
     * @param {VirtualCurrencyUpdateManyAndReturnArgs} args - Arguments to update many VirtualCurrencies.
     * @example
     * // Update many VirtualCurrencies
     * const virtualCurrency = await prisma.virtualCurrency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more VirtualCurrencies and only return the `id`
     * const virtualCurrencyWithIdOnly = await prisma.virtualCurrency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VirtualCurrencyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VirtualCurrencyUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one VirtualCurrency.
     * @param {VirtualCurrencyUpsertArgs} args - Arguments to update or create a VirtualCurrency.
     * @example
     * // Update or create a VirtualCurrency
     * const virtualCurrency = await prisma.virtualCurrency.upsert({
     *   create: {
     *     // ... data to create a VirtualCurrency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualCurrency we want to update
     *   }
     * })
     */
    upsert<T extends VirtualCurrencyUpsertArgs>(
      args: SelectSubset<T, VirtualCurrencyUpsertArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      $Result.GetResult<
        Prisma.$VirtualCurrencyPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of VirtualCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyCountArgs} args - Arguments to filter VirtualCurrencies to count.
     * @example
     * // Count the number of VirtualCurrencies
     * const count = await prisma.virtualCurrency.count({
     *   where: {
     *     // ... the filter for the VirtualCurrencies we want to count
     *   }
     * })
     **/
    count<T extends VirtualCurrencyCountArgs>(
      args?: Subset<T, VirtualCurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], VirtualCurrencyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VirtualCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VirtualCurrencyAggregateArgs>(
      args: Subset<T, VirtualCurrencyAggregateArgs>,
    ): Prisma.PrismaPromise<GetVirtualCurrencyAggregateType<T>>;

    /**
     * Group by VirtualCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VirtualCurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualCurrencyGroupByArgs["orderBy"] }
        : { orderBy?: VirtualCurrencyGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VirtualCurrencyGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetVirtualCurrencyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VirtualCurrency model
     */
    readonly fields: VirtualCurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualCurrency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualCurrencyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    transactionHistory<
      T extends VirtualCurrency$transactionHistoryArgs<ExtArgs> = {},
    >(
      args?: Subset<T, VirtualCurrency$transactionHistoryArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TransactionHistoryPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VirtualCurrency model
   */
  interface VirtualCurrencyFieldRefs {
    readonly id: FieldRef<"VirtualCurrency", "String">;
    readonly userId: FieldRef<"VirtualCurrency", "String">;
    readonly amount: FieldRef<"VirtualCurrency", "Int">;
    readonly type: FieldRef<"VirtualCurrency", "CurrencySourceType">;
    readonly createdAt: FieldRef<"VirtualCurrency", "DateTime">;
    readonly updatedAt: FieldRef<"VirtualCurrency", "DateTime">;
  }

  // Custom InputTypes
  /**
   * VirtualCurrency findUnique
   */
  export type VirtualCurrencyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * Filter, which VirtualCurrency to fetch.
     */
    where: VirtualCurrencyWhereUniqueInput;
  };

  /**
   * VirtualCurrency findUniqueOrThrow
   */
  export type VirtualCurrencyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * Filter, which VirtualCurrency to fetch.
     */
    where: VirtualCurrencyWhereUniqueInput;
  };

  /**
   * VirtualCurrency findFirst
   */
  export type VirtualCurrencyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * Filter, which VirtualCurrency to fetch.
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VirtualCurrencies to fetch.
     */
    orderBy?:
      | VirtualCurrencyOrderByWithRelationInput
      | VirtualCurrencyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VirtualCurrencies.
     */
    cursor?: VirtualCurrencyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VirtualCurrencies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VirtualCurrencies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VirtualCurrencies.
     */
    distinct?:
      | VirtualCurrencyScalarFieldEnum
      | VirtualCurrencyScalarFieldEnum[];
  };

  /**
   * VirtualCurrency findFirstOrThrow
   */
  export type VirtualCurrencyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * Filter, which VirtualCurrency to fetch.
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VirtualCurrencies to fetch.
     */
    orderBy?:
      | VirtualCurrencyOrderByWithRelationInput
      | VirtualCurrencyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VirtualCurrencies.
     */
    cursor?: VirtualCurrencyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VirtualCurrencies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VirtualCurrencies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VirtualCurrencies.
     */
    distinct?:
      | VirtualCurrencyScalarFieldEnum
      | VirtualCurrencyScalarFieldEnum[];
  };

  /**
   * VirtualCurrency findMany
   */
  export type VirtualCurrencyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * Filter, which VirtualCurrencies to fetch.
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VirtualCurrencies to fetch.
     */
    orderBy?:
      | VirtualCurrencyOrderByWithRelationInput
      | VirtualCurrencyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VirtualCurrencies.
     */
    cursor?: VirtualCurrencyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VirtualCurrencies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VirtualCurrencies.
     */
    skip?: number;
    distinct?:
      | VirtualCurrencyScalarFieldEnum
      | VirtualCurrencyScalarFieldEnum[];
  };

  /**
   * VirtualCurrency create
   */
  export type VirtualCurrencyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * The data needed to create a VirtualCurrency.
     */
    data: XOR<VirtualCurrencyCreateInput, VirtualCurrencyUncheckedCreateInput>;
  };

  /**
   * VirtualCurrency createMany
   */
  export type VirtualCurrencyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VirtualCurrencies.
     */
    data: VirtualCurrencyCreateManyInput | VirtualCurrencyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VirtualCurrency createManyAndReturn
   */
  export type VirtualCurrencyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * The data used to create many VirtualCurrencies.
     */
    data: VirtualCurrencyCreateManyInput | VirtualCurrencyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * VirtualCurrency update
   */
  export type VirtualCurrencyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * The data needed to update a VirtualCurrency.
     */
    data: XOR<VirtualCurrencyUpdateInput, VirtualCurrencyUncheckedUpdateInput>;
    /**
     * Choose, which VirtualCurrency to update.
     */
    where: VirtualCurrencyWhereUniqueInput;
  };

  /**
   * VirtualCurrency updateMany
   */
  export type VirtualCurrencyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VirtualCurrencies.
     */
    data: XOR<
      VirtualCurrencyUpdateManyMutationInput,
      VirtualCurrencyUncheckedUpdateManyInput
    >;
    /**
     * Filter which VirtualCurrencies to update
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * Limit how many VirtualCurrencies to update.
     */
    limit?: number;
  };

  /**
   * VirtualCurrency updateManyAndReturn
   */
  export type VirtualCurrencyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * The data used to update VirtualCurrencies.
     */
    data: XOR<
      VirtualCurrencyUpdateManyMutationInput,
      VirtualCurrencyUncheckedUpdateManyInput
    >;
    /**
     * Filter which VirtualCurrencies to update
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * Limit how many VirtualCurrencies to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * VirtualCurrency upsert
   */
  export type VirtualCurrencyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * The filter to search for the VirtualCurrency to update in case it exists.
     */
    where: VirtualCurrencyWhereUniqueInput;
    /**
     * In case the VirtualCurrency found by the `where` argument doesn't exist, create a new VirtualCurrency with this data.
     */
    create: XOR<
      VirtualCurrencyCreateInput,
      VirtualCurrencyUncheckedCreateInput
    >;
    /**
     * In case the VirtualCurrency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      VirtualCurrencyUpdateInput,
      VirtualCurrencyUncheckedUpdateInput
    >;
  };

  /**
   * VirtualCurrency delete
   */
  export type VirtualCurrencyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
    /**
     * Filter which VirtualCurrency to delete.
     */
    where: VirtualCurrencyWhereUniqueInput;
  };

  /**
   * VirtualCurrency deleteMany
   */
  export type VirtualCurrencyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VirtualCurrencies to delete
     */
    where?: VirtualCurrencyWhereInput;
    /**
     * Limit how many VirtualCurrencies to delete.
     */
    limit?: number;
  };

  /**
   * VirtualCurrency.transactionHistory
   */
  export type VirtualCurrency$transactionHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    where?: TransactionHistoryWhereInput;
    orderBy?:
      | TransactionHistoryOrderByWithRelationInput
      | TransactionHistoryOrderByWithRelationInput[];
    cursor?: TransactionHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TransactionHistoryScalarFieldEnum
      | TransactionHistoryScalarFieldEnum[];
  };

  /**
   * VirtualCurrency without action
   */
  export type VirtualCurrencyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VirtualCurrency
     */
    select?: VirtualCurrencySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VirtualCurrency
     */
    omit?: VirtualCurrencyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCurrencyInclude<ExtArgs> | null;
  };

  /**
   * Model TransactionHistory
   */

  export type AggregateTransactionHistory = {
    _count: TransactionHistoryCountAggregateOutputType | null;
    _avg: TransactionHistoryAvgAggregateOutputType | null;
    _sum: TransactionHistorySumAggregateOutputType | null;
    _min: TransactionHistoryMinAggregateOutputType | null;
    _max: TransactionHistoryMaxAggregateOutputType | null;
  };

  export type TransactionHistoryAvgAggregateOutputType = {
    amount: number | null;
  };

  export type TransactionHistorySumAggregateOutputType = {
    amount: number | null;
  };

  export type TransactionHistoryMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    transactionId: string | null;
    stripeSessionId: string | null;
    amount: number | null;
    transactionType: $Enums.TransactionType | null;
    description: string | null;
    createdAt: Date | null;
    virtualCurrencyId: string | null;
  };

  export type TransactionHistoryMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    transactionId: string | null;
    stripeSessionId: string | null;
    amount: number | null;
    transactionType: $Enums.TransactionType | null;
    description: string | null;
    createdAt: Date | null;
    virtualCurrencyId: string | null;
  };

  export type TransactionHistoryCountAggregateOutputType = {
    id: number;
    userId: number;
    transactionId: number;
    stripeSessionId: number;
    amount: number;
    transactionType: number;
    description: number;
    createdAt: number;
    virtualCurrencyId: number;
    _all: number;
  };

  export type TransactionHistoryAvgAggregateInputType = {
    amount?: true;
  };

  export type TransactionHistorySumAggregateInputType = {
    amount?: true;
  };

  export type TransactionHistoryMinAggregateInputType = {
    id?: true;
    userId?: true;
    transactionId?: true;
    stripeSessionId?: true;
    amount?: true;
    transactionType?: true;
    description?: true;
    createdAt?: true;
    virtualCurrencyId?: true;
  };

  export type TransactionHistoryMaxAggregateInputType = {
    id?: true;
    userId?: true;
    transactionId?: true;
    stripeSessionId?: true;
    amount?: true;
    transactionType?: true;
    description?: true;
    createdAt?: true;
    virtualCurrencyId?: true;
  };

  export type TransactionHistoryCountAggregateInputType = {
    id?: true;
    userId?: true;
    transactionId?: true;
    stripeSessionId?: true;
    amount?: true;
    transactionType?: true;
    description?: true;
    createdAt?: true;
    virtualCurrencyId?: true;
    _all?: true;
  };

  export type TransactionHistoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TransactionHistory to aggregate.
     */
    where?: TransactionHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?:
      | TransactionHistoryOrderByWithRelationInput
      | TransactionHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TransactionHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TransactionHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TransactionHistories
     **/
    _count?: true | TransactionHistoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TransactionHistoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TransactionHistorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TransactionHistoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TransactionHistoryMaxAggregateInputType;
  };

  export type GetTransactionHistoryAggregateType<
    T extends TransactionHistoryAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTransactionHistory]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionHistory[P]>
      : GetScalarType<T[P], AggregateTransactionHistory[P]>;
  };

  export type TransactionHistoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TransactionHistoryWhereInput;
    orderBy?:
      | TransactionHistoryOrderByWithAggregationInput
      | TransactionHistoryOrderByWithAggregationInput[];
    by: TransactionHistoryScalarFieldEnum[] | TransactionHistoryScalarFieldEnum;
    having?: TransactionHistoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TransactionHistoryCountAggregateInputType | true;
    _avg?: TransactionHistoryAvgAggregateInputType;
    _sum?: TransactionHistorySumAggregateInputType;
    _min?: TransactionHistoryMinAggregateInputType;
    _max?: TransactionHistoryMaxAggregateInputType;
  };

  export type TransactionHistoryGroupByOutputType = {
    id: string;
    userId: string;
    transactionId: string;
    stripeSessionId: string | null;
    amount: number;
    transactionType: $Enums.TransactionType;
    description: string | null;
    createdAt: Date;
    virtualCurrencyId: string;
    _count: TransactionHistoryCountAggregateOutputType | null;
    _avg: TransactionHistoryAvgAggregateOutputType | null;
    _sum: TransactionHistorySumAggregateOutputType | null;
    _min: TransactionHistoryMinAggregateOutputType | null;
    _max: TransactionHistoryMaxAggregateOutputType | null;
  };

  type GetTransactionHistoryGroupByPayload<
    T extends TransactionHistoryGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionHistoryGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof TransactionHistoryGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TransactionHistoryGroupByOutputType[P]>
          : GetScalarType<T[P], TransactionHistoryGroupByOutputType[P]>;
      }
    >
  >;

  export type TransactionHistorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      transactionId?: boolean;
      stripeSessionId?: boolean;
      amount?: boolean;
      transactionType?: boolean;
      description?: boolean;
      createdAt?: boolean;
      virtualCurrencyId?: boolean;
      virtualCurrency?: boolean | VirtualCurrencyDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["transactionHistory"]
  >;

  export type TransactionHistorySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      transactionId?: boolean;
      stripeSessionId?: boolean;
      amount?: boolean;
      transactionType?: boolean;
      description?: boolean;
      createdAt?: boolean;
      virtualCurrencyId?: boolean;
      virtualCurrency?: boolean | VirtualCurrencyDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["transactionHistory"]
  >;

  export type TransactionHistorySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      transactionId?: boolean;
      stripeSessionId?: boolean;
      amount?: boolean;
      transactionType?: boolean;
      description?: boolean;
      createdAt?: boolean;
      virtualCurrencyId?: boolean;
      virtualCurrency?: boolean | VirtualCurrencyDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["transactionHistory"]
  >;

  export type TransactionHistorySelectScalar = {
    id?: boolean;
    userId?: boolean;
    transactionId?: boolean;
    stripeSessionId?: boolean;
    amount?: boolean;
    transactionType?: boolean;
    description?: boolean;
    createdAt?: boolean;
    virtualCurrencyId?: boolean;
  };

  export type TransactionHistoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "transactionId"
    | "stripeSessionId"
    | "amount"
    | "transactionType"
    | "description"
    | "createdAt"
    | "virtualCurrencyId",
    ExtArgs["result"]["transactionHistory"]
  >;
  export type TransactionHistoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    virtualCurrency?: boolean | VirtualCurrencyDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type TransactionHistoryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    virtualCurrency?: boolean | VirtualCurrencyDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type TransactionHistoryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    virtualCurrency?: boolean | VirtualCurrencyDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TransactionHistoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TransactionHistory";
    objects: {
      virtualCurrency: Prisma.$VirtualCurrencyPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        transactionId: string;
        stripeSessionId: string | null;
        amount: number;
        transactionType: $Enums.TransactionType;
        description: string | null;
        createdAt: Date;
        virtualCurrencyId: string;
      },
      ExtArgs["result"]["transactionHistory"]
    >;
    composites: {};
  };

  type TransactionHistoryGetPayload<
    S extends boolean | null | undefined | TransactionHistoryDefaultArgs,
  > = $Result.GetResult<Prisma.$TransactionHistoryPayload, S>;

  type TransactionHistoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TransactionHistoryFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TransactionHistoryCountAggregateInputType | true;
  };

  export interface TransactionHistoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TransactionHistory"];
      meta: { name: "TransactionHistory" };
    };
    /**
     * Find zero or one TransactionHistory that matches the filter.
     * @param {TransactionHistoryFindUniqueArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionHistoryFindUniqueArgs>(
      args: SelectSubset<T, TransactionHistoryFindUniqueArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TransactionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionHistoryFindUniqueOrThrowArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionHistoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TransactionHistoryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TransactionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryFindFirstArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionHistoryFindFirstArgs>(
      args?: SelectSubset<T, TransactionHistoryFindFirstArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TransactionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryFindFirstOrThrowArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TransactionHistoryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TransactionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionHistories
     * const transactionHistories = await prisma.transactionHistory.findMany()
     *
     * // Get first 10 TransactionHistories
     * const transactionHistories = await prisma.transactionHistory.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const transactionHistoryWithIdOnly = await prisma.transactionHistory.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TransactionHistoryFindManyArgs>(
      args?: SelectSubset<T, TransactionHistoryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TransactionHistory.
     * @param {TransactionHistoryCreateArgs} args - Arguments to create a TransactionHistory.
     * @example
     * // Create one TransactionHistory
     * const TransactionHistory = await prisma.transactionHistory.create({
     *   data: {
     *     // ... data to create a TransactionHistory
     *   }
     * })
     *
     */
    create<T extends TransactionHistoryCreateArgs>(
      args: SelectSubset<T, TransactionHistoryCreateArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TransactionHistories.
     * @param {TransactionHistoryCreateManyArgs} args - Arguments to create many TransactionHistories.
     * @example
     * // Create many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TransactionHistoryCreateManyArgs>(
      args?: SelectSubset<T, TransactionHistoryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TransactionHistories and returns the data saved in the database.
     * @param {TransactionHistoryCreateManyAndReturnArgs} args - Arguments to create many TransactionHistories.
     * @example
     * // Create many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TransactionHistories and only return the `id`
     * const transactionHistoryWithIdOnly = await prisma.transactionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TransactionHistoryCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        TransactionHistoryCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a TransactionHistory.
     * @param {TransactionHistoryDeleteArgs} args - Arguments to delete one TransactionHistory.
     * @example
     * // Delete one TransactionHistory
     * const TransactionHistory = await prisma.transactionHistory.delete({
     *   where: {
     *     // ... filter to delete one TransactionHistory
     *   }
     * })
     *
     */
    delete<T extends TransactionHistoryDeleteArgs>(
      args: SelectSubset<T, TransactionHistoryDeleteArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TransactionHistory.
     * @param {TransactionHistoryUpdateArgs} args - Arguments to update one TransactionHistory.
     * @example
     * // Update one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TransactionHistoryUpdateArgs>(
      args: SelectSubset<T, TransactionHistoryUpdateArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TransactionHistories.
     * @param {TransactionHistoryDeleteManyArgs} args - Arguments to filter TransactionHistories to delete.
     * @example
     * // Delete a few TransactionHistories
     * const { count } = await prisma.transactionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TransactionHistoryDeleteManyArgs>(
      args?: SelectSubset<T, TransactionHistoryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TransactionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TransactionHistoryUpdateManyArgs>(
      args: SelectSubset<T, TransactionHistoryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TransactionHistories and returns the data updated in the database.
     * @param {TransactionHistoryUpdateManyAndReturnArgs} args - Arguments to update many TransactionHistories.
     * @example
     * // Update many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TransactionHistories and only return the `id`
     * const transactionHistoryWithIdOnly = await prisma.transactionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TransactionHistoryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TransactionHistoryUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one TransactionHistory.
     * @param {TransactionHistoryUpsertArgs} args - Arguments to update or create a TransactionHistory.
     * @example
     * // Update or create a TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.upsert({
     *   create: {
     *     // ... data to create a TransactionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionHistory we want to update
     *   }
     * })
     */
    upsert<T extends TransactionHistoryUpsertArgs>(
      args: SelectSubset<T, TransactionHistoryUpsertArgs<ExtArgs>>,
    ): Prisma__TransactionHistoryClient<
      $Result.GetResult<
        Prisma.$TransactionHistoryPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TransactionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryCountArgs} args - Arguments to filter TransactionHistories to count.
     * @example
     * // Count the number of TransactionHistories
     * const count = await prisma.transactionHistory.count({
     *   where: {
     *     // ... the filter for the TransactionHistories we want to count
     *   }
     * })
     **/
    count<T extends TransactionHistoryCountArgs>(
      args?: Subset<T, TransactionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              TransactionHistoryCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TransactionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TransactionHistoryAggregateArgs>(
      args: Subset<T, TransactionHistoryAggregateArgs>,
    ): Prisma.PrismaPromise<GetTransactionHistoryAggregateType<T>>;

    /**
     * Group by TransactionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TransactionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionHistoryGroupByArgs["orderBy"] }
        : { orderBy?: TransactionHistoryGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TransactionHistoryGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTransactionHistoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TransactionHistory model
     */
    readonly fields: TransactionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionHistoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    virtualCurrency<T extends VirtualCurrencyDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, VirtualCurrencyDefaultArgs<ExtArgs>>,
    ): Prisma__VirtualCurrencyClient<
      | $Result.GetResult<
          Prisma.$VirtualCurrencyPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TransactionHistory model
   */
  interface TransactionHistoryFieldRefs {
    readonly id: FieldRef<"TransactionHistory", "String">;
    readonly userId: FieldRef<"TransactionHistory", "String">;
    readonly transactionId: FieldRef<"TransactionHistory", "String">;
    readonly stripeSessionId: FieldRef<"TransactionHistory", "String">;
    readonly amount: FieldRef<"TransactionHistory", "Int">;
    readonly transactionType: FieldRef<"TransactionHistory", "TransactionType">;
    readonly description: FieldRef<"TransactionHistory", "String">;
    readonly createdAt: FieldRef<"TransactionHistory", "DateTime">;
    readonly virtualCurrencyId: FieldRef<"TransactionHistory", "String">;
  }

  // Custom InputTypes
  /**
   * TransactionHistory findUnique
   */
  export type TransactionHistoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where: TransactionHistoryWhereUniqueInput;
  };

  /**
   * TransactionHistory findUniqueOrThrow
   */
  export type TransactionHistoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where: TransactionHistoryWhereUniqueInput;
  };

  /**
   * TransactionHistory findFirst
   */
  export type TransactionHistoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where?: TransactionHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?:
      | TransactionHistoryOrderByWithRelationInput
      | TransactionHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TransactionHistories.
     */
    cursor?: TransactionHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TransactionHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TransactionHistories.
     */
    distinct?:
      | TransactionHistoryScalarFieldEnum
      | TransactionHistoryScalarFieldEnum[];
  };

  /**
   * TransactionHistory findFirstOrThrow
   */
  export type TransactionHistoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where?: TransactionHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?:
      | TransactionHistoryOrderByWithRelationInput
      | TransactionHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TransactionHistories.
     */
    cursor?: TransactionHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TransactionHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TransactionHistories.
     */
    distinct?:
      | TransactionHistoryScalarFieldEnum
      | TransactionHistoryScalarFieldEnum[];
  };

  /**
   * TransactionHistory findMany
   */
  export type TransactionHistoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which TransactionHistories to fetch.
     */
    where?: TransactionHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?:
      | TransactionHistoryOrderByWithRelationInput
      | TransactionHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TransactionHistories.
     */
    cursor?: TransactionHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TransactionHistories.
     */
    skip?: number;
    distinct?:
      | TransactionHistoryScalarFieldEnum
      | TransactionHistoryScalarFieldEnum[];
  };

  /**
   * TransactionHistory create
   */
  export type TransactionHistoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a TransactionHistory.
     */
    data: XOR<
      TransactionHistoryCreateInput,
      TransactionHistoryUncheckedCreateInput
    >;
  };

  /**
   * TransactionHistory createMany
   */
  export type TransactionHistoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TransactionHistories.
     */
    data:
      | TransactionHistoryCreateManyInput
      | TransactionHistoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TransactionHistory createManyAndReturn
   */
  export type TransactionHistoryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * The data used to create many TransactionHistories.
     */
    data:
      | TransactionHistoryCreateManyInput
      | TransactionHistoryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TransactionHistory update
   */
  export type TransactionHistoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a TransactionHistory.
     */
    data: XOR<
      TransactionHistoryUpdateInput,
      TransactionHistoryUncheckedUpdateInput
    >;
    /**
     * Choose, which TransactionHistory to update.
     */
    where: TransactionHistoryWhereUniqueInput;
  };

  /**
   * TransactionHistory updateMany
   */
  export type TransactionHistoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TransactionHistories.
     */
    data: XOR<
      TransactionHistoryUpdateManyMutationInput,
      TransactionHistoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which TransactionHistories to update
     */
    where?: TransactionHistoryWhereInput;
    /**
     * Limit how many TransactionHistories to update.
     */
    limit?: number;
  };

  /**
   * TransactionHistory updateManyAndReturn
   */
  export type TransactionHistoryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * The data used to update TransactionHistories.
     */
    data: XOR<
      TransactionHistoryUpdateManyMutationInput,
      TransactionHistoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which TransactionHistories to update
     */
    where?: TransactionHistoryWhereInput;
    /**
     * Limit how many TransactionHistories to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TransactionHistory upsert
   */
  export type TransactionHistoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the TransactionHistory to update in case it exists.
     */
    where: TransactionHistoryWhereUniqueInput;
    /**
     * In case the TransactionHistory found by the `where` argument doesn't exist, create a new TransactionHistory with this data.
     */
    create: XOR<
      TransactionHistoryCreateInput,
      TransactionHistoryUncheckedCreateInput
    >;
    /**
     * In case the TransactionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      TransactionHistoryUpdateInput,
      TransactionHistoryUncheckedUpdateInput
    >;
  };

  /**
   * TransactionHistory delete
   */
  export type TransactionHistoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
    /**
     * Filter which TransactionHistory to delete.
     */
    where: TransactionHistoryWhereUniqueInput;
  };

  /**
   * TransactionHistory deleteMany
   */
  export type TransactionHistoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TransactionHistories to delete
     */
    where?: TransactionHistoryWhereInput;
    /**
     * Limit how many TransactionHistories to delete.
     */
    limit?: number;
  };

  /**
   * TransactionHistory without action
   */
  export type TransactionHistoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null;
  };

  /**
   * Model Craft
   */

  export type AggregateCraft = {
    _count: CraftCountAggregateOutputType | null;
    _min: CraftMinAggregateOutputType | null;
    _max: CraftMaxAggregateOutputType | null;
  };

  export type CraftMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    resultId: string | null;
    createdAt: Date | null;
  };

  export type CraftMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    resultId: string | null;
    createdAt: Date | null;
  };

  export type CraftCountAggregateOutputType = {
    id: number;
    userId: number;
    resultId: number;
    createdAt: number;
    _all: number;
  };

  export type CraftMinAggregateInputType = {
    id?: true;
    userId?: true;
    resultId?: true;
    createdAt?: true;
  };

  export type CraftMaxAggregateInputType = {
    id?: true;
    userId?: true;
    resultId?: true;
    createdAt?: true;
  };

  export type CraftCountAggregateInputType = {
    id?: true;
    userId?: true;
    resultId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type CraftAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Craft to aggregate.
     */
    where?: CraftWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Crafts to fetch.
     */
    orderBy?: CraftOrderByWithRelationInput | CraftOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CraftWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Crafts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Crafts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Crafts
     **/
    _count?: true | CraftCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CraftMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CraftMaxAggregateInputType;
  };

  export type GetCraftAggregateType<T extends CraftAggregateArgs> = {
    [P in keyof T & keyof AggregateCraft]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCraft[P]>
      : GetScalarType<T[P], AggregateCraft[P]>;
  };

  export type CraftGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CraftWhereInput;
    orderBy?:
      | CraftOrderByWithAggregationInput
      | CraftOrderByWithAggregationInput[];
    by: CraftScalarFieldEnum[] | CraftScalarFieldEnum;
    having?: CraftScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CraftCountAggregateInputType | true;
    _min?: CraftMinAggregateInputType;
    _max?: CraftMaxAggregateInputType;
  };

  export type CraftGroupByOutputType = {
    id: string;
    userId: string;
    resultId: string;
    createdAt: Date;
    _count: CraftCountAggregateOutputType | null;
    _min: CraftMinAggregateOutputType | null;
    _max: CraftMaxAggregateOutputType | null;
  };

  type GetCraftGroupByPayload<T extends CraftGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CraftGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof CraftGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CraftGroupByOutputType[P]>
            : GetScalarType<T[P], CraftGroupByOutputType[P]>;
        }
      >
    >;

  export type CraftSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      resultId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      result?: boolean | ArtefactDefaultArgs<ExtArgs>;
      materials?: boolean | Craft$materialsArgs<ExtArgs>;
      _count?: boolean | CraftCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["craft"]
  >;

  export type CraftSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      resultId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      result?: boolean | ArtefactDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["craft"]
  >;

  export type CraftSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      resultId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      result?: boolean | ArtefactDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["craft"]
  >;

  export type CraftSelectScalar = {
    id?: boolean;
    userId?: boolean;
    resultId?: boolean;
    createdAt?: boolean;
  };

  export type CraftOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "resultId" | "createdAt",
    ExtArgs["result"]["craft"]
  >;
  export type CraftInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    result?: boolean | ArtefactDefaultArgs<ExtArgs>;
    materials?: boolean | Craft$materialsArgs<ExtArgs>;
    _count?: boolean | CraftCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CraftIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    result?: boolean | ArtefactDefaultArgs<ExtArgs>;
  };
  export type CraftIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    result?: boolean | ArtefactDefaultArgs<ExtArgs>;
  };

  export type $CraftPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Craft";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      result: Prisma.$ArtefactPayload<ExtArgs>;
      materials: Prisma.$CraftMaterialPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        resultId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["craft"]
    >;
    composites: {};
  };

  type CraftGetPayload<
    S extends boolean | null | undefined | CraftDefaultArgs,
  > = $Result.GetResult<Prisma.$CraftPayload, S>;

  type CraftCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CraftFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: CraftCountAggregateInputType | true;
  };

  export interface CraftDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Craft"];
      meta: { name: "Craft" };
    };
    /**
     * Find zero or one Craft that matches the filter.
     * @param {CraftFindUniqueArgs} args - Arguments to find a Craft
     * @example
     * // Get one Craft
     * const craft = await prisma.craft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CraftFindUniqueArgs>(
      args: SelectSubset<T, CraftFindUniqueArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Craft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CraftFindUniqueOrThrowArgs} args - Arguments to find a Craft
     * @example
     * // Get one Craft
     * const craft = await prisma.craft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CraftFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CraftFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Craft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftFindFirstArgs} args - Arguments to find a Craft
     * @example
     * // Get one Craft
     * const craft = await prisma.craft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CraftFindFirstArgs>(
      args?: SelectSubset<T, CraftFindFirstArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Craft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftFindFirstOrThrowArgs} args - Arguments to find a Craft
     * @example
     * // Get one Craft
     * const craft = await prisma.craft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CraftFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CraftFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Crafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crafts
     * const crafts = await prisma.craft.findMany()
     *
     * // Get first 10 Crafts
     * const crafts = await prisma.craft.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const craftWithIdOnly = await prisma.craft.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CraftFindManyArgs>(
      args?: SelectSubset<T, CraftFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Craft.
     * @param {CraftCreateArgs} args - Arguments to create a Craft.
     * @example
     * // Create one Craft
     * const Craft = await prisma.craft.create({
     *   data: {
     *     // ... data to create a Craft
     *   }
     * })
     *
     */
    create<T extends CraftCreateArgs>(
      args: SelectSubset<T, CraftCreateArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Crafts.
     * @param {CraftCreateManyArgs} args - Arguments to create many Crafts.
     * @example
     * // Create many Crafts
     * const craft = await prisma.craft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CraftCreateManyArgs>(
      args?: SelectSubset<T, CraftCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Crafts and returns the data saved in the database.
     * @param {CraftCreateManyAndReturnArgs} args - Arguments to create many Crafts.
     * @example
     * // Create many Crafts
     * const craft = await prisma.craft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Crafts and only return the `id`
     * const craftWithIdOnly = await prisma.craft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CraftCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CraftCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Craft.
     * @param {CraftDeleteArgs} args - Arguments to delete one Craft.
     * @example
     * // Delete one Craft
     * const Craft = await prisma.craft.delete({
     *   where: {
     *     // ... filter to delete one Craft
     *   }
     * })
     *
     */
    delete<T extends CraftDeleteArgs>(
      args: SelectSubset<T, CraftDeleteArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Craft.
     * @param {CraftUpdateArgs} args - Arguments to update one Craft.
     * @example
     * // Update one Craft
     * const craft = await prisma.craft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CraftUpdateArgs>(
      args: SelectSubset<T, CraftUpdateArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Crafts.
     * @param {CraftDeleteManyArgs} args - Arguments to filter Crafts to delete.
     * @example
     * // Delete a few Crafts
     * const { count } = await prisma.craft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CraftDeleteManyArgs>(
      args?: SelectSubset<T, CraftDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Crafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crafts
     * const craft = await prisma.craft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CraftUpdateManyArgs>(
      args: SelectSubset<T, CraftUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Crafts and returns the data updated in the database.
     * @param {CraftUpdateManyAndReturnArgs} args - Arguments to update many Crafts.
     * @example
     * // Update many Crafts
     * const craft = await prisma.craft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Crafts and only return the `id`
     * const craftWithIdOnly = await prisma.craft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CraftUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CraftUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Craft.
     * @param {CraftUpsertArgs} args - Arguments to update or create a Craft.
     * @example
     * // Update or create a Craft
     * const craft = await prisma.craft.upsert({
     *   create: {
     *     // ... data to create a Craft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Craft we want to update
     *   }
     * })
     */
    upsert<T extends CraftUpsertArgs>(
      args: SelectSubset<T, CraftUpsertArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      $Result.GetResult<
        Prisma.$CraftPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Crafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftCountArgs} args - Arguments to filter Crafts to count.
     * @example
     * // Count the number of Crafts
     * const count = await prisma.craft.count({
     *   where: {
     *     // ... the filter for the Crafts we want to count
     *   }
     * })
     **/
    count<T extends CraftCountArgs>(
      args?: Subset<T, CraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CraftCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Craft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CraftAggregateArgs>(
      args: Subset<T, CraftAggregateArgs>,
    ): Prisma.PrismaPromise<GetCraftAggregateType<T>>;

    /**
     * Group by Craft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CraftGroupByArgs["orderBy"] }
        : { orderBy?: CraftGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CraftGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCraftGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Craft model
     */
    readonly fields: CraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Craft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CraftClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    result<T extends ArtefactDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ArtefactDefaultArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      | $Result.GetResult<
          Prisma.$ArtefactPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    materials<T extends Craft$materialsArgs<ExtArgs> = {}>(
      args?: Subset<T, Craft$materialsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CraftMaterialPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Craft model
   */
  interface CraftFieldRefs {
    readonly id: FieldRef<"Craft", "String">;
    readonly userId: FieldRef<"Craft", "String">;
    readonly resultId: FieldRef<"Craft", "String">;
    readonly createdAt: FieldRef<"Craft", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Craft findUnique
   */
  export type CraftFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * Filter, which Craft to fetch.
     */
    where: CraftWhereUniqueInput;
  };

  /**
   * Craft findUniqueOrThrow
   */
  export type CraftFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * Filter, which Craft to fetch.
     */
    where: CraftWhereUniqueInput;
  };

  /**
   * Craft findFirst
   */
  export type CraftFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * Filter, which Craft to fetch.
     */
    where?: CraftWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Crafts to fetch.
     */
    orderBy?: CraftOrderByWithRelationInput | CraftOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Crafts.
     */
    cursor?: CraftWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Crafts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Crafts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Crafts.
     */
    distinct?: CraftScalarFieldEnum | CraftScalarFieldEnum[];
  };

  /**
   * Craft findFirstOrThrow
   */
  export type CraftFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * Filter, which Craft to fetch.
     */
    where?: CraftWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Crafts to fetch.
     */
    orderBy?: CraftOrderByWithRelationInput | CraftOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Crafts.
     */
    cursor?: CraftWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Crafts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Crafts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Crafts.
     */
    distinct?: CraftScalarFieldEnum | CraftScalarFieldEnum[];
  };

  /**
   * Craft findMany
   */
  export type CraftFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * Filter, which Crafts to fetch.
     */
    where?: CraftWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Crafts to fetch.
     */
    orderBy?: CraftOrderByWithRelationInput | CraftOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Crafts.
     */
    cursor?: CraftWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Crafts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Crafts.
     */
    skip?: number;
    distinct?: CraftScalarFieldEnum | CraftScalarFieldEnum[];
  };

  /**
   * Craft create
   */
  export type CraftCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * The data needed to create a Craft.
     */
    data: XOR<CraftCreateInput, CraftUncheckedCreateInput>;
  };

  /**
   * Craft createMany
   */
  export type CraftCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Crafts.
     */
    data: CraftCreateManyInput | CraftCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Craft createManyAndReturn
   */
  export type CraftCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * The data used to create many Crafts.
     */
    data: CraftCreateManyInput | CraftCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Craft update
   */
  export type CraftUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * The data needed to update a Craft.
     */
    data: XOR<CraftUpdateInput, CraftUncheckedUpdateInput>;
    /**
     * Choose, which Craft to update.
     */
    where: CraftWhereUniqueInput;
  };

  /**
   * Craft updateMany
   */
  export type CraftUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Crafts.
     */
    data: XOR<CraftUpdateManyMutationInput, CraftUncheckedUpdateManyInput>;
    /**
     * Filter which Crafts to update
     */
    where?: CraftWhereInput;
    /**
     * Limit how many Crafts to update.
     */
    limit?: number;
  };

  /**
   * Craft updateManyAndReturn
   */
  export type CraftUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * The data used to update Crafts.
     */
    data: XOR<CraftUpdateManyMutationInput, CraftUncheckedUpdateManyInput>;
    /**
     * Filter which Crafts to update
     */
    where?: CraftWhereInput;
    /**
     * Limit how many Crafts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Craft upsert
   */
  export type CraftUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * The filter to search for the Craft to update in case it exists.
     */
    where: CraftWhereUniqueInput;
    /**
     * In case the Craft found by the `where` argument doesn't exist, create a new Craft with this data.
     */
    create: XOR<CraftCreateInput, CraftUncheckedCreateInput>;
    /**
     * In case the Craft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CraftUpdateInput, CraftUncheckedUpdateInput>;
  };

  /**
   * Craft delete
   */
  export type CraftDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
    /**
     * Filter which Craft to delete.
     */
    where: CraftWhereUniqueInput;
  };

  /**
   * Craft deleteMany
   */
  export type CraftDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Crafts to delete
     */
    where?: CraftWhereInput;
    /**
     * Limit how many Crafts to delete.
     */
    limit?: number;
  };

  /**
   * Craft.materials
   */
  export type Craft$materialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    where?: CraftMaterialWhereInput;
    orderBy?:
      | CraftMaterialOrderByWithRelationInput
      | CraftMaterialOrderByWithRelationInput[];
    cursor?: CraftMaterialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CraftMaterialScalarFieldEnum | CraftMaterialScalarFieldEnum[];
  };

  /**
   * Craft without action
   */
  export type CraftDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Craft
     */
    select?: CraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Craft
     */
    omit?: CraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInclude<ExtArgs> | null;
  };

  /**
   * Model CraftMaterial
   */

  export type AggregateCraftMaterial = {
    _count: CraftMaterialCountAggregateOutputType | null;
    _min: CraftMaterialMinAggregateOutputType | null;
    _max: CraftMaterialMaxAggregateOutputType | null;
  };

  export type CraftMaterialMinAggregateOutputType = {
    id: string | null;
    craftId: string | null;
    artefactId: string | null;
  };

  export type CraftMaterialMaxAggregateOutputType = {
    id: string | null;
    craftId: string | null;
    artefactId: string | null;
  };

  export type CraftMaterialCountAggregateOutputType = {
    id: number;
    craftId: number;
    artefactId: number;
    _all: number;
  };

  export type CraftMaterialMinAggregateInputType = {
    id?: true;
    craftId?: true;
    artefactId?: true;
  };

  export type CraftMaterialMaxAggregateInputType = {
    id?: true;
    craftId?: true;
    artefactId?: true;
  };

  export type CraftMaterialCountAggregateInputType = {
    id?: true;
    craftId?: true;
    artefactId?: true;
    _all?: true;
  };

  export type CraftMaterialAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CraftMaterial to aggregate.
     */
    where?: CraftMaterialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CraftMaterials to fetch.
     */
    orderBy?:
      | CraftMaterialOrderByWithRelationInput
      | CraftMaterialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CraftMaterialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CraftMaterials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CraftMaterials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CraftMaterials
     **/
    _count?: true | CraftMaterialCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CraftMaterialMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CraftMaterialMaxAggregateInputType;
  };

  export type GetCraftMaterialAggregateType<
    T extends CraftMaterialAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateCraftMaterial]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCraftMaterial[P]>
      : GetScalarType<T[P], AggregateCraftMaterial[P]>;
  };

  export type CraftMaterialGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CraftMaterialWhereInput;
    orderBy?:
      | CraftMaterialOrderByWithAggregationInput
      | CraftMaterialOrderByWithAggregationInput[];
    by: CraftMaterialScalarFieldEnum[] | CraftMaterialScalarFieldEnum;
    having?: CraftMaterialScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CraftMaterialCountAggregateInputType | true;
    _min?: CraftMaterialMinAggregateInputType;
    _max?: CraftMaterialMaxAggregateInputType;
  };

  export type CraftMaterialGroupByOutputType = {
    id: string;
    craftId: string;
    artefactId: string;
    _count: CraftMaterialCountAggregateOutputType | null;
    _min: CraftMaterialMinAggregateOutputType | null;
    _max: CraftMaterialMaxAggregateOutputType | null;
  };

  type GetCraftMaterialGroupByPayload<T extends CraftMaterialGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CraftMaterialGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof CraftMaterialGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CraftMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], CraftMaterialGroupByOutputType[P]>;
        }
      >
    >;

  export type CraftMaterialSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      craftId?: boolean;
      artefactId?: boolean;
      craft?: boolean | CraftDefaultArgs<ExtArgs>;
      artefact?: boolean | ArtefactDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["craftMaterial"]
  >;

  export type CraftMaterialSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      craftId?: boolean;
      artefactId?: boolean;
      craft?: boolean | CraftDefaultArgs<ExtArgs>;
      artefact?: boolean | ArtefactDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["craftMaterial"]
  >;

  export type CraftMaterialSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      craftId?: boolean;
      artefactId?: boolean;
      craft?: boolean | CraftDefaultArgs<ExtArgs>;
      artefact?: boolean | ArtefactDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["craftMaterial"]
  >;

  export type CraftMaterialSelectScalar = {
    id?: boolean;
    craftId?: boolean;
    artefactId?: boolean;
  };

  export type CraftMaterialOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "craftId" | "artefactId",
    ExtArgs["result"]["craftMaterial"]
  >;
  export type CraftMaterialInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    craft?: boolean | CraftDefaultArgs<ExtArgs>;
    artefact?: boolean | ArtefactDefaultArgs<ExtArgs>;
  };
  export type CraftMaterialIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    craft?: boolean | CraftDefaultArgs<ExtArgs>;
    artefact?: boolean | ArtefactDefaultArgs<ExtArgs>;
  };
  export type CraftMaterialIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    craft?: boolean | CraftDefaultArgs<ExtArgs>;
    artefact?: boolean | ArtefactDefaultArgs<ExtArgs>;
  };

  export type $CraftMaterialPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "CraftMaterial";
    objects: {
      craft: Prisma.$CraftPayload<ExtArgs>;
      artefact: Prisma.$ArtefactPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        craftId: string;
        artefactId: string;
      },
      ExtArgs["result"]["craftMaterial"]
    >;
    composites: {};
  };

  type CraftMaterialGetPayload<
    S extends boolean | null | undefined | CraftMaterialDefaultArgs,
  > = $Result.GetResult<Prisma.$CraftMaterialPayload, S>;

  type CraftMaterialCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    CraftMaterialFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: CraftMaterialCountAggregateInputType | true;
  };

  export interface CraftMaterialDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["CraftMaterial"];
      meta: { name: "CraftMaterial" };
    };
    /**
     * Find zero or one CraftMaterial that matches the filter.
     * @param {CraftMaterialFindUniqueArgs} args - Arguments to find a CraftMaterial
     * @example
     * // Get one CraftMaterial
     * const craftMaterial = await prisma.craftMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CraftMaterialFindUniqueArgs>(
      args: SelectSubset<T, CraftMaterialFindUniqueArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CraftMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CraftMaterialFindUniqueOrThrowArgs} args - Arguments to find a CraftMaterial
     * @example
     * // Get one CraftMaterial
     * const craftMaterial = await prisma.craftMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CraftMaterialFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CraftMaterialFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CraftMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialFindFirstArgs} args - Arguments to find a CraftMaterial
     * @example
     * // Get one CraftMaterial
     * const craftMaterial = await prisma.craftMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CraftMaterialFindFirstArgs>(
      args?: SelectSubset<T, CraftMaterialFindFirstArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CraftMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialFindFirstOrThrowArgs} args - Arguments to find a CraftMaterial
     * @example
     * // Get one CraftMaterial
     * const craftMaterial = await prisma.craftMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CraftMaterialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CraftMaterialFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CraftMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CraftMaterials
     * const craftMaterials = await prisma.craftMaterial.findMany()
     *
     * // Get first 10 CraftMaterials
     * const craftMaterials = await prisma.craftMaterial.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const craftMaterialWithIdOnly = await prisma.craftMaterial.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CraftMaterialFindManyArgs>(
      args?: SelectSubset<T, CraftMaterialFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CraftMaterial.
     * @param {CraftMaterialCreateArgs} args - Arguments to create a CraftMaterial.
     * @example
     * // Create one CraftMaterial
     * const CraftMaterial = await prisma.craftMaterial.create({
     *   data: {
     *     // ... data to create a CraftMaterial
     *   }
     * })
     *
     */
    create<T extends CraftMaterialCreateArgs>(
      args: SelectSubset<T, CraftMaterialCreateArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CraftMaterials.
     * @param {CraftMaterialCreateManyArgs} args - Arguments to create many CraftMaterials.
     * @example
     * // Create many CraftMaterials
     * const craftMaterial = await prisma.craftMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CraftMaterialCreateManyArgs>(
      args?: SelectSubset<T, CraftMaterialCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CraftMaterials and returns the data saved in the database.
     * @param {CraftMaterialCreateManyAndReturnArgs} args - Arguments to create many CraftMaterials.
     * @example
     * // Create many CraftMaterials
     * const craftMaterial = await prisma.craftMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CraftMaterials and only return the `id`
     * const craftMaterialWithIdOnly = await prisma.craftMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CraftMaterialCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CraftMaterialCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a CraftMaterial.
     * @param {CraftMaterialDeleteArgs} args - Arguments to delete one CraftMaterial.
     * @example
     * // Delete one CraftMaterial
     * const CraftMaterial = await prisma.craftMaterial.delete({
     *   where: {
     *     // ... filter to delete one CraftMaterial
     *   }
     * })
     *
     */
    delete<T extends CraftMaterialDeleteArgs>(
      args: SelectSubset<T, CraftMaterialDeleteArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CraftMaterial.
     * @param {CraftMaterialUpdateArgs} args - Arguments to update one CraftMaterial.
     * @example
     * // Update one CraftMaterial
     * const craftMaterial = await prisma.craftMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CraftMaterialUpdateArgs>(
      args: SelectSubset<T, CraftMaterialUpdateArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CraftMaterials.
     * @param {CraftMaterialDeleteManyArgs} args - Arguments to filter CraftMaterials to delete.
     * @example
     * // Delete a few CraftMaterials
     * const { count } = await prisma.craftMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CraftMaterialDeleteManyArgs>(
      args?: SelectSubset<T, CraftMaterialDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CraftMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CraftMaterials
     * const craftMaterial = await prisma.craftMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CraftMaterialUpdateManyArgs>(
      args: SelectSubset<T, CraftMaterialUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CraftMaterials and returns the data updated in the database.
     * @param {CraftMaterialUpdateManyAndReturnArgs} args - Arguments to update many CraftMaterials.
     * @example
     * // Update many CraftMaterials
     * const craftMaterial = await prisma.craftMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CraftMaterials and only return the `id`
     * const craftMaterialWithIdOnly = await prisma.craftMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CraftMaterialUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CraftMaterialUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one CraftMaterial.
     * @param {CraftMaterialUpsertArgs} args - Arguments to update or create a CraftMaterial.
     * @example
     * // Update or create a CraftMaterial
     * const craftMaterial = await prisma.craftMaterial.upsert({
     *   create: {
     *     // ... data to create a CraftMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CraftMaterial we want to update
     *   }
     * })
     */
    upsert<T extends CraftMaterialUpsertArgs>(
      args: SelectSubset<T, CraftMaterialUpsertArgs<ExtArgs>>,
    ): Prisma__CraftMaterialClient<
      $Result.GetResult<
        Prisma.$CraftMaterialPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CraftMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialCountArgs} args - Arguments to filter CraftMaterials to count.
     * @example
     * // Count the number of CraftMaterials
     * const count = await prisma.craftMaterial.count({
     *   where: {
     *     // ... the filter for the CraftMaterials we want to count
     *   }
     * })
     **/
    count<T extends CraftMaterialCountArgs>(
      args?: Subset<T, CraftMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CraftMaterialCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CraftMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CraftMaterialAggregateArgs>(
      args: Subset<T, CraftMaterialAggregateArgs>,
    ): Prisma.PrismaPromise<GetCraftMaterialAggregateType<T>>;

    /**
     * Group by CraftMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CraftMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CraftMaterialGroupByArgs["orderBy"] }
        : { orderBy?: CraftMaterialGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CraftMaterialGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetCraftMaterialGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CraftMaterial model
     */
    readonly fields: CraftMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CraftMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CraftMaterialClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    craft<T extends CraftDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CraftDefaultArgs<ExtArgs>>,
    ): Prisma__CraftClient<
      | $Result.GetResult<
          Prisma.$CraftPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    artefact<T extends ArtefactDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ArtefactDefaultArgs<ExtArgs>>,
    ): Prisma__ArtefactClient<
      | $Result.GetResult<
          Prisma.$ArtefactPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CraftMaterial model
   */
  interface CraftMaterialFieldRefs {
    readonly id: FieldRef<"CraftMaterial", "String">;
    readonly craftId: FieldRef<"CraftMaterial", "String">;
    readonly artefactId: FieldRef<"CraftMaterial", "String">;
  }

  // Custom InputTypes
  /**
   * CraftMaterial findUnique
   */
  export type CraftMaterialFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * Filter, which CraftMaterial to fetch.
     */
    where: CraftMaterialWhereUniqueInput;
  };

  /**
   * CraftMaterial findUniqueOrThrow
   */
  export type CraftMaterialFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * Filter, which CraftMaterial to fetch.
     */
    where: CraftMaterialWhereUniqueInput;
  };

  /**
   * CraftMaterial findFirst
   */
  export type CraftMaterialFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * Filter, which CraftMaterial to fetch.
     */
    where?: CraftMaterialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CraftMaterials to fetch.
     */
    orderBy?:
      | CraftMaterialOrderByWithRelationInput
      | CraftMaterialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CraftMaterials.
     */
    cursor?: CraftMaterialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CraftMaterials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CraftMaterials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CraftMaterials.
     */
    distinct?: CraftMaterialScalarFieldEnum | CraftMaterialScalarFieldEnum[];
  };

  /**
   * CraftMaterial findFirstOrThrow
   */
  export type CraftMaterialFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * Filter, which CraftMaterial to fetch.
     */
    where?: CraftMaterialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CraftMaterials to fetch.
     */
    orderBy?:
      | CraftMaterialOrderByWithRelationInput
      | CraftMaterialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CraftMaterials.
     */
    cursor?: CraftMaterialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CraftMaterials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CraftMaterials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CraftMaterials.
     */
    distinct?: CraftMaterialScalarFieldEnum | CraftMaterialScalarFieldEnum[];
  };

  /**
   * CraftMaterial findMany
   */
  export type CraftMaterialFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * Filter, which CraftMaterials to fetch.
     */
    where?: CraftMaterialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CraftMaterials to fetch.
     */
    orderBy?:
      | CraftMaterialOrderByWithRelationInput
      | CraftMaterialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CraftMaterials.
     */
    cursor?: CraftMaterialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CraftMaterials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CraftMaterials.
     */
    skip?: number;
    distinct?: CraftMaterialScalarFieldEnum | CraftMaterialScalarFieldEnum[];
  };

  /**
   * CraftMaterial create
   */
  export type CraftMaterialCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * The data needed to create a CraftMaterial.
     */
    data: XOR<CraftMaterialCreateInput, CraftMaterialUncheckedCreateInput>;
  };

  /**
   * CraftMaterial createMany
   */
  export type CraftMaterialCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CraftMaterials.
     */
    data: CraftMaterialCreateManyInput | CraftMaterialCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CraftMaterial createManyAndReturn
   */
  export type CraftMaterialCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * The data used to create many CraftMaterials.
     */
    data: CraftMaterialCreateManyInput | CraftMaterialCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CraftMaterial update
   */
  export type CraftMaterialUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * The data needed to update a CraftMaterial.
     */
    data: XOR<CraftMaterialUpdateInput, CraftMaterialUncheckedUpdateInput>;
    /**
     * Choose, which CraftMaterial to update.
     */
    where: CraftMaterialWhereUniqueInput;
  };

  /**
   * CraftMaterial updateMany
   */
  export type CraftMaterialUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CraftMaterials.
     */
    data: XOR<
      CraftMaterialUpdateManyMutationInput,
      CraftMaterialUncheckedUpdateManyInput
    >;
    /**
     * Filter which CraftMaterials to update
     */
    where?: CraftMaterialWhereInput;
    /**
     * Limit how many CraftMaterials to update.
     */
    limit?: number;
  };

  /**
   * CraftMaterial updateManyAndReturn
   */
  export type CraftMaterialUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * The data used to update CraftMaterials.
     */
    data: XOR<
      CraftMaterialUpdateManyMutationInput,
      CraftMaterialUncheckedUpdateManyInput
    >;
    /**
     * Filter which CraftMaterials to update
     */
    where?: CraftMaterialWhereInput;
    /**
     * Limit how many CraftMaterials to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CraftMaterial upsert
   */
  export type CraftMaterialUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * The filter to search for the CraftMaterial to update in case it exists.
     */
    where: CraftMaterialWhereUniqueInput;
    /**
     * In case the CraftMaterial found by the `where` argument doesn't exist, create a new CraftMaterial with this data.
     */
    create: XOR<CraftMaterialCreateInput, CraftMaterialUncheckedCreateInput>;
    /**
     * In case the CraftMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CraftMaterialUpdateInput, CraftMaterialUncheckedUpdateInput>;
  };

  /**
   * CraftMaterial delete
   */
  export type CraftMaterialDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
    /**
     * Filter which CraftMaterial to delete.
     */
    where: CraftMaterialWhereUniqueInput;
  };

  /**
   * CraftMaterial deleteMany
   */
  export type CraftMaterialDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CraftMaterials to delete
     */
    where?: CraftMaterialWhereInput;
    /**
     * Limit how many CraftMaterials to delete.
     */
    limit?: number;
  };

  /**
   * CraftMaterial without action
   */
  export type CraftMaterialDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CraftMaterial
     */
    select?: CraftMaterialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CraftMaterial
     */
    omit?: CraftMaterialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftMaterialInclude<ExtArgs> | null;
  };

  /**
   * Model LeaderboardEntry
   */

  export type AggregateLeaderboardEntry = {
    _count: LeaderboardEntryCountAggregateOutputType | null;
    _avg: LeaderboardEntryAvgAggregateOutputType | null;
    _sum: LeaderboardEntrySumAggregateOutputType | null;
    _min: LeaderboardEntryMinAggregateOutputType | null;
    _max: LeaderboardEntryMaxAggregateOutputType | null;
  };

  export type LeaderboardEntryAvgAggregateOutputType = {
    rank: number | null;
    score: number | null;
  };

  export type LeaderboardEntrySumAggregateOutputType = {
    rank: number | null;
    score: number | null;
  };

  export type LeaderboardEntryMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    huntId: string | null;
    rank: number | null;
    score: number | null;
    completedAt: Date | null;
  };

  export type LeaderboardEntryMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    huntId: string | null;
    rank: number | null;
    score: number | null;
    completedAt: Date | null;
  };

  export type LeaderboardEntryCountAggregateOutputType = {
    id: number;
    userId: number;
    huntId: number;
    rank: number;
    score: number;
    completedAt: number;
    _all: number;
  };

  export type LeaderboardEntryAvgAggregateInputType = {
    rank?: true;
    score?: true;
  };

  export type LeaderboardEntrySumAggregateInputType = {
    rank?: true;
    score?: true;
  };

  export type LeaderboardEntryMinAggregateInputType = {
    id?: true;
    userId?: true;
    huntId?: true;
    rank?: true;
    score?: true;
    completedAt?: true;
  };

  export type LeaderboardEntryMaxAggregateInputType = {
    id?: true;
    userId?: true;
    huntId?: true;
    rank?: true;
    score?: true;
    completedAt?: true;
  };

  export type LeaderboardEntryCountAggregateInputType = {
    id?: true;
    userId?: true;
    huntId?: true;
    rank?: true;
    score?: true;
    completedAt?: true;
    _all?: true;
  };

  export type LeaderboardEntryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LeaderboardEntry to aggregate.
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?:
      | LeaderboardEntryOrderByWithRelationInput
      | LeaderboardEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LeaderboardEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LeaderboardEntries
     **/
    _count?: true | LeaderboardEntryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LeaderboardEntryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LeaderboardEntrySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LeaderboardEntryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LeaderboardEntryMaxAggregateInputType;
  };

  export type GetLeaderboardEntryAggregateType<
    T extends LeaderboardEntryAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateLeaderboardEntry]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
      : GetScalarType<T[P], AggregateLeaderboardEntry[P]>;
  };

  export type LeaderboardEntryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeaderboardEntryWhereInput;
    orderBy?:
      | LeaderboardEntryOrderByWithAggregationInput
      | LeaderboardEntryOrderByWithAggregationInput[];
    by: LeaderboardEntryScalarFieldEnum[] | LeaderboardEntryScalarFieldEnum;
    having?: LeaderboardEntryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LeaderboardEntryCountAggregateInputType | true;
    _avg?: LeaderboardEntryAvgAggregateInputType;
    _sum?: LeaderboardEntrySumAggregateInputType;
    _min?: LeaderboardEntryMinAggregateInputType;
    _max?: LeaderboardEntryMaxAggregateInputType;
  };

  export type LeaderboardEntryGroupByOutputType = {
    id: string;
    userId: string;
    huntId: string;
    rank: number;
    score: number;
    completedAt: Date;
    _count: LeaderboardEntryCountAggregateOutputType | null;
    _avg: LeaderboardEntryAvgAggregateOutputType | null;
    _sum: LeaderboardEntrySumAggregateOutputType | null;
    _min: LeaderboardEntryMinAggregateOutputType | null;
    _max: LeaderboardEntryMaxAggregateOutputType | null;
  };

  type GetLeaderboardEntryGroupByPayload<
    T extends LeaderboardEntryGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardEntryGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof LeaderboardEntryGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
          : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>;
      }
    >
  >;

  export type LeaderboardEntrySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      huntId?: boolean;
      rank?: boolean;
      score?: boolean;
      completedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["leaderboardEntry"]
  >;

  export type LeaderboardEntrySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      huntId?: boolean;
      rank?: boolean;
      score?: boolean;
      completedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["leaderboardEntry"]
  >;

  export type LeaderboardEntrySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      huntId?: boolean;
      rank?: boolean;
      score?: boolean;
      completedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["leaderboardEntry"]
  >;

  export type LeaderboardEntrySelectScalar = {
    id?: boolean;
    userId?: boolean;
    huntId?: boolean;
    rank?: boolean;
    score?: boolean;
    completedAt?: boolean;
  };

  export type LeaderboardEntryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "huntId" | "rank" | "score" | "completedAt",
    ExtArgs["result"]["leaderboardEntry"]
  >;
  export type LeaderboardEntryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type LeaderboardEntryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };
  export type LeaderboardEntryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hunt?: boolean | TreasureHuntDefaultArgs<ExtArgs>;
  };

  export type $LeaderboardEntryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "LeaderboardEntry";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      hunt: Prisma.$TreasureHuntPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        huntId: string;
        rank: number;
        score: number;
        completedAt: Date;
      },
      ExtArgs["result"]["leaderboardEntry"]
    >;
    composites: {};
  };

  type LeaderboardEntryGetPayload<
    S extends boolean | null | undefined | LeaderboardEntryDefaultArgs,
  > = $Result.GetResult<Prisma.$LeaderboardEntryPayload, S>;

  type LeaderboardEntryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    LeaderboardEntryFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: LeaderboardEntryCountAggregateInputType | true;
  };

  export interface LeaderboardEntryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LeaderboardEntry"];
      meta: { name: "LeaderboardEntry" };
    };
    /**
     * Find zero or one LeaderboardEntry that matches the filter.
     * @param {LeaderboardEntryFindUniqueArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardEntryFindUniqueArgs>(
      args: SelectSubset<T, LeaderboardEntryFindUniqueArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LeaderboardEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderboardEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardEntryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LeaderboardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardEntryFindFirstArgs>(
      args?: SelectSubset<T, LeaderboardEntryFindFirstArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LeaderboardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardEntryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LeaderboardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
     *
     * // Get first 10 LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LeaderboardEntryFindManyArgs>(
      args?: SelectSubset<T, LeaderboardEntryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a LeaderboardEntry.
     * @param {LeaderboardEntryCreateArgs} args - Arguments to create a LeaderboardEntry.
     * @example
     * // Create one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.create({
     *   data: {
     *     // ... data to create a LeaderboardEntry
     *   }
     * })
     *
     */
    create<T extends LeaderboardEntryCreateArgs>(
      args: SelectSubset<T, LeaderboardEntryCreateArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LeaderboardEntries.
     * @param {LeaderboardEntryCreateManyArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LeaderboardEntryCreateManyArgs>(
      args?: SelectSubset<T, LeaderboardEntryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LeaderboardEntries and returns the data saved in the database.
     * @param {LeaderboardEntryCreateManyAndReturnArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LeaderboardEntryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a LeaderboardEntry.
     * @param {LeaderboardEntryDeleteArgs} args - Arguments to delete one LeaderboardEntry.
     * @example
     * // Delete one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardEntry
     *   }
     * })
     *
     */
    delete<T extends LeaderboardEntryDeleteArgs>(
      args: SelectSubset<T, LeaderboardEntryDeleteArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LeaderboardEntry.
     * @param {LeaderboardEntryUpdateArgs} args - Arguments to update one LeaderboardEntry.
     * @example
     * // Update one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LeaderboardEntryUpdateArgs>(
      args: SelectSubset<T, LeaderboardEntryUpdateArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LeaderboardEntries.
     * @param {LeaderboardEntryDeleteManyArgs} args - Arguments to filter LeaderboardEntries to delete.
     * @example
     * // Delete a few LeaderboardEntries
     * const { count } = await prisma.leaderboardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LeaderboardEntryDeleteManyArgs>(
      args?: SelectSubset<T, LeaderboardEntryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LeaderboardEntryUpdateManyArgs>(
      args: SelectSubset<T, LeaderboardEntryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LeaderboardEntries and returns the data updated in the database.
     * @param {LeaderboardEntryUpdateManyAndReturnArgs} args - Arguments to update many LeaderboardEntries.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LeaderboardEntryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LeaderboardEntryUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one LeaderboardEntry.
     * @param {LeaderboardEntryUpsertArgs} args - Arguments to update or create a LeaderboardEntry.
     * @example
     * // Update or create a LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.upsert({
     *   create: {
     *     // ... data to create a LeaderboardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardEntry we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardEntryUpsertArgs>(
      args: SelectSubset<T, LeaderboardEntryUpsertArgs<ExtArgs>>,
    ): Prisma__LeaderboardEntryClient<
      $Result.GetResult<
        Prisma.$LeaderboardEntryPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryCountArgs} args - Arguments to filter LeaderboardEntries to count.
     * @example
     * // Count the number of LeaderboardEntries
     * const count = await prisma.leaderboardEntry.count({
     *   where: {
     *     // ... the filter for the LeaderboardEntries we want to count
     *   }
     * })
     **/
    count<T extends LeaderboardEntryCountArgs>(
      args?: Subset<T, LeaderboardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LeaderboardEntryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LeaderboardEntryAggregateArgs>(
      args: Subset<T, LeaderboardEntryAggregateArgs>,
    ): Prisma.PrismaPromise<GetLeaderboardEntryAggregateType<T>>;

    /**
     * Group by LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LeaderboardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardEntryGroupByArgs["orderBy"] }
        : { orderBy?: LeaderboardEntryGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LeaderboardEntryGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetLeaderboardEntryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LeaderboardEntry model
     */
    readonly fields: LeaderboardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardEntryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    hunt<T extends TreasureHuntDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TreasureHuntDefaultArgs<ExtArgs>>,
    ): Prisma__TreasureHuntClient<
      | $Result.GetResult<
          Prisma.$TreasureHuntPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LeaderboardEntry model
   */
  interface LeaderboardEntryFieldRefs {
    readonly id: FieldRef<"LeaderboardEntry", "String">;
    readonly userId: FieldRef<"LeaderboardEntry", "String">;
    readonly huntId: FieldRef<"LeaderboardEntry", "String">;
    readonly rank: FieldRef<"LeaderboardEntry", "Int">;
    readonly score: FieldRef<"LeaderboardEntry", "Int">;
    readonly completedAt: FieldRef<"LeaderboardEntry", "DateTime">;
  }

  // Custom InputTypes
  /**
   * LeaderboardEntry findUnique
   */
  export type LeaderboardEntryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput;
  };

  /**
   * LeaderboardEntry findUniqueOrThrow
   */
  export type LeaderboardEntryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput;
  };

  /**
   * LeaderboardEntry findFirst
   */
  export type LeaderboardEntryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?:
      | LeaderboardEntryOrderByWithRelationInput
      | LeaderboardEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?:
      | LeaderboardEntryScalarFieldEnum
      | LeaderboardEntryScalarFieldEnum[];
  };

  /**
   * LeaderboardEntry findFirstOrThrow
   */
  export type LeaderboardEntryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?:
      | LeaderboardEntryOrderByWithRelationInput
      | LeaderboardEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?:
      | LeaderboardEntryScalarFieldEnum
      | LeaderboardEntryScalarFieldEnum[];
  };

  /**
   * LeaderboardEntry findMany
   */
  export type LeaderboardEntryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * Filter, which LeaderboardEntries to fetch.
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?:
      | LeaderboardEntryOrderByWithRelationInput
      | LeaderboardEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number;
    distinct?:
      | LeaderboardEntryScalarFieldEnum
      | LeaderboardEntryScalarFieldEnum[];
  };

  /**
   * LeaderboardEntry create
   */
  export type LeaderboardEntryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * The data needed to create a LeaderboardEntry.
     */
    data: XOR<
      LeaderboardEntryCreateInput,
      LeaderboardEntryUncheckedCreateInput
    >;
  };

  /**
   * LeaderboardEntry createMany
   */
  export type LeaderboardEntryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LeaderboardEntry createManyAndReturn
   */
  export type LeaderboardEntryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LeaderboardEntry update
   */
  export type LeaderboardEntryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * The data needed to update a LeaderboardEntry.
     */
    data: XOR<
      LeaderboardEntryUpdateInput,
      LeaderboardEntryUncheckedUpdateInput
    >;
    /**
     * Choose, which LeaderboardEntry to update.
     */
    where: LeaderboardEntryWhereUniqueInput;
  };

  /**
   * LeaderboardEntry updateMany
   */
  export type LeaderboardEntryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<
      LeaderboardEntryUpdateManyMutationInput,
      LeaderboardEntryUncheckedUpdateManyInput
    >;
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * Limit how many LeaderboardEntries to update.
     */
    limit?: number;
  };

  /**
   * LeaderboardEntry updateManyAndReturn
   */
  export type LeaderboardEntryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<
      LeaderboardEntryUpdateManyMutationInput,
      LeaderboardEntryUncheckedUpdateManyInput
    >;
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * Limit how many LeaderboardEntries to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LeaderboardEntry upsert
   */
  export type LeaderboardEntryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * The filter to search for the LeaderboardEntry to update in case it exists.
     */
    where: LeaderboardEntryWhereUniqueInput;
    /**
     * In case the LeaderboardEntry found by the `where` argument doesn't exist, create a new LeaderboardEntry with this data.
     */
    create: XOR<
      LeaderboardEntryCreateInput,
      LeaderboardEntryUncheckedCreateInput
    >;
    /**
     * In case the LeaderboardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      LeaderboardEntryUpdateInput,
      LeaderboardEntryUncheckedUpdateInput
    >;
  };

  /**
   * LeaderboardEntry delete
   */
  export type LeaderboardEntryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
    /**
     * Filter which LeaderboardEntry to delete.
     */
    where: LeaderboardEntryWhereUniqueInput;
  };

  /**
   * LeaderboardEntry deleteMany
   */
  export type LeaderboardEntryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LeaderboardEntries to delete
     */
    where?: LeaderboardEntryWhereInput;
    /**
     * Limit how many LeaderboardEntries to delete.
     */
    limit?: number;
  };

  /**
   * LeaderboardEntry without action
   */
  export type LeaderboardEntryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    name: "name";
    email: "email";
    emailVerified: "emailVerified";
    image: "image";
    stripeCustomerId: "stripeCustomerId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    nickname: "nickname";
    role: "role";
    isMfaEnabled: "isMfaEnabled";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: "id";
    expiresAt: "expiresAt";
    token: "token";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    ipAddress: "ipAddress";
    userAgent: "userAgent";
    userId: "userId";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    id: "id";
    accountId: "accountId";
    providerId: "providerId";
    userId: "userId";
    accessToken: "accessToken";
    refreshToken: "refreshToken";
    idToken: "idToken";
    accessTokenExpiresAt: "accessTokenExpiresAt";
    refreshTokenExpiresAt: "refreshTokenExpiresAt";
    scope: "scope";
    password: "password";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const VerificationScalarFieldEnum: {
    id: "id";
    identifier: "identifier";
    value: "value";
    expiresAt: "expiresAt";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type VerificationScalarFieldEnum =
    (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum];

  export const TreasureHuntScalarFieldEnum: {
    id: "id";
    title: "title";
    description: "description";
    createdById: "createdById";
    startDate: "startDate";
    endDate: "endDate";
    location: "location";
    mode: "mode";
    fee: "fee";
    mapStyle: "mapStyle";
    isFinished: "isFinished";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type TreasureHuntScalarFieldEnum =
    (typeof TreasureHuntScalarFieldEnum)[keyof typeof TreasureHuntScalarFieldEnum];

  export const ParticipationScalarFieldEnum: {
    id: "id";
    userId: "userId";
    huntId: "huntId";
    status: "status";
    joinDate: "joinDate";
  };

  export type ParticipationScalarFieldEnum =
    (typeof ParticipationScalarFieldEnum)[keyof typeof ParticipationScalarFieldEnum];

  export const ArtefactScalarFieldEnum: {
    id: "id";
    name: "name";
    rarity: "rarity";
    description: "description";
    imageUrl: "imageUrl";
    isHidden: "isHidden";
    source: "source";
    userId: "userId";
    huntId: "huntId";
    foundAt: "foundAt";
  };

  export type ArtefactScalarFieldEnum =
    (typeof ArtefactScalarFieldEnum)[keyof typeof ArtefactScalarFieldEnum];

  export const HuntStepScalarFieldEnum: {
    id: "id";
    description: "description";
    huntId: "huntId";
    stepOrder: "stepOrder";
    createdAt: "createdAt";
  };

  export type HuntStepScalarFieldEnum =
    (typeof HuntStepScalarFieldEnum)[keyof typeof HuntStepScalarFieldEnum];

  export const RewardScalarFieldEnum: {
    id: "id";
    type: "type";
    value: "value";
    description: "description";
    huntId: "huntId";
  };

  export type RewardScalarFieldEnum =
    (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum];

  export const VirtualCurrencyScalarFieldEnum: {
    id: "id";
    userId: "userId";
    amount: "amount";
    type: "type";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type VirtualCurrencyScalarFieldEnum =
    (typeof VirtualCurrencyScalarFieldEnum)[keyof typeof VirtualCurrencyScalarFieldEnum];

  export const TransactionHistoryScalarFieldEnum: {
    id: "id";
    userId: "userId";
    transactionId: "transactionId";
    stripeSessionId: "stripeSessionId";
    amount: "amount";
    transactionType: "transactionType";
    description: "description";
    createdAt: "createdAt";
    virtualCurrencyId: "virtualCurrencyId";
  };

  export type TransactionHistoryScalarFieldEnum =
    (typeof TransactionHistoryScalarFieldEnum)[keyof typeof TransactionHistoryScalarFieldEnum];

  export const CraftScalarFieldEnum: {
    id: "id";
    userId: "userId";
    resultId: "resultId";
    createdAt: "createdAt";
  };

  export type CraftScalarFieldEnum =
    (typeof CraftScalarFieldEnum)[keyof typeof CraftScalarFieldEnum];

  export const CraftMaterialScalarFieldEnum: {
    id: "id";
    craftId: "craftId";
    artefactId: "artefactId";
  };

  export type CraftMaterialScalarFieldEnum =
    (typeof CraftMaterialScalarFieldEnum)[keyof typeof CraftMaterialScalarFieldEnum];

  export const LeaderboardEntryScalarFieldEnum: {
    id: "id";
    userId: "userId";
    huntId: "huntId";
    rank: "rank";
    score: "score";
    completedAt: "completedAt";
  };

  export type LeaderboardEntryScalarFieldEnum =
    (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UserRole"
  >;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UserRole[]"
  >;

  /**
   * Reference to a field of type 'HuntMode'
   */
  export type EnumHuntModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "HuntMode"
  >;

  /**
   * Reference to a field of type 'HuntMode[]'
   */
  export type ListEnumHuntModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "HuntMode[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'HuntStatus'
   */
  export type EnumHuntStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "HuntStatus"
  >;

  /**
   * Reference to a field of type 'HuntStatus[]'
   */
  export type ListEnumHuntStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "HuntStatus[]"
  >;

  /**
   * Reference to a field of type 'ParticipationStatus'
   */
  export type EnumParticipationStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ParticipationStatus">;

  /**
   * Reference to a field of type 'ParticipationStatus[]'
   */
  export type ListEnumParticipationStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ParticipationStatus[]">;

  /**
   * Reference to a field of type 'ArtefactRarity'
   */
  export type EnumArtefactRarityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ArtefactRarity"
  >;

  /**
   * Reference to a field of type 'ArtefactRarity[]'
   */
  export type ListEnumArtefactRarityFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ArtefactRarity[]">;

  /**
   * Reference to a field of type 'ArtefactSource'
   */
  export type EnumArtefactSourceFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ArtefactSource"
  >;

  /**
   * Reference to a field of type 'ArtefactSource[]'
   */
  export type ListEnumArtefactSourceFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ArtefactSource[]">;

  /**
   * Reference to a field of type 'RewardType'
   */
  export type EnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "RewardType"
  >;

  /**
   * Reference to a field of type 'RewardType[]'
   */
  export type ListEnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "RewardType[]"
  >;

  /**
   * Reference to a field of type 'CurrencySourceType'
   */
  export type EnumCurrencySourceTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "CurrencySourceType">;

  /**
   * Reference to a field of type 'CurrencySourceType[]'
   */
  export type ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "CurrencySourceType[]">;

  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "TransactionType">;

  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "TransactionType[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    email?: StringFilter<"User"> | string;
    emailVerified?: BoolFilter<"User"> | boolean;
    image?: StringNullableFilter<"User"> | string | null;
    stripeCustomerId?: StringNullableFilter<"User"> | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    nickname?: StringNullableFilter<"User"> | string | null;
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole;
    isMfaEnabled?: BoolFilter<"User"> | boolean;
    sessions?: SessionListRelationFilter;
    accounts?: AccountListRelationFilter;
    participations?: ParticipationListRelationFilter;
    createdChasses?: TreasureHuntListRelationFilter;
    collectedArtefacts?: ArtefactListRelationFilter;
    virtualCurrency?: VirtualCurrencyListRelationFilter;
    transactionHistory?: TransactionHistoryListRelationFilter;
    Craft?: CraftListRelationFilter;
    LeaderboardEntry?: LeaderboardEntryListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrderInput | SortOrder;
    stripeCustomerId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    nickname?: SortOrderInput | SortOrder;
    role?: SortOrder;
    isMfaEnabled?: SortOrder;
    sessions?: SessionOrderByRelationAggregateInput;
    accounts?: AccountOrderByRelationAggregateInput;
    participations?: ParticipationOrderByRelationAggregateInput;
    createdChasses?: TreasureHuntOrderByRelationAggregateInput;
    collectedArtefacts?: ArtefactOrderByRelationAggregateInput;
    virtualCurrency?: VirtualCurrencyOrderByRelationAggregateInput;
    transactionHistory?: TransactionHistoryOrderByRelationAggregateInput;
    Craft?: CraftOrderByRelationAggregateInput;
    LeaderboardEntry?: LeaderboardEntryOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<"User"> | string | null;
      emailVerified?: BoolFilter<"User"> | boolean;
      image?: StringNullableFilter<"User"> | string | null;
      stripeCustomerId?: StringNullableFilter<"User"> | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      nickname?: StringNullableFilter<"User"> | string | null;
      role?: EnumUserRoleFilter<"User"> | $Enums.UserRole;
      isMfaEnabled?: BoolFilter<"User"> | boolean;
      sessions?: SessionListRelationFilter;
      accounts?: AccountListRelationFilter;
      participations?: ParticipationListRelationFilter;
      createdChasses?: TreasureHuntListRelationFilter;
      collectedArtefacts?: ArtefactListRelationFilter;
      virtualCurrency?: VirtualCurrencyListRelationFilter;
      transactionHistory?: TransactionHistoryListRelationFilter;
      Craft?: CraftListRelationFilter;
      LeaderboardEntry?: LeaderboardEntryListRelationFilter;
    },
    "id" | "email"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrderInput | SortOrder;
    stripeCustomerId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    nickname?: SortOrderInput | SortOrder;
    role?: SortOrder;
    isMfaEnabled?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    email?: StringWithAggregatesFilter<"User"> | string;
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean;
    image?: StringNullableWithAggregatesFilter<"User"> | string | null;
    stripeCustomerId?:
      | StringNullableWithAggregatesFilter<"User">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    nickname?: StringNullableWithAggregatesFilter<"User"> | string | null;
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole;
    isMfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<"Session"> | string;
    expiresAt?: DateTimeFilter<"Session"> | Date | string;
    token?: StringFilter<"Session"> | string;
    createdAt?: DateTimeFilter<"Session"> | Date | string;
    updatedAt?: DateTimeFilter<"Session"> | Date | string;
    ipAddress?: StringNullableFilter<"Session"> | string | null;
    userAgent?: StringNullableFilter<"Session"> | string | null;
    userId?: StringFilter<"Session"> | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      expiresAt?: DateTimeFilter<"Session"> | Date | string;
      createdAt?: DateTimeFilter<"Session"> | Date | string;
      updatedAt?: DateTimeFilter<"Session"> | Date | string;
      ipAddress?: StringNullableFilter<"Session"> | string | null;
      userAgent?: StringNullableFilter<"Session"> | string | null;
      userId?: StringFilter<"Session"> | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "token"
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Session"> | string;
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    token?: StringWithAggregatesFilter<"Session"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null;
    userId?: StringWithAggregatesFilter<"Session"> | string;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<"Account"> | string;
    accountId?: StringFilter<"Account"> | string;
    providerId?: StringFilter<"Account"> | string;
    userId?: StringFilter<"Account"> | string;
    accessToken?: StringNullableFilter<"Account"> | string | null;
    refreshToken?: StringNullableFilter<"Account"> | string | null;
    idToken?: StringNullableFilter<"Account"> | string | null;
    accessTokenExpiresAt?:
      | DateTimeNullableFilter<"Account">
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | DateTimeNullableFilter<"Account">
      | Date
      | string
      | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    password?: StringNullableFilter<"Account"> | string | null;
    createdAt?: DateTimeFilter<"Account"> | Date | string;
    updatedAt?: DateTimeFilter<"Account"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrderInput | SortOrder;
    refreshToken?: SortOrderInput | SortOrder;
    idToken?: SortOrderInput | SortOrder;
    accessTokenExpiresAt?: SortOrderInput | SortOrder;
    refreshTokenExpiresAt?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      accountId?: StringFilter<"Account"> | string;
      providerId?: StringFilter<"Account"> | string;
      userId?: StringFilter<"Account"> | string;
      accessToken?: StringNullableFilter<"Account"> | string | null;
      refreshToken?: StringNullableFilter<"Account"> | string | null;
      idToken?: StringNullableFilter<"Account"> | string | null;
      accessTokenExpiresAt?:
        | DateTimeNullableFilter<"Account">
        | Date
        | string
        | null;
      refreshTokenExpiresAt?:
        | DateTimeNullableFilter<"Account">
        | Date
        | string
        | null;
      scope?: StringNullableFilter<"Account"> | string | null;
      password?: StringNullableFilter<"Account"> | string | null;
      createdAt?: DateTimeFilter<"Account"> | Date | string;
      updatedAt?: DateTimeFilter<"Account"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrderInput | SortOrder;
    refreshToken?: SortOrderInput | SortOrder;
    idToken?: SortOrderInput | SortOrder;
    accessTokenExpiresAt?: SortOrderInput | SortOrder;
    refreshTokenExpiresAt?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Account"> | string;
    accountId?: StringWithAggregatesFilter<"Account"> | string;
    providerId?: StringWithAggregatesFilter<"Account"> | string;
    userId?: StringWithAggregatesFilter<"Account"> | string;
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    refreshToken?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    accessTokenExpiresAt?:
      | DateTimeNullableWithAggregatesFilter<"Account">
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | DateTimeNullableWithAggregatesFilter<"Account">
      | Date
      | string
      | null;
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string;
  };

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[];
    OR?: VerificationWhereInput[];
    NOT?: VerificationWhereInput | VerificationWhereInput[];
    id?: StringFilter<"Verification"> | string;
    identifier?: StringFilter<"Verification"> | string;
    value?: StringFilter<"Verification"> | string;
    expiresAt?: DateTimeFilter<"Verification"> | Date | string;
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null;
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null;
  };

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrderInput | SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
  };

  export type VerificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: VerificationWhereInput | VerificationWhereInput[];
      OR?: VerificationWhereInput[];
      NOT?: VerificationWhereInput | VerificationWhereInput[];
      identifier?: StringFilter<"Verification"> | string;
      value?: StringFilter<"Verification"> | string;
      expiresAt?: DateTimeFilter<"Verification"> | Date | string;
      createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null;
      updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null;
    },
    "id"
  >;

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrderInput | SortOrder;
    updatedAt?: SortOrderInput | SortOrder;
    _count?: VerificationCountOrderByAggregateInput;
    _max?: VerificationMaxOrderByAggregateInput;
    _min?: VerificationMinOrderByAggregateInput;
  };

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationScalarWhereWithAggregatesInput
      | VerificationScalarWhereWithAggregatesInput[];
    OR?: VerificationScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationScalarWhereWithAggregatesInput
      | VerificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Verification"> | string;
    identifier?: StringWithAggregatesFilter<"Verification"> | string;
    value?: StringWithAggregatesFilter<"Verification"> | string;
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string;
    createdAt?:
      | DateTimeNullableWithAggregatesFilter<"Verification">
      | Date
      | string
      | null;
    updatedAt?:
      | DateTimeNullableWithAggregatesFilter<"Verification">
      | Date
      | string
      | null;
  };

  export type TreasureHuntWhereInput = {
    AND?: TreasureHuntWhereInput | TreasureHuntWhereInput[];
    OR?: TreasureHuntWhereInput[];
    NOT?: TreasureHuntWhereInput | TreasureHuntWhereInput[];
    id?: StringFilter<"TreasureHunt"> | string;
    title?: StringFilter<"TreasureHunt"> | string;
    description?: StringNullableFilter<"TreasureHunt"> | string | null;
    createdById?: StringFilter<"TreasureHunt"> | string;
    startDate?: DateTimeNullableFilter<"TreasureHunt"> | Date | string | null;
    endDate?: DateTimeNullableFilter<"TreasureHunt"> | Date | string | null;
    location?: StringNullableFilter<"TreasureHunt"> | string | null;
    mode?: EnumHuntModeFilter<"TreasureHunt"> | $Enums.HuntMode;
    fee?: IntNullableFilter<"TreasureHunt"> | number | null;
    mapStyle?: StringNullableFilter<"TreasureHunt"> | string | null;
    isFinished?: BoolFilter<"TreasureHunt"> | boolean;
    status?: EnumHuntStatusFilter<"TreasureHunt"> | $Enums.HuntStatus;
    createdAt?: DateTimeFilter<"TreasureHunt"> | Date | string;
    updatedAt?: DateTimeFilter<"TreasureHunt"> | Date | string;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    participants?: ParticipationListRelationFilter;
    steps?: HuntStepListRelationFilter;
    rewards?: RewardListRelationFilter;
    artefacts?: ArtefactListRelationFilter;
    LeaderboardEntry?: LeaderboardEntryListRelationFilter;
  };

  export type TreasureHuntOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdById?: SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    location?: SortOrderInput | SortOrder;
    mode?: SortOrder;
    fee?: SortOrderInput | SortOrder;
    mapStyle?: SortOrderInput | SortOrder;
    isFinished?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: UserOrderByWithRelationInput;
    participants?: ParticipationOrderByRelationAggregateInput;
    steps?: HuntStepOrderByRelationAggregateInput;
    rewards?: RewardOrderByRelationAggregateInput;
    artefacts?: ArtefactOrderByRelationAggregateInput;
    LeaderboardEntry?: LeaderboardEntryOrderByRelationAggregateInput;
  };

  export type TreasureHuntWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TreasureHuntWhereInput | TreasureHuntWhereInput[];
      OR?: TreasureHuntWhereInput[];
      NOT?: TreasureHuntWhereInput | TreasureHuntWhereInput[];
      title?: StringFilter<"TreasureHunt"> | string;
      description?: StringNullableFilter<"TreasureHunt"> | string | null;
      createdById?: StringFilter<"TreasureHunt"> | string;
      startDate?: DateTimeNullableFilter<"TreasureHunt"> | Date | string | null;
      endDate?: DateTimeNullableFilter<"TreasureHunt"> | Date | string | null;
      location?: StringNullableFilter<"TreasureHunt"> | string | null;
      mode?: EnumHuntModeFilter<"TreasureHunt"> | $Enums.HuntMode;
      fee?: IntNullableFilter<"TreasureHunt"> | number | null;
      mapStyle?: StringNullableFilter<"TreasureHunt"> | string | null;
      isFinished?: BoolFilter<"TreasureHunt"> | boolean;
      status?: EnumHuntStatusFilter<"TreasureHunt"> | $Enums.HuntStatus;
      createdAt?: DateTimeFilter<"TreasureHunt"> | Date | string;
      updatedAt?: DateTimeFilter<"TreasureHunt"> | Date | string;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      participants?: ParticipationListRelationFilter;
      steps?: HuntStepListRelationFilter;
      rewards?: RewardListRelationFilter;
      artefacts?: ArtefactListRelationFilter;
      LeaderboardEntry?: LeaderboardEntryListRelationFilter;
    },
    "id"
  >;

  export type TreasureHuntOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdById?: SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    location?: SortOrderInput | SortOrder;
    mode?: SortOrder;
    fee?: SortOrderInput | SortOrder;
    mapStyle?: SortOrderInput | SortOrder;
    isFinished?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TreasureHuntCountOrderByAggregateInput;
    _avg?: TreasureHuntAvgOrderByAggregateInput;
    _max?: TreasureHuntMaxOrderByAggregateInput;
    _min?: TreasureHuntMinOrderByAggregateInput;
    _sum?: TreasureHuntSumOrderByAggregateInput;
  };

  export type TreasureHuntScalarWhereWithAggregatesInput = {
    AND?:
      | TreasureHuntScalarWhereWithAggregatesInput
      | TreasureHuntScalarWhereWithAggregatesInput[];
    OR?: TreasureHuntScalarWhereWithAggregatesInput[];
    NOT?:
      | TreasureHuntScalarWhereWithAggregatesInput
      | TreasureHuntScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TreasureHunt"> | string;
    title?: StringWithAggregatesFilter<"TreasureHunt"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"TreasureHunt">
      | string
      | null;
    createdById?: StringWithAggregatesFilter<"TreasureHunt"> | string;
    startDate?:
      | DateTimeNullableWithAggregatesFilter<"TreasureHunt">
      | Date
      | string
      | null;
    endDate?:
      | DateTimeNullableWithAggregatesFilter<"TreasureHunt">
      | Date
      | string
      | null;
    location?:
      | StringNullableWithAggregatesFilter<"TreasureHunt">
      | string
      | null;
    mode?: EnumHuntModeWithAggregatesFilter<"TreasureHunt"> | $Enums.HuntMode;
    fee?: IntNullableWithAggregatesFilter<"TreasureHunt"> | number | null;
    mapStyle?:
      | StringNullableWithAggregatesFilter<"TreasureHunt">
      | string
      | null;
    isFinished?: BoolWithAggregatesFilter<"TreasureHunt"> | boolean;
    status?:
      | EnumHuntStatusWithAggregatesFilter<"TreasureHunt">
      | $Enums.HuntStatus;
    createdAt?: DateTimeWithAggregatesFilter<"TreasureHunt"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"TreasureHunt"> | Date | string;
  };

  export type ParticipationWhereInput = {
    AND?: ParticipationWhereInput | ParticipationWhereInput[];
    OR?: ParticipationWhereInput[];
    NOT?: ParticipationWhereInput | ParticipationWhereInput[];
    id?: StringFilter<"Participation"> | string;
    userId?: StringFilter<"Participation"> | string;
    huntId?: StringFilter<"Participation"> | string;
    status?:
      | EnumParticipationStatusFilter<"Participation">
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFilter<"Participation"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    treasureHunt?: XOR<
      TreasureHuntScalarRelationFilter,
      TreasureHuntWhereInput
    >;
  };

  export type ParticipationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    status?: SortOrder;
    joinDate?: SortOrder;
    user?: UserOrderByWithRelationInput;
    treasureHunt?: TreasureHuntOrderByWithRelationInput;
  };

  export type ParticipationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ParticipationWhereInput | ParticipationWhereInput[];
      OR?: ParticipationWhereInput[];
      NOT?: ParticipationWhereInput | ParticipationWhereInput[];
      userId?: StringFilter<"Participation"> | string;
      huntId?: StringFilter<"Participation"> | string;
      status?:
        | EnumParticipationStatusFilter<"Participation">
        | $Enums.ParticipationStatus;
      joinDate?: DateTimeFilter<"Participation"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      treasureHunt?: XOR<
        TreasureHuntScalarRelationFilter,
        TreasureHuntWhereInput
      >;
    },
    "id"
  >;

  export type ParticipationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    status?: SortOrder;
    joinDate?: SortOrder;
    _count?: ParticipationCountOrderByAggregateInput;
    _max?: ParticipationMaxOrderByAggregateInput;
    _min?: ParticipationMinOrderByAggregateInput;
  };

  export type ParticipationScalarWhereWithAggregatesInput = {
    AND?:
      | ParticipationScalarWhereWithAggregatesInput
      | ParticipationScalarWhereWithAggregatesInput[];
    OR?: ParticipationScalarWhereWithAggregatesInput[];
    NOT?:
      | ParticipationScalarWhereWithAggregatesInput
      | ParticipationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Participation"> | string;
    userId?: StringWithAggregatesFilter<"Participation"> | string;
    huntId?: StringWithAggregatesFilter<"Participation"> | string;
    status?:
      | EnumParticipationStatusWithAggregatesFilter<"Participation">
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeWithAggregatesFilter<"Participation"> | Date | string;
  };

  export type ArtefactWhereInput = {
    AND?: ArtefactWhereInput | ArtefactWhereInput[];
    OR?: ArtefactWhereInput[];
    NOT?: ArtefactWhereInput | ArtefactWhereInput[];
    id?: StringFilter<"Artefact"> | string;
    name?: StringFilter<"Artefact"> | string;
    rarity?: EnumArtefactRarityFilter<"Artefact"> | $Enums.ArtefactRarity;
    description?: StringNullableFilter<"Artefact"> | string | null;
    imageUrl?: StringNullableFilter<"Artefact"> | string | null;
    isHidden?: BoolFilter<"Artefact"> | boolean;
    source?: EnumArtefactSourceFilter<"Artefact"> | $Enums.ArtefactSource;
    userId?: StringFilter<"Artefact"> | string;
    huntId?: StringNullableFilter<"Artefact"> | string | null;
    foundAt?: DateTimeFilter<"Artefact"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    hunt?: XOR<
      TreasureHuntNullableScalarRelationFilter,
      TreasureHuntWhereInput
    > | null;
    Craft?: CraftListRelationFilter;
    CraftMaterial?: CraftMaterialListRelationFilter;
  };

  export type ArtefactOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    rarity?: SortOrder;
    description?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    isHidden?: SortOrder;
    source?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrderInput | SortOrder;
    foundAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    hunt?: TreasureHuntOrderByWithRelationInput;
    Craft?: CraftOrderByRelationAggregateInput;
    CraftMaterial?: CraftMaterialOrderByRelationAggregateInput;
  };

  export type ArtefactWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ArtefactWhereInput | ArtefactWhereInput[];
      OR?: ArtefactWhereInput[];
      NOT?: ArtefactWhereInput | ArtefactWhereInput[];
      name?: StringFilter<"Artefact"> | string;
      rarity?: EnumArtefactRarityFilter<"Artefact"> | $Enums.ArtefactRarity;
      description?: StringNullableFilter<"Artefact"> | string | null;
      imageUrl?: StringNullableFilter<"Artefact"> | string | null;
      isHidden?: BoolFilter<"Artefact"> | boolean;
      source?: EnumArtefactSourceFilter<"Artefact"> | $Enums.ArtefactSource;
      userId?: StringFilter<"Artefact"> | string;
      huntId?: StringNullableFilter<"Artefact"> | string | null;
      foundAt?: DateTimeFilter<"Artefact"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      hunt?: XOR<
        TreasureHuntNullableScalarRelationFilter,
        TreasureHuntWhereInput
      > | null;
      Craft?: CraftListRelationFilter;
      CraftMaterial?: CraftMaterialListRelationFilter;
    },
    "id"
  >;

  export type ArtefactOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    rarity?: SortOrder;
    description?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    isHidden?: SortOrder;
    source?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrderInput | SortOrder;
    foundAt?: SortOrder;
    _count?: ArtefactCountOrderByAggregateInput;
    _max?: ArtefactMaxOrderByAggregateInput;
    _min?: ArtefactMinOrderByAggregateInput;
  };

  export type ArtefactScalarWhereWithAggregatesInput = {
    AND?:
      | ArtefactScalarWhereWithAggregatesInput
      | ArtefactScalarWhereWithAggregatesInput[];
    OR?: ArtefactScalarWhereWithAggregatesInput[];
    NOT?:
      | ArtefactScalarWhereWithAggregatesInput
      | ArtefactScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Artefact"> | string;
    name?: StringWithAggregatesFilter<"Artefact"> | string;
    rarity?:
      | EnumArtefactRarityWithAggregatesFilter<"Artefact">
      | $Enums.ArtefactRarity;
    description?:
      | StringNullableWithAggregatesFilter<"Artefact">
      | string
      | null;
    imageUrl?: StringNullableWithAggregatesFilter<"Artefact"> | string | null;
    isHidden?: BoolWithAggregatesFilter<"Artefact"> | boolean;
    source?:
      | EnumArtefactSourceWithAggregatesFilter<"Artefact">
      | $Enums.ArtefactSource;
    userId?: StringWithAggregatesFilter<"Artefact"> | string;
    huntId?: StringNullableWithAggregatesFilter<"Artefact"> | string | null;
    foundAt?: DateTimeWithAggregatesFilter<"Artefact"> | Date | string;
  };

  export type HuntStepWhereInput = {
    AND?: HuntStepWhereInput | HuntStepWhereInput[];
    OR?: HuntStepWhereInput[];
    NOT?: HuntStepWhereInput | HuntStepWhereInput[];
    id?: StringFilter<"HuntStep"> | string;
    description?: StringFilter<"HuntStep"> | string;
    huntId?: StringFilter<"HuntStep"> | string;
    stepOrder?: IntFilter<"HuntStep"> | number;
    createdAt?: DateTimeFilter<"HuntStep"> | Date | string;
    treasureHunt?: XOR<
      TreasureHuntScalarRelationFilter,
      TreasureHuntWhereInput
    >;
  };

  export type HuntStepOrderByWithRelationInput = {
    id?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
    stepOrder?: SortOrder;
    createdAt?: SortOrder;
    treasureHunt?: TreasureHuntOrderByWithRelationInput;
  };

  export type HuntStepWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: HuntStepWhereInput | HuntStepWhereInput[];
      OR?: HuntStepWhereInput[];
      NOT?: HuntStepWhereInput | HuntStepWhereInput[];
      description?: StringFilter<"HuntStep"> | string;
      huntId?: StringFilter<"HuntStep"> | string;
      stepOrder?: IntFilter<"HuntStep"> | number;
      createdAt?: DateTimeFilter<"HuntStep"> | Date | string;
      treasureHunt?: XOR<
        TreasureHuntScalarRelationFilter,
        TreasureHuntWhereInput
      >;
    },
    "id"
  >;

  export type HuntStepOrderByWithAggregationInput = {
    id?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
    stepOrder?: SortOrder;
    createdAt?: SortOrder;
    _count?: HuntStepCountOrderByAggregateInput;
    _avg?: HuntStepAvgOrderByAggregateInput;
    _max?: HuntStepMaxOrderByAggregateInput;
    _min?: HuntStepMinOrderByAggregateInput;
    _sum?: HuntStepSumOrderByAggregateInput;
  };

  export type HuntStepScalarWhereWithAggregatesInput = {
    AND?:
      | HuntStepScalarWhereWithAggregatesInput
      | HuntStepScalarWhereWithAggregatesInput[];
    OR?: HuntStepScalarWhereWithAggregatesInput[];
    NOT?:
      | HuntStepScalarWhereWithAggregatesInput
      | HuntStepScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"HuntStep"> | string;
    description?: StringWithAggregatesFilter<"HuntStep"> | string;
    huntId?: StringWithAggregatesFilter<"HuntStep"> | string;
    stepOrder?: IntWithAggregatesFilter<"HuntStep"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"HuntStep"> | Date | string;
  };

  export type RewardWhereInput = {
    AND?: RewardWhereInput | RewardWhereInput[];
    OR?: RewardWhereInput[];
    NOT?: RewardWhereInput | RewardWhereInput[];
    id?: StringFilter<"Reward"> | string;
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType;
    value?: IntFilter<"Reward"> | number;
    description?: StringNullableFilter<"Reward"> | string | null;
    huntId?: StringFilter<"Reward"> | string;
    treasureHunt?: XOR<
      TreasureHuntScalarRelationFilter,
      TreasureHuntWhereInput
    >;
  };

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    description?: SortOrderInput | SortOrder;
    huntId?: SortOrder;
    treasureHunt?: TreasureHuntOrderByWithRelationInput;
  };

  export type RewardWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: RewardWhereInput | RewardWhereInput[];
      OR?: RewardWhereInput[];
      NOT?: RewardWhereInput | RewardWhereInput[];
      type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType;
      value?: IntFilter<"Reward"> | number;
      description?: StringNullableFilter<"Reward"> | string | null;
      huntId?: StringFilter<"Reward"> | string;
      treasureHunt?: XOR<
        TreasureHuntScalarRelationFilter,
        TreasureHuntWhereInput
      >;
    },
    "id"
  >;

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    description?: SortOrderInput | SortOrder;
    huntId?: SortOrder;
    _count?: RewardCountOrderByAggregateInput;
    _avg?: RewardAvgOrderByAggregateInput;
    _max?: RewardMaxOrderByAggregateInput;
    _min?: RewardMinOrderByAggregateInput;
    _sum?: RewardSumOrderByAggregateInput;
  };

  export type RewardScalarWhereWithAggregatesInput = {
    AND?:
      | RewardScalarWhereWithAggregatesInput
      | RewardScalarWhereWithAggregatesInput[];
    OR?: RewardScalarWhereWithAggregatesInput[];
    NOT?:
      | RewardScalarWhereWithAggregatesInput
      | RewardScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Reward"> | string;
    type?: EnumRewardTypeWithAggregatesFilter<"Reward"> | $Enums.RewardType;
    value?: IntWithAggregatesFilter<"Reward"> | number;
    description?: StringNullableWithAggregatesFilter<"Reward"> | string | null;
    huntId?: StringWithAggregatesFilter<"Reward"> | string;
  };

  export type VirtualCurrencyWhereInput = {
    AND?: VirtualCurrencyWhereInput | VirtualCurrencyWhereInput[];
    OR?: VirtualCurrencyWhereInput[];
    NOT?: VirtualCurrencyWhereInput | VirtualCurrencyWhereInput[];
    id?: StringFilter<"VirtualCurrency"> | string;
    userId?: StringFilter<"VirtualCurrency"> | string;
    amount?: IntFilter<"VirtualCurrency"> | number;
    type?:
      | EnumCurrencySourceTypeFilter<"VirtualCurrency">
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFilter<"VirtualCurrency"> | Date | string;
    updatedAt?: DateTimeFilter<"VirtualCurrency"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    transactionHistory?: TransactionHistoryListRelationFilter;
  };

  export type VirtualCurrencyOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    transactionHistory?: TransactionHistoryOrderByRelationAggregateInput;
  };

  export type VirtualCurrencyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: VirtualCurrencyWhereInput | VirtualCurrencyWhereInput[];
      OR?: VirtualCurrencyWhereInput[];
      NOT?: VirtualCurrencyWhereInput | VirtualCurrencyWhereInput[];
      userId?: StringFilter<"VirtualCurrency"> | string;
      amount?: IntFilter<"VirtualCurrency"> | number;
      type?:
        | EnumCurrencySourceTypeFilter<"VirtualCurrency">
        | $Enums.CurrencySourceType;
      createdAt?: DateTimeFilter<"VirtualCurrency"> | Date | string;
      updatedAt?: DateTimeFilter<"VirtualCurrency"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      transactionHistory?: TransactionHistoryListRelationFilter;
    },
    "id"
  >;

  export type VirtualCurrencyOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: VirtualCurrencyCountOrderByAggregateInput;
    _avg?: VirtualCurrencyAvgOrderByAggregateInput;
    _max?: VirtualCurrencyMaxOrderByAggregateInput;
    _min?: VirtualCurrencyMinOrderByAggregateInput;
    _sum?: VirtualCurrencySumOrderByAggregateInput;
  };

  export type VirtualCurrencyScalarWhereWithAggregatesInput = {
    AND?:
      | VirtualCurrencyScalarWhereWithAggregatesInput
      | VirtualCurrencyScalarWhereWithAggregatesInput[];
    OR?: VirtualCurrencyScalarWhereWithAggregatesInput[];
    NOT?:
      | VirtualCurrencyScalarWhereWithAggregatesInput
      | VirtualCurrencyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"VirtualCurrency"> | string;
    userId?: StringWithAggregatesFilter<"VirtualCurrency"> | string;
    amount?: IntWithAggregatesFilter<"VirtualCurrency"> | number;
    type?:
      | EnumCurrencySourceTypeWithAggregatesFilter<"VirtualCurrency">
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeWithAggregatesFilter<"VirtualCurrency"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"VirtualCurrency"> | Date | string;
  };

  export type TransactionHistoryWhereInput = {
    AND?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[];
    OR?: TransactionHistoryWhereInput[];
    NOT?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[];
    id?: StringFilter<"TransactionHistory"> | string;
    userId?: StringFilter<"TransactionHistory"> | string;
    transactionId?: StringFilter<"TransactionHistory"> | string;
    stripeSessionId?:
      | StringNullableFilter<"TransactionHistory">
      | string
      | null;
    amount?: IntFilter<"TransactionHistory"> | number;
    transactionType?:
      | EnumTransactionTypeFilter<"TransactionHistory">
      | $Enums.TransactionType;
    description?: StringNullableFilter<"TransactionHistory"> | string | null;
    createdAt?: DateTimeFilter<"TransactionHistory"> | Date | string;
    virtualCurrencyId?: StringFilter<"TransactionHistory"> | string;
    virtualCurrency?: XOR<
      VirtualCurrencyScalarRelationFilter,
      VirtualCurrencyWhereInput
    >;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TransactionHistoryOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    transactionId?: SortOrder;
    stripeSessionId?: SortOrderInput | SortOrder;
    amount?: SortOrder;
    transactionType?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    virtualCurrencyId?: SortOrder;
    virtualCurrency?: VirtualCurrencyOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type TransactionHistoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      stripeSessionId?: string;
      AND?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[];
      OR?: TransactionHistoryWhereInput[];
      NOT?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[];
      userId?: StringFilter<"TransactionHistory"> | string;
      transactionId?: StringFilter<"TransactionHistory"> | string;
      amount?: IntFilter<"TransactionHistory"> | number;
      transactionType?:
        | EnumTransactionTypeFilter<"TransactionHistory">
        | $Enums.TransactionType;
      description?: StringNullableFilter<"TransactionHistory"> | string | null;
      createdAt?: DateTimeFilter<"TransactionHistory"> | Date | string;
      virtualCurrencyId?: StringFilter<"TransactionHistory"> | string;
      virtualCurrency?: XOR<
        VirtualCurrencyScalarRelationFilter,
        VirtualCurrencyWhereInput
      >;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "stripeSessionId"
  >;

  export type TransactionHistoryOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    transactionId?: SortOrder;
    stripeSessionId?: SortOrderInput | SortOrder;
    amount?: SortOrder;
    transactionType?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    virtualCurrencyId?: SortOrder;
    _count?: TransactionHistoryCountOrderByAggregateInput;
    _avg?: TransactionHistoryAvgOrderByAggregateInput;
    _max?: TransactionHistoryMaxOrderByAggregateInput;
    _min?: TransactionHistoryMinOrderByAggregateInput;
    _sum?: TransactionHistorySumOrderByAggregateInput;
  };

  export type TransactionHistoryScalarWhereWithAggregatesInput = {
    AND?:
      | TransactionHistoryScalarWhereWithAggregatesInput
      | TransactionHistoryScalarWhereWithAggregatesInput[];
    OR?: TransactionHistoryScalarWhereWithAggregatesInput[];
    NOT?:
      | TransactionHistoryScalarWhereWithAggregatesInput
      | TransactionHistoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TransactionHistory"> | string;
    userId?: StringWithAggregatesFilter<"TransactionHistory"> | string;
    transactionId?: StringWithAggregatesFilter<"TransactionHistory"> | string;
    stripeSessionId?:
      | StringNullableWithAggregatesFilter<"TransactionHistory">
      | string
      | null;
    amount?: IntWithAggregatesFilter<"TransactionHistory"> | number;
    transactionType?:
      | EnumTransactionTypeWithAggregatesFilter<"TransactionHistory">
      | $Enums.TransactionType;
    description?:
      | StringNullableWithAggregatesFilter<"TransactionHistory">
      | string
      | null;
    createdAt?:
      | DateTimeWithAggregatesFilter<"TransactionHistory">
      | Date
      | string;
    virtualCurrencyId?:
      | StringWithAggregatesFilter<"TransactionHistory">
      | string;
  };

  export type CraftWhereInput = {
    AND?: CraftWhereInput | CraftWhereInput[];
    OR?: CraftWhereInput[];
    NOT?: CraftWhereInput | CraftWhereInput[];
    id?: StringFilter<"Craft"> | string;
    userId?: StringFilter<"Craft"> | string;
    resultId?: StringFilter<"Craft"> | string;
    createdAt?: DateTimeFilter<"Craft"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    result?: XOR<ArtefactScalarRelationFilter, ArtefactWhereInput>;
    materials?: CraftMaterialListRelationFilter;
  };

  export type CraftOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    resultId?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    result?: ArtefactOrderByWithRelationInput;
    materials?: CraftMaterialOrderByRelationAggregateInput;
  };

  export type CraftWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CraftWhereInput | CraftWhereInput[];
      OR?: CraftWhereInput[];
      NOT?: CraftWhereInput | CraftWhereInput[];
      userId?: StringFilter<"Craft"> | string;
      resultId?: StringFilter<"Craft"> | string;
      createdAt?: DateTimeFilter<"Craft"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      result?: XOR<ArtefactScalarRelationFilter, ArtefactWhereInput>;
      materials?: CraftMaterialListRelationFilter;
    },
    "id"
  >;

  export type CraftOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    resultId?: SortOrder;
    createdAt?: SortOrder;
    _count?: CraftCountOrderByAggregateInput;
    _max?: CraftMaxOrderByAggregateInput;
    _min?: CraftMinOrderByAggregateInput;
  };

  export type CraftScalarWhereWithAggregatesInput = {
    AND?:
      | CraftScalarWhereWithAggregatesInput
      | CraftScalarWhereWithAggregatesInput[];
    OR?: CraftScalarWhereWithAggregatesInput[];
    NOT?:
      | CraftScalarWhereWithAggregatesInput
      | CraftScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Craft"> | string;
    userId?: StringWithAggregatesFilter<"Craft"> | string;
    resultId?: StringWithAggregatesFilter<"Craft"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Craft"> | Date | string;
  };

  export type CraftMaterialWhereInput = {
    AND?: CraftMaterialWhereInput | CraftMaterialWhereInput[];
    OR?: CraftMaterialWhereInput[];
    NOT?: CraftMaterialWhereInput | CraftMaterialWhereInput[];
    id?: StringFilter<"CraftMaterial"> | string;
    craftId?: StringFilter<"CraftMaterial"> | string;
    artefactId?: StringFilter<"CraftMaterial"> | string;
    craft?: XOR<CraftScalarRelationFilter, CraftWhereInput>;
    artefact?: XOR<ArtefactScalarRelationFilter, ArtefactWhereInput>;
  };

  export type CraftMaterialOrderByWithRelationInput = {
    id?: SortOrder;
    craftId?: SortOrder;
    artefactId?: SortOrder;
    craft?: CraftOrderByWithRelationInput;
    artefact?: ArtefactOrderByWithRelationInput;
  };

  export type CraftMaterialWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CraftMaterialWhereInput | CraftMaterialWhereInput[];
      OR?: CraftMaterialWhereInput[];
      NOT?: CraftMaterialWhereInput | CraftMaterialWhereInput[];
      craftId?: StringFilter<"CraftMaterial"> | string;
      artefactId?: StringFilter<"CraftMaterial"> | string;
      craft?: XOR<CraftScalarRelationFilter, CraftWhereInput>;
      artefact?: XOR<ArtefactScalarRelationFilter, ArtefactWhereInput>;
    },
    "id"
  >;

  export type CraftMaterialOrderByWithAggregationInput = {
    id?: SortOrder;
    craftId?: SortOrder;
    artefactId?: SortOrder;
    _count?: CraftMaterialCountOrderByAggregateInput;
    _max?: CraftMaterialMaxOrderByAggregateInput;
    _min?: CraftMaterialMinOrderByAggregateInput;
  };

  export type CraftMaterialScalarWhereWithAggregatesInput = {
    AND?:
      | CraftMaterialScalarWhereWithAggregatesInput
      | CraftMaterialScalarWhereWithAggregatesInput[];
    OR?: CraftMaterialScalarWhereWithAggregatesInput[];
    NOT?:
      | CraftMaterialScalarWhereWithAggregatesInput
      | CraftMaterialScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"CraftMaterial"> | string;
    craftId?: StringWithAggregatesFilter<"CraftMaterial"> | string;
    artefactId?: StringWithAggregatesFilter<"CraftMaterial"> | string;
  };

  export type LeaderboardEntryWhereInput = {
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[];
    OR?: LeaderboardEntryWhereInput[];
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[];
    id?: StringFilter<"LeaderboardEntry"> | string;
    userId?: StringFilter<"LeaderboardEntry"> | string;
    huntId?: StringFilter<"LeaderboardEntry"> | string;
    rank?: IntFilter<"LeaderboardEntry"> | number;
    score?: IntFilter<"LeaderboardEntry"> | number;
    completedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    hunt?: XOR<TreasureHuntScalarRelationFilter, TreasureHuntWhereInput>;
  };

  export type LeaderboardEntryOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    rank?: SortOrder;
    score?: SortOrder;
    completedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    hunt?: TreasureHuntOrderByWithRelationInput;
  };

  export type LeaderboardEntryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[];
      OR?: LeaderboardEntryWhereInput[];
      NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[];
      userId?: StringFilter<"LeaderboardEntry"> | string;
      huntId?: StringFilter<"LeaderboardEntry"> | string;
      rank?: IntFilter<"LeaderboardEntry"> | number;
      score?: IntFilter<"LeaderboardEntry"> | number;
      completedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      hunt?: XOR<TreasureHuntScalarRelationFilter, TreasureHuntWhereInput>;
    },
    "id"
  >;

  export type LeaderboardEntryOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    rank?: SortOrder;
    score?: SortOrder;
    completedAt?: SortOrder;
    _count?: LeaderboardEntryCountOrderByAggregateInput;
    _avg?: LeaderboardEntryAvgOrderByAggregateInput;
    _max?: LeaderboardEntryMaxOrderByAggregateInput;
    _min?: LeaderboardEntryMinOrderByAggregateInput;
    _sum?: LeaderboardEntrySumOrderByAggregateInput;
  };

  export type LeaderboardEntryScalarWhereWithAggregatesInput = {
    AND?:
      | LeaderboardEntryScalarWhereWithAggregatesInput
      | LeaderboardEntryScalarWhereWithAggregatesInput[];
    OR?: LeaderboardEntryScalarWhereWithAggregatesInput[];
    NOT?:
      | LeaderboardEntryScalarWhereWithAggregatesInput
      | LeaderboardEntryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"LeaderboardEntry"> | string;
    userId?: StringWithAggregatesFilter<"LeaderboardEntry"> | string;
    huntId?: StringWithAggregatesFilter<"LeaderboardEntry"> | string;
    rank?: IntWithAggregatesFilter<"LeaderboardEntry"> | number;
    score?: IntWithAggregatesFilter<"LeaderboardEntry"> | number;
    completedAt?:
      | DateTimeWithAggregatesFilter<"LeaderboardEntry">
      | Date
      | string;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type SessionCreateInput = {
    id: string;
    expiresAt: Date | string;
    token: string;
    createdAt: Date | string;
    updatedAt: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id: string;
    expiresAt: Date | string;
    token: string;
    createdAt: Date | string;
    updatedAt: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
    userId: string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionCreateManyInput = {
    id: string;
    expiresAt: Date | string;
    token: string;
    createdAt: Date | string;
    updatedAt: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
    userId: string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type AccountCreateInput = {
    id: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id: string;
    accountId: string;
    providerId: string;
    userId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountCreateManyInput = {
    id: string;
    accountId: string;
    providerId: string;
    userId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationCreateInput = {
    id: string;
    identifier: string;
    value: string;
    expiresAt: Date | string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type VerificationUncheckedCreateInput = {
    id: string;
    identifier: string;
    value: string;
    expiresAt: Date | string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type VerificationCreateManyInput = {
    id: string;
    identifier: string;
    value: string;
    expiresAt: Date | string;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
  };

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    updatedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TreasureHuntCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedChassesInput;
    participants?: ParticipationCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardUncheckedCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactUncheckedCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedChassesNestedInput;
    participants?: ParticipationUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUncheckedUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntCreateManyInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TreasureHuntUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TreasureHuntUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationCreateInput = {
    id?: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
    user: UserCreateNestedOneWithoutParticipationsInput;
    treasureHunt: TreasureHuntCreateNestedOneWithoutParticipantsInput;
  };

  export type ParticipationUncheckedCreateInput = {
    id?: string;
    userId: string;
    huntId: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
  };

  export type ParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutParticipationsNestedInput;
    treasureHunt?: TreasureHuntUpdateOneRequiredWithoutParticipantsNestedInput;
  };

  export type ParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationCreateManyInput = {
    id?: string;
    userId: string;
    huntId: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
  };

  export type ParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ArtefactCreateInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    foundAt?: Date | string;
    user: UserCreateNestedOneWithoutCollectedArtefactsInput;
    hunt?: TreasureHuntCreateNestedOneWithoutArtefactsInput;
    Craft?: CraftCreateNestedManyWithoutResultInput;
    CraftMaterial?: CraftMaterialCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactUncheckedCreateInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    huntId?: string | null;
    foundAt?: Date | string;
    Craft?: CraftUncheckedCreateNestedManyWithoutResultInput;
    CraftMaterial?: CraftMaterialUncheckedCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCollectedArtefactsNestedInput;
    hunt?: TreasureHuntUpdateOneWithoutArtefactsNestedInput;
    Craft?: CraftUpdateManyWithoutResultNestedInput;
    CraftMaterial?: CraftMaterialUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: NullableStringFieldUpdateOperationsInput | string | null;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Craft?: CraftUncheckedUpdateManyWithoutResultNestedInput;
    CraftMaterial?: CraftMaterialUncheckedUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactCreateManyInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    huntId?: string | null;
    foundAt?: Date | string;
  };

  export type ArtefactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ArtefactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: NullableStringFieldUpdateOperationsInput | string | null;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HuntStepCreateInput = {
    id?: string;
    description: string;
    stepOrder: number;
    createdAt?: Date | string;
    treasureHunt: TreasureHuntCreateNestedOneWithoutStepsInput;
  };

  export type HuntStepUncheckedCreateInput = {
    id?: string;
    description: string;
    huntId: string;
    stepOrder: number;
    createdAt?: Date | string;
  };

  export type HuntStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    treasureHunt?: TreasureHuntUpdateOneRequiredWithoutStepsNestedInput;
  };

  export type HuntStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HuntStepCreateManyInput = {
    id?: string;
    description: string;
    huntId: string;
    stepOrder: number;
    createdAt?: Date | string;
  };

  export type HuntStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HuntStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RewardCreateInput = {
    id?: string;
    type: $Enums.RewardType;
    value: number;
    description?: string | null;
    treasureHunt: TreasureHuntCreateNestedOneWithoutRewardsInput;
  };

  export type RewardUncheckedCreateInput = {
    id?: string;
    type: $Enums.RewardType;
    value: number;
    description?: string | null;
    huntId: string;
  };

  export type RewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    treasureHunt?: TreasureHuntUpdateOneRequiredWithoutRewardsNestedInput;
  };

  export type RewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    huntId?: StringFieldUpdateOperationsInput | string;
  };

  export type RewardCreateManyInput = {
    id?: string;
    type: $Enums.RewardType;
    value: number;
    description?: string | null;
    huntId: string;
  };

  export type RewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    huntId?: StringFieldUpdateOperationsInput | string;
  };

  export type VirtualCurrencyCreateInput = {
    id?: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutVirtualCurrencyInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutVirtualCurrencyInput;
  };

  export type VirtualCurrencyUncheckedCreateInput = {
    id?: string;
    userId: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutVirtualCurrencyInput;
  };

  export type VirtualCurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutVirtualCurrencyNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutVirtualCurrencyNestedInput;
  };

  export type VirtualCurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutVirtualCurrencyNestedInput;
  };

  export type VirtualCurrencyCreateManyInput = {
    id?: string;
    userId: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VirtualCurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VirtualCurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TransactionHistoryCreateInput = {
    id?: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    virtualCurrency: VirtualCurrencyCreateNestedOneWithoutTransactionHistoryInput;
    user: UserCreateNestedOneWithoutTransactionHistoryInput;
  };

  export type TransactionHistoryUncheckedCreateInput = {
    id?: string;
    userId: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    virtualCurrencyId: string;
  };

  export type TransactionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    virtualCurrency?: VirtualCurrencyUpdateOneRequiredWithoutTransactionHistoryNestedInput;
    user?: UserUpdateOneRequiredWithoutTransactionHistoryNestedInput;
  };

  export type TransactionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    virtualCurrencyId?: StringFieldUpdateOperationsInput | string;
  };

  export type TransactionHistoryCreateManyInput = {
    id?: string;
    userId: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    virtualCurrencyId: string;
  };

  export type TransactionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TransactionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    virtualCurrencyId?: StringFieldUpdateOperationsInput | string;
  };

  export type CraftCreateInput = {
    id?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutCraftInput;
    result: ArtefactCreateNestedOneWithoutCraftInput;
    materials?: CraftMaterialCreateNestedManyWithoutCraftInput;
  };

  export type CraftUncheckedCreateInput = {
    id?: string;
    userId: string;
    resultId: string;
    createdAt?: Date | string;
    materials?: CraftMaterialUncheckedCreateNestedManyWithoutCraftInput;
  };

  export type CraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCraftNestedInput;
    result?: ArtefactUpdateOneRequiredWithoutCraftNestedInput;
    materials?: CraftMaterialUpdateManyWithoutCraftNestedInput;
  };

  export type CraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    resultId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    materials?: CraftMaterialUncheckedUpdateManyWithoutCraftNestedInput;
  };

  export type CraftCreateManyInput = {
    id?: string;
    userId: string;
    resultId: string;
    createdAt?: Date | string;
  };

  export type CraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    resultId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CraftMaterialCreateInput = {
    id?: string;
    craft: CraftCreateNestedOneWithoutMaterialsInput;
    artefact: ArtefactCreateNestedOneWithoutCraftMaterialInput;
  };

  export type CraftMaterialUncheckedCreateInput = {
    id?: string;
    craftId: string;
    artefactId: string;
  };

  export type CraftMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    craft?: CraftUpdateOneRequiredWithoutMaterialsNestedInput;
    artefact?: ArtefactUpdateOneRequiredWithoutCraftMaterialNestedInput;
  };

  export type CraftMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    craftId?: StringFieldUpdateOperationsInput | string;
    artefactId?: StringFieldUpdateOperationsInput | string;
  };

  export type CraftMaterialCreateManyInput = {
    id?: string;
    craftId: string;
    artefactId: string;
  };

  export type CraftMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
  };

  export type CraftMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    craftId?: StringFieldUpdateOperationsInput | string;
    artefactId?: StringFieldUpdateOperationsInput | string;
  };

  export type LeaderboardEntryCreateInput = {
    id?: string;
    rank: number;
    score: number;
    completedAt: Date | string;
    user: UserCreateNestedOneWithoutLeaderboardEntryInput;
    hunt: TreasureHuntCreateNestedOneWithoutLeaderboardEntryInput;
  };

  export type LeaderboardEntryUncheckedCreateInput = {
    id?: string;
    userId: string;
    huntId: string;
    rank: number;
    score: number;
    completedAt: Date | string;
  };

  export type LeaderboardEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutLeaderboardEntryNestedInput;
    hunt?: TreasureHuntUpdateOneRequiredWithoutLeaderboardEntryNestedInput;
  };

  export type LeaderboardEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardEntryCreateManyInput = {
    id?: string;
    userId: string;
    huntId: string;
    rank: number;
    score: number;
    completedAt: Date | string;
  };

  export type LeaderboardEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type ParticipationListRelationFilter = {
    every?: ParticipationWhereInput;
    some?: ParticipationWhereInput;
    none?: ParticipationWhereInput;
  };

  export type TreasureHuntListRelationFilter = {
    every?: TreasureHuntWhereInput;
    some?: TreasureHuntWhereInput;
    none?: TreasureHuntWhereInput;
  };

  export type ArtefactListRelationFilter = {
    every?: ArtefactWhereInput;
    some?: ArtefactWhereInput;
    none?: ArtefactWhereInput;
  };

  export type VirtualCurrencyListRelationFilter = {
    every?: VirtualCurrencyWhereInput;
    some?: VirtualCurrencyWhereInput;
    none?: VirtualCurrencyWhereInput;
  };

  export type TransactionHistoryListRelationFilter = {
    every?: TransactionHistoryWhereInput;
    some?: TransactionHistoryWhereInput;
    none?: TransactionHistoryWhereInput;
  };

  export type CraftListRelationFilter = {
    every?: CraftWhereInput;
    some?: CraftWhereInput;
    none?: CraftWhereInput;
  };

  export type LeaderboardEntryListRelationFilter = {
    every?: LeaderboardEntryWhereInput;
    some?: LeaderboardEntryWhereInput;
    none?: LeaderboardEntryWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TreasureHuntOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ArtefactOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type VirtualCurrencyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TransactionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CraftOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LeaderboardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    stripeCustomerId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    nickname?: SortOrder;
    role?: SortOrder;
    isMfaEnabled?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    stripeCustomerId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    nickname?: SortOrder;
    role?: SortOrder;
    isMfaEnabled?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    stripeCustomerId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    nickname?: SortOrder;
    role?: SortOrder;
    isMfaEnabled?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    idToken?: SortOrder;
    accessTokenExpiresAt?: SortOrder;
    refreshTokenExpiresAt?: SortOrder;
    scope?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    idToken?: SortOrder;
    accessTokenExpiresAt?: SortOrder;
    refreshTokenExpiresAt?: SortOrder;
    scope?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    idToken?: SortOrder;
    accessTokenExpiresAt?: SortOrder;
    refreshTokenExpiresAt?: SortOrder;
    scope?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumHuntModeFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntMode | EnumHuntModeFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    not?: NestedEnumHuntModeFilter<$PrismaModel> | $Enums.HuntMode;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type EnumHuntStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntStatus | EnumHuntStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumHuntStatusFilter<$PrismaModel> | $Enums.HuntStatus;
  };

  export type HuntStepListRelationFilter = {
    every?: HuntStepWhereInput;
    some?: HuntStepWhereInput;
    none?: HuntStepWhereInput;
  };

  export type RewardListRelationFilter = {
    every?: RewardWhereInput;
    some?: RewardWhereInput;
    none?: RewardWhereInput;
  };

  export type HuntStepOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RewardOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TreasureHuntCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    createdById?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    location?: SortOrder;
    mode?: SortOrder;
    fee?: SortOrder;
    mapStyle?: SortOrder;
    isFinished?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TreasureHuntAvgOrderByAggregateInput = {
    fee?: SortOrder;
  };

  export type TreasureHuntMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    createdById?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    location?: SortOrder;
    mode?: SortOrder;
    fee?: SortOrder;
    mapStyle?: SortOrder;
    isFinished?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TreasureHuntMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    createdById?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    location?: SortOrder;
    mode?: SortOrder;
    fee?: SortOrder;
    mapStyle?: SortOrder;
    isFinished?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TreasureHuntSumOrderByAggregateInput = {
    fee?: SortOrder;
  };

  export type EnumHuntModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntMode | EnumHuntModeFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumHuntModeWithAggregatesFilter<$PrismaModel>
      | $Enums.HuntMode;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHuntModeFilter<$PrismaModel>;
    _max?: NestedEnumHuntModeFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type EnumHuntStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntStatus | EnumHuntStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumHuntStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.HuntStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHuntStatusFilter<$PrismaModel>;
    _max?: NestedEnumHuntStatusFilter<$PrismaModel>;
  };

  export type EnumParticipationStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ParticipationStatus
      | EnumParticipationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumParticipationStatusFilter<$PrismaModel>
      | $Enums.ParticipationStatus;
  };

  export type TreasureHuntScalarRelationFilter = {
    is?: TreasureHuntWhereInput;
    isNot?: TreasureHuntWhereInput;
  };

  export type ParticipationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    status?: SortOrder;
    joinDate?: SortOrder;
  };

  export type ParticipationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    status?: SortOrder;
    joinDate?: SortOrder;
  };

  export type ParticipationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    status?: SortOrder;
    joinDate?: SortOrder;
  };

  export type EnumParticipationStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ParticipationStatus
      | EnumParticipationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumParticipationStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ParticipationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumParticipationStatusFilter<$PrismaModel>;
    _max?: NestedEnumParticipationStatusFilter<$PrismaModel>;
  };

  export type EnumArtefactRarityFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ArtefactRarity
      | EnumArtefactRarityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    not?: NestedEnumArtefactRarityFilter<$PrismaModel> | $Enums.ArtefactRarity;
  };

  export type EnumArtefactSourceFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ArtefactSource
      | EnumArtefactSourceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    not?: NestedEnumArtefactSourceFilter<$PrismaModel> | $Enums.ArtefactSource;
  };

  export type TreasureHuntNullableScalarRelationFilter = {
    is?: TreasureHuntWhereInput | null;
    isNot?: TreasureHuntWhereInput | null;
  };

  export type CraftMaterialListRelationFilter = {
    every?: CraftMaterialWhereInput;
    some?: CraftMaterialWhereInput;
    none?: CraftMaterialWhereInput;
  };

  export type CraftMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ArtefactCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    rarity?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    isHidden?: SortOrder;
    source?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    foundAt?: SortOrder;
  };

  export type ArtefactMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    rarity?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    isHidden?: SortOrder;
    source?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    foundAt?: SortOrder;
  };

  export type ArtefactMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    rarity?: SortOrder;
    description?: SortOrder;
    imageUrl?: SortOrder;
    isHidden?: SortOrder;
    source?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    foundAt?: SortOrder;
  };

  export type EnumArtefactRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ArtefactRarity
      | EnumArtefactRarityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumArtefactRarityWithAggregatesFilter<$PrismaModel>
      | $Enums.ArtefactRarity;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumArtefactRarityFilter<$PrismaModel>;
    _max?: NestedEnumArtefactRarityFilter<$PrismaModel>;
  };

  export type EnumArtefactSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ArtefactSource
      | EnumArtefactSourceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumArtefactSourceWithAggregatesFilter<$PrismaModel>
      | $Enums.ArtefactSource;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumArtefactSourceFilter<$PrismaModel>;
    _max?: NestedEnumArtefactSourceFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type HuntStepCountOrderByAggregateInput = {
    id?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
    stepOrder?: SortOrder;
    createdAt?: SortOrder;
  };

  export type HuntStepAvgOrderByAggregateInput = {
    stepOrder?: SortOrder;
  };

  export type HuntStepMaxOrderByAggregateInput = {
    id?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
    stepOrder?: SortOrder;
    createdAt?: SortOrder;
  };

  export type HuntStepMinOrderByAggregateInput = {
    id?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
    stepOrder?: SortOrder;
    createdAt?: SortOrder;
  };

  export type HuntStepSumOrderByAggregateInput = {
    stepOrder?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType;
  };

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
  };

  export type RewardAvgOrderByAggregateInput = {
    value?: SortOrder;
  };

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
  };

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    huntId?: SortOrder;
  };

  export type RewardSumOrderByAggregateInput = {
    value?: SortOrder;
  };

  export type EnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.RewardType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>;
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>;
  };

  export type EnumCurrencySourceTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CurrencySourceType
      | EnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CurrencySourceType[]
      | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CurrencySourceType[]
      | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCurrencySourceTypeFilter<$PrismaModel>
      | $Enums.CurrencySourceType;
  };

  export type VirtualCurrencyCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VirtualCurrencyAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type VirtualCurrencyMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VirtualCurrencyMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VirtualCurrencySumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type EnumCurrencySourceTypeWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.CurrencySourceType
        | EnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.CurrencySourceType[]
        | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.CurrencySourceType[]
        | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumCurrencySourceTypeWithAggregatesFilter<$PrismaModel>
        | $Enums.CurrencySourceType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumCurrencySourceTypeFilter<$PrismaModel>;
      _max?: NestedEnumCurrencySourceTypeFilter<$PrismaModel>;
    };

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeFilter<$PrismaModel>
      | $Enums.TransactionType;
  };

  export type VirtualCurrencyScalarRelationFilter = {
    is?: VirtualCurrencyWhereInput;
    isNot?: VirtualCurrencyWhereInput;
  };

  export type TransactionHistoryCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    transactionId?: SortOrder;
    stripeSessionId?: SortOrder;
    amount?: SortOrder;
    transactionType?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    virtualCurrencyId?: SortOrder;
  };

  export type TransactionHistoryAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type TransactionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    transactionId?: SortOrder;
    stripeSessionId?: SortOrder;
    amount?: SortOrder;
    transactionType?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    virtualCurrencyId?: SortOrder;
  };

  export type TransactionHistoryMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    transactionId?: SortOrder;
    stripeSessionId?: SortOrder;
    amount?: SortOrder;
    transactionType?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    virtualCurrencyId?: SortOrder;
  };

  export type TransactionHistorySumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.TransactionType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>;
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>;
  };

  export type ArtefactScalarRelationFilter = {
    is?: ArtefactWhereInput;
    isNot?: ArtefactWhereInput;
  };

  export type CraftCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    resultId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CraftMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    resultId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CraftMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    resultId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CraftScalarRelationFilter = {
    is?: CraftWhereInput;
    isNot?: CraftWhereInput;
  };

  export type CraftMaterialCountOrderByAggregateInput = {
    id?: SortOrder;
    craftId?: SortOrder;
    artefactId?: SortOrder;
  };

  export type CraftMaterialMaxOrderByAggregateInput = {
    id?: SortOrder;
    craftId?: SortOrder;
    artefactId?: SortOrder;
  };

  export type CraftMaterialMinOrderByAggregateInput = {
    id?: SortOrder;
    craftId?: SortOrder;
    artefactId?: SortOrder;
  };

  export type LeaderboardEntryCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    rank?: SortOrder;
    score?: SortOrder;
    completedAt?: SortOrder;
  };

  export type LeaderboardEntryAvgOrderByAggregateInput = {
    rank?: SortOrder;
    score?: SortOrder;
  };

  export type LeaderboardEntryMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    rank?: SortOrder;
    score?: SortOrder;
    completedAt?: SortOrder;
  };

  export type LeaderboardEntryMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    huntId?: SortOrder;
    rank?: SortOrder;
    score?: SortOrder;
    completedAt?: SortOrder;
  };

  export type LeaderboardEntrySumOrderByAggregateInput = {
    rank?: SortOrder;
    score?: SortOrder;
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type ParticipationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutUserInput,
          ParticipationUncheckedCreateWithoutUserInput
        >
      | ParticipationCreateWithoutUserInput[]
      | ParticipationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutUserInput
      | ParticipationCreateOrConnectWithoutUserInput[];
    createMany?: ParticipationCreateManyUserInputEnvelope;
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
  };

  export type TreasureHuntCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<
          TreasureHuntCreateWithoutCreatedByInput,
          TreasureHuntUncheckedCreateWithoutCreatedByInput
        >
      | TreasureHuntCreateWithoutCreatedByInput[]
      | TreasureHuntUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | TreasureHuntCreateOrConnectWithoutCreatedByInput
      | TreasureHuntCreateOrConnectWithoutCreatedByInput[];
    createMany?: TreasureHuntCreateManyCreatedByInputEnvelope;
    connect?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
  };

  export type ArtefactCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutUserInput,
          ArtefactUncheckedCreateWithoutUserInput
        >
      | ArtefactCreateWithoutUserInput[]
      | ArtefactUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutUserInput
      | ArtefactCreateOrConnectWithoutUserInput[];
    createMany?: ArtefactCreateManyUserInputEnvelope;
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
  };

  export type VirtualCurrencyCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          VirtualCurrencyCreateWithoutUserInput,
          VirtualCurrencyUncheckedCreateWithoutUserInput
        >
      | VirtualCurrencyCreateWithoutUserInput[]
      | VirtualCurrencyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VirtualCurrencyCreateOrConnectWithoutUserInput
      | VirtualCurrencyCreateOrConnectWithoutUserInput[];
    createMany?: VirtualCurrencyCreateManyUserInputEnvelope;
    connect?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
  };

  export type TransactionHistoryCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          TransactionHistoryCreateWithoutUserInput,
          TransactionHistoryUncheckedCreateWithoutUserInput
        >
      | TransactionHistoryCreateWithoutUserInput[]
      | TransactionHistoryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TransactionHistoryCreateOrConnectWithoutUserInput
      | TransactionHistoryCreateOrConnectWithoutUserInput[];
    createMany?: TransactionHistoryCreateManyUserInputEnvelope;
    connect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
  };

  export type CraftCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CraftCreateWithoutUserInput, CraftUncheckedCreateWithoutUserInput>
      | CraftCreateWithoutUserInput[]
      | CraftUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutUserInput
      | CraftCreateOrConnectWithoutUserInput[];
    createMany?: CraftCreateManyUserInputEnvelope;
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
  };

  export type LeaderboardEntryCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutUserInput,
          LeaderboardEntryUncheckedCreateWithoutUserInput
        >
      | LeaderboardEntryCreateWithoutUserInput[]
      | LeaderboardEntryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutUserInput
      | LeaderboardEntryCreateOrConnectWithoutUserInput[];
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope;
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type ParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutUserInput,
          ParticipationUncheckedCreateWithoutUserInput
        >
      | ParticipationCreateWithoutUserInput[]
      | ParticipationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutUserInput
      | ParticipationCreateOrConnectWithoutUserInput[];
    createMany?: ParticipationCreateManyUserInputEnvelope;
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
  };

  export type TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<
          TreasureHuntCreateWithoutCreatedByInput,
          TreasureHuntUncheckedCreateWithoutCreatedByInput
        >
      | TreasureHuntCreateWithoutCreatedByInput[]
      | TreasureHuntUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | TreasureHuntCreateOrConnectWithoutCreatedByInput
      | TreasureHuntCreateOrConnectWithoutCreatedByInput[];
    createMany?: TreasureHuntCreateManyCreatedByInputEnvelope;
    connect?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
  };

  export type ArtefactUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutUserInput,
          ArtefactUncheckedCreateWithoutUserInput
        >
      | ArtefactCreateWithoutUserInput[]
      | ArtefactUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutUserInput
      | ArtefactCreateOrConnectWithoutUserInput[];
    createMany?: ArtefactCreateManyUserInputEnvelope;
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
  };

  export type VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          VirtualCurrencyCreateWithoutUserInput,
          VirtualCurrencyUncheckedCreateWithoutUserInput
        >
      | VirtualCurrencyCreateWithoutUserInput[]
      | VirtualCurrencyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VirtualCurrencyCreateOrConnectWithoutUserInput
      | VirtualCurrencyCreateOrConnectWithoutUserInput[];
    createMany?: VirtualCurrencyCreateManyUserInputEnvelope;
    connect?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
  };

  export type TransactionHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          TransactionHistoryCreateWithoutUserInput,
          TransactionHistoryUncheckedCreateWithoutUserInput
        >
      | TransactionHistoryCreateWithoutUserInput[]
      | TransactionHistoryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TransactionHistoryCreateOrConnectWithoutUserInput
      | TransactionHistoryCreateOrConnectWithoutUserInput[];
    createMany?: TransactionHistoryCreateManyUserInputEnvelope;
    connect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
  };

  export type CraftUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<CraftCreateWithoutUserInput, CraftUncheckedCreateWithoutUserInput>
      | CraftCreateWithoutUserInput[]
      | CraftUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutUserInput
      | CraftCreateOrConnectWithoutUserInput[];
    createMany?: CraftCreateManyUserInputEnvelope;
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
  };

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutUserInput,
          LeaderboardEntryUncheckedCreateWithoutUserInput
        >
      | LeaderboardEntryCreateWithoutUserInput[]
      | LeaderboardEntryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutUserInput
      | LeaderboardEntryCreateOrConnectWithoutUserInput[];
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope;
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type ParticipationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutUserInput,
          ParticipationUncheckedCreateWithoutUserInput
        >
      | ParticipationCreateWithoutUserInput[]
      | ParticipationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutUserInput
      | ParticipationCreateOrConnectWithoutUserInput[];
    upsert?:
      | ParticipationUpsertWithWhereUniqueWithoutUserInput
      | ParticipationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ParticipationCreateManyUserInputEnvelope;
    set?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    disconnect?:
      | ParticipationWhereUniqueInput
      | ParticipationWhereUniqueInput[];
    delete?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    update?:
      | ParticipationUpdateWithWhereUniqueWithoutUserInput
      | ParticipationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ParticipationUpdateManyWithWhereWithoutUserInput
      | ParticipationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | ParticipationScalarWhereInput
      | ParticipationScalarWhereInput[];
  };

  export type TreasureHuntUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<
          TreasureHuntCreateWithoutCreatedByInput,
          TreasureHuntUncheckedCreateWithoutCreatedByInput
        >
      | TreasureHuntCreateWithoutCreatedByInput[]
      | TreasureHuntUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | TreasureHuntCreateOrConnectWithoutCreatedByInput
      | TreasureHuntCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | TreasureHuntUpsertWithWhereUniqueWithoutCreatedByInput
      | TreasureHuntUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: TreasureHuntCreateManyCreatedByInputEnvelope;
    set?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    disconnect?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    delete?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    connect?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    update?:
      | TreasureHuntUpdateWithWhereUniqueWithoutCreatedByInput
      | TreasureHuntUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | TreasureHuntUpdateManyWithWhereWithoutCreatedByInput
      | TreasureHuntUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: TreasureHuntScalarWhereInput | TreasureHuntScalarWhereInput[];
  };

  export type ArtefactUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutUserInput,
          ArtefactUncheckedCreateWithoutUserInput
        >
      | ArtefactCreateWithoutUserInput[]
      | ArtefactUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutUserInput
      | ArtefactCreateOrConnectWithoutUserInput[];
    upsert?:
      | ArtefactUpsertWithWhereUniqueWithoutUserInput
      | ArtefactUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ArtefactCreateManyUserInputEnvelope;
    set?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    disconnect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    delete?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    update?:
      | ArtefactUpdateWithWhereUniqueWithoutUserInput
      | ArtefactUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ArtefactUpdateManyWithWhereWithoutUserInput
      | ArtefactUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ArtefactScalarWhereInput | ArtefactScalarWhereInput[];
  };

  export type VirtualCurrencyUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          VirtualCurrencyCreateWithoutUserInput,
          VirtualCurrencyUncheckedCreateWithoutUserInput
        >
      | VirtualCurrencyCreateWithoutUserInput[]
      | VirtualCurrencyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VirtualCurrencyCreateOrConnectWithoutUserInput
      | VirtualCurrencyCreateOrConnectWithoutUserInput[];
    upsert?:
      | VirtualCurrencyUpsertWithWhereUniqueWithoutUserInput
      | VirtualCurrencyUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: VirtualCurrencyCreateManyUserInputEnvelope;
    set?: VirtualCurrencyWhereUniqueInput | VirtualCurrencyWhereUniqueInput[];
    disconnect?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
    delete?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
    connect?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
    update?:
      | VirtualCurrencyUpdateWithWhereUniqueWithoutUserInput
      | VirtualCurrencyUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | VirtualCurrencyUpdateManyWithWhereWithoutUserInput
      | VirtualCurrencyUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | VirtualCurrencyScalarWhereInput
      | VirtualCurrencyScalarWhereInput[];
  };

  export type TransactionHistoryUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          TransactionHistoryCreateWithoutUserInput,
          TransactionHistoryUncheckedCreateWithoutUserInput
        >
      | TransactionHistoryCreateWithoutUserInput[]
      | TransactionHistoryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TransactionHistoryCreateOrConnectWithoutUserInput
      | TransactionHistoryCreateOrConnectWithoutUserInput[];
    upsert?:
      | TransactionHistoryUpsertWithWhereUniqueWithoutUserInput
      | TransactionHistoryUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TransactionHistoryCreateManyUserInputEnvelope;
    set?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    disconnect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    delete?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    connect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    update?:
      | TransactionHistoryUpdateWithWhereUniqueWithoutUserInput
      | TransactionHistoryUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TransactionHistoryUpdateManyWithWhereWithoutUserInput
      | TransactionHistoryUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | TransactionHistoryScalarWhereInput
      | TransactionHistoryScalarWhereInput[];
  };

  export type CraftUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CraftCreateWithoutUserInput, CraftUncheckedCreateWithoutUserInput>
      | CraftCreateWithoutUserInput[]
      | CraftUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutUserInput
      | CraftCreateOrConnectWithoutUserInput[];
    upsert?:
      | CraftUpsertWithWhereUniqueWithoutUserInput
      | CraftUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CraftCreateManyUserInputEnvelope;
    set?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    disconnect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    delete?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    update?:
      | CraftUpdateWithWhereUniqueWithoutUserInput
      | CraftUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CraftUpdateManyWithWhereWithoutUserInput
      | CraftUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CraftScalarWhereInput | CraftScalarWhereInput[];
  };

  export type LeaderboardEntryUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutUserInput,
          LeaderboardEntryUncheckedCreateWithoutUserInput
        >
      | LeaderboardEntryCreateWithoutUserInput[]
      | LeaderboardEntryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutUserInput
      | LeaderboardEntryCreateOrConnectWithoutUserInput[];
    upsert?:
      | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput
      | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope;
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[];
    disconnect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    delete?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    update?:
      | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput
      | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | LeaderboardEntryUpdateManyWithWhereWithoutUserInput
      | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | LeaderboardEntryScalarWhereInput
      | LeaderboardEntryScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type ParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutUserInput,
          ParticipationUncheckedCreateWithoutUserInput
        >
      | ParticipationCreateWithoutUserInput[]
      | ParticipationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutUserInput
      | ParticipationCreateOrConnectWithoutUserInput[];
    upsert?:
      | ParticipationUpsertWithWhereUniqueWithoutUserInput
      | ParticipationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ParticipationCreateManyUserInputEnvelope;
    set?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    disconnect?:
      | ParticipationWhereUniqueInput
      | ParticipationWhereUniqueInput[];
    delete?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    update?:
      | ParticipationUpdateWithWhereUniqueWithoutUserInput
      | ParticipationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ParticipationUpdateManyWithWhereWithoutUserInput
      | ParticipationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | ParticipationScalarWhereInput
      | ParticipationScalarWhereInput[];
  };

  export type TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<
          TreasureHuntCreateWithoutCreatedByInput,
          TreasureHuntUncheckedCreateWithoutCreatedByInput
        >
      | TreasureHuntCreateWithoutCreatedByInput[]
      | TreasureHuntUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | TreasureHuntCreateOrConnectWithoutCreatedByInput
      | TreasureHuntCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | TreasureHuntUpsertWithWhereUniqueWithoutCreatedByInput
      | TreasureHuntUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: TreasureHuntCreateManyCreatedByInputEnvelope;
    set?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    disconnect?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    delete?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    connect?: TreasureHuntWhereUniqueInput | TreasureHuntWhereUniqueInput[];
    update?:
      | TreasureHuntUpdateWithWhereUniqueWithoutCreatedByInput
      | TreasureHuntUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | TreasureHuntUpdateManyWithWhereWithoutCreatedByInput
      | TreasureHuntUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: TreasureHuntScalarWhereInput | TreasureHuntScalarWhereInput[];
  };

  export type ArtefactUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutUserInput,
          ArtefactUncheckedCreateWithoutUserInput
        >
      | ArtefactCreateWithoutUserInput[]
      | ArtefactUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutUserInput
      | ArtefactCreateOrConnectWithoutUserInput[];
    upsert?:
      | ArtefactUpsertWithWhereUniqueWithoutUserInput
      | ArtefactUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ArtefactCreateManyUserInputEnvelope;
    set?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    disconnect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    delete?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    update?:
      | ArtefactUpdateWithWhereUniqueWithoutUserInput
      | ArtefactUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ArtefactUpdateManyWithWhereWithoutUserInput
      | ArtefactUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ArtefactScalarWhereInput | ArtefactScalarWhereInput[];
  };

  export type VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          VirtualCurrencyCreateWithoutUserInput,
          VirtualCurrencyUncheckedCreateWithoutUserInput
        >
      | VirtualCurrencyCreateWithoutUserInput[]
      | VirtualCurrencyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VirtualCurrencyCreateOrConnectWithoutUserInput
      | VirtualCurrencyCreateOrConnectWithoutUserInput[];
    upsert?:
      | VirtualCurrencyUpsertWithWhereUniqueWithoutUserInput
      | VirtualCurrencyUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: VirtualCurrencyCreateManyUserInputEnvelope;
    set?: VirtualCurrencyWhereUniqueInput | VirtualCurrencyWhereUniqueInput[];
    disconnect?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
    delete?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
    connect?:
      | VirtualCurrencyWhereUniqueInput
      | VirtualCurrencyWhereUniqueInput[];
    update?:
      | VirtualCurrencyUpdateWithWhereUniqueWithoutUserInput
      | VirtualCurrencyUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | VirtualCurrencyUpdateManyWithWhereWithoutUserInput
      | VirtualCurrencyUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | VirtualCurrencyScalarWhereInput
      | VirtualCurrencyScalarWhereInput[];
  };

  export type TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          TransactionHistoryCreateWithoutUserInput,
          TransactionHistoryUncheckedCreateWithoutUserInput
        >
      | TransactionHistoryCreateWithoutUserInput[]
      | TransactionHistoryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TransactionHistoryCreateOrConnectWithoutUserInput
      | TransactionHistoryCreateOrConnectWithoutUserInput[];
    upsert?:
      | TransactionHistoryUpsertWithWhereUniqueWithoutUserInput
      | TransactionHistoryUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TransactionHistoryCreateManyUserInputEnvelope;
    set?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    disconnect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    delete?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    connect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    update?:
      | TransactionHistoryUpdateWithWhereUniqueWithoutUserInput
      | TransactionHistoryUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TransactionHistoryUpdateManyWithWhereWithoutUserInput
      | TransactionHistoryUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | TransactionHistoryScalarWhereInput
      | TransactionHistoryScalarWhereInput[];
  };

  export type CraftUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<CraftCreateWithoutUserInput, CraftUncheckedCreateWithoutUserInput>
      | CraftCreateWithoutUserInput[]
      | CraftUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutUserInput
      | CraftCreateOrConnectWithoutUserInput[];
    upsert?:
      | CraftUpsertWithWhereUniqueWithoutUserInput
      | CraftUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: CraftCreateManyUserInputEnvelope;
    set?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    disconnect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    delete?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    update?:
      | CraftUpdateWithWhereUniqueWithoutUserInput
      | CraftUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | CraftUpdateManyWithWhereWithoutUserInput
      | CraftUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: CraftScalarWhereInput | CraftScalarWhereInput[];
  };

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutUserInput,
          LeaderboardEntryUncheckedCreateWithoutUserInput
        >
      | LeaderboardEntryCreateWithoutUserInput[]
      | LeaderboardEntryUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutUserInput
      | LeaderboardEntryCreateOrConnectWithoutUserInput[];
    upsert?:
      | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput
      | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope;
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[];
    disconnect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    delete?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    update?:
      | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput
      | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | LeaderboardEntryUpdateManyWithWhereWithoutUserInput
      | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | LeaderboardEntryScalarWhereInput
      | LeaderboardEntryScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSessionsInput,
        UserUpdateWithoutSessionsInput
      >,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAccountsInput,
        UserUpdateWithoutAccountsInput
      >,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutCreatedChassesInput = {
    create?: XOR<
      UserCreateWithoutCreatedChassesInput,
      UserUncheckedCreateWithoutCreatedChassesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChassesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ParticipationCreateNestedManyWithoutTreasureHuntInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutTreasureHuntInput,
          ParticipationUncheckedCreateWithoutTreasureHuntInput
        >
      | ParticipationCreateWithoutTreasureHuntInput[]
      | ParticipationUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutTreasureHuntInput
      | ParticipationCreateOrConnectWithoutTreasureHuntInput[];
    createMany?: ParticipationCreateManyTreasureHuntInputEnvelope;
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
  };

  export type HuntStepCreateNestedManyWithoutTreasureHuntInput = {
    create?:
      | XOR<
          HuntStepCreateWithoutTreasureHuntInput,
          HuntStepUncheckedCreateWithoutTreasureHuntInput
        >
      | HuntStepCreateWithoutTreasureHuntInput[]
      | HuntStepUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | HuntStepCreateOrConnectWithoutTreasureHuntInput
      | HuntStepCreateOrConnectWithoutTreasureHuntInput[];
    createMany?: HuntStepCreateManyTreasureHuntInputEnvelope;
    connect?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
  };

  export type RewardCreateNestedManyWithoutTreasureHuntInput = {
    create?:
      | XOR<
          RewardCreateWithoutTreasureHuntInput,
          RewardUncheckedCreateWithoutTreasureHuntInput
        >
      | RewardCreateWithoutTreasureHuntInput[]
      | RewardUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | RewardCreateOrConnectWithoutTreasureHuntInput
      | RewardCreateOrConnectWithoutTreasureHuntInput[];
    createMany?: RewardCreateManyTreasureHuntInputEnvelope;
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
  };

  export type ArtefactCreateNestedManyWithoutHuntInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutHuntInput,
          ArtefactUncheckedCreateWithoutHuntInput
        >
      | ArtefactCreateWithoutHuntInput[]
      | ArtefactUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutHuntInput
      | ArtefactCreateOrConnectWithoutHuntInput[];
    createMany?: ArtefactCreateManyHuntInputEnvelope;
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
  };

  export type LeaderboardEntryCreateNestedManyWithoutHuntInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutHuntInput,
          LeaderboardEntryUncheckedCreateWithoutHuntInput
        >
      | LeaderboardEntryCreateWithoutHuntInput[]
      | LeaderboardEntryUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutHuntInput
      | LeaderboardEntryCreateOrConnectWithoutHuntInput[];
    createMany?: LeaderboardEntryCreateManyHuntInputEnvelope;
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
  };

  export type ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutTreasureHuntInput,
          ParticipationUncheckedCreateWithoutTreasureHuntInput
        >
      | ParticipationCreateWithoutTreasureHuntInput[]
      | ParticipationUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutTreasureHuntInput
      | ParticipationCreateOrConnectWithoutTreasureHuntInput[];
    createMany?: ParticipationCreateManyTreasureHuntInputEnvelope;
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
  };

  export type HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput = {
    create?:
      | XOR<
          HuntStepCreateWithoutTreasureHuntInput,
          HuntStepUncheckedCreateWithoutTreasureHuntInput
        >
      | HuntStepCreateWithoutTreasureHuntInput[]
      | HuntStepUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | HuntStepCreateOrConnectWithoutTreasureHuntInput
      | HuntStepCreateOrConnectWithoutTreasureHuntInput[];
    createMany?: HuntStepCreateManyTreasureHuntInputEnvelope;
    connect?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
  };

  export type RewardUncheckedCreateNestedManyWithoutTreasureHuntInput = {
    create?:
      | XOR<
          RewardCreateWithoutTreasureHuntInput,
          RewardUncheckedCreateWithoutTreasureHuntInput
        >
      | RewardCreateWithoutTreasureHuntInput[]
      | RewardUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | RewardCreateOrConnectWithoutTreasureHuntInput
      | RewardCreateOrConnectWithoutTreasureHuntInput[];
    createMany?: RewardCreateManyTreasureHuntInputEnvelope;
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
  };

  export type ArtefactUncheckedCreateNestedManyWithoutHuntInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutHuntInput,
          ArtefactUncheckedCreateWithoutHuntInput
        >
      | ArtefactCreateWithoutHuntInput[]
      | ArtefactUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutHuntInput
      | ArtefactCreateOrConnectWithoutHuntInput[];
    createMany?: ArtefactCreateManyHuntInputEnvelope;
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
  };

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutHuntInput,
          LeaderboardEntryUncheckedCreateWithoutHuntInput
        >
      | LeaderboardEntryCreateWithoutHuntInput[]
      | LeaderboardEntryUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutHuntInput
      | LeaderboardEntryCreateOrConnectWithoutHuntInput[];
    createMany?: LeaderboardEntryCreateManyHuntInputEnvelope;
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
  };

  export type EnumHuntModeFieldUpdateOperationsInput = {
    set?: $Enums.HuntMode;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumHuntStatusFieldUpdateOperationsInput = {
    set?: $Enums.HuntStatus;
  };

  export type UserUpdateOneRequiredWithoutCreatedChassesNestedInput = {
    create?: XOR<
      UserCreateWithoutCreatedChassesInput,
      UserUncheckedCreateWithoutCreatedChassesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChassesInput;
    upsert?: UserUpsertWithoutCreatedChassesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCreatedChassesInput,
        UserUpdateWithoutCreatedChassesInput
      >,
      UserUncheckedUpdateWithoutCreatedChassesInput
    >;
  };

  export type ParticipationUpdateManyWithoutTreasureHuntNestedInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutTreasureHuntInput,
          ParticipationUncheckedCreateWithoutTreasureHuntInput
        >
      | ParticipationCreateWithoutTreasureHuntInput[]
      | ParticipationUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutTreasureHuntInput
      | ParticipationCreateOrConnectWithoutTreasureHuntInput[];
    upsert?:
      | ParticipationUpsertWithWhereUniqueWithoutTreasureHuntInput
      | ParticipationUpsertWithWhereUniqueWithoutTreasureHuntInput[];
    createMany?: ParticipationCreateManyTreasureHuntInputEnvelope;
    set?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    disconnect?:
      | ParticipationWhereUniqueInput
      | ParticipationWhereUniqueInput[];
    delete?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    update?:
      | ParticipationUpdateWithWhereUniqueWithoutTreasureHuntInput
      | ParticipationUpdateWithWhereUniqueWithoutTreasureHuntInput[];
    updateMany?:
      | ParticipationUpdateManyWithWhereWithoutTreasureHuntInput
      | ParticipationUpdateManyWithWhereWithoutTreasureHuntInput[];
    deleteMany?:
      | ParticipationScalarWhereInput
      | ParticipationScalarWhereInput[];
  };

  export type HuntStepUpdateManyWithoutTreasureHuntNestedInput = {
    create?:
      | XOR<
          HuntStepCreateWithoutTreasureHuntInput,
          HuntStepUncheckedCreateWithoutTreasureHuntInput
        >
      | HuntStepCreateWithoutTreasureHuntInput[]
      | HuntStepUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | HuntStepCreateOrConnectWithoutTreasureHuntInput
      | HuntStepCreateOrConnectWithoutTreasureHuntInput[];
    upsert?:
      | HuntStepUpsertWithWhereUniqueWithoutTreasureHuntInput
      | HuntStepUpsertWithWhereUniqueWithoutTreasureHuntInput[];
    createMany?: HuntStepCreateManyTreasureHuntInputEnvelope;
    set?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    disconnect?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    delete?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    connect?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    update?:
      | HuntStepUpdateWithWhereUniqueWithoutTreasureHuntInput
      | HuntStepUpdateWithWhereUniqueWithoutTreasureHuntInput[];
    updateMany?:
      | HuntStepUpdateManyWithWhereWithoutTreasureHuntInput
      | HuntStepUpdateManyWithWhereWithoutTreasureHuntInput[];
    deleteMany?: HuntStepScalarWhereInput | HuntStepScalarWhereInput[];
  };

  export type RewardUpdateManyWithoutTreasureHuntNestedInput = {
    create?:
      | XOR<
          RewardCreateWithoutTreasureHuntInput,
          RewardUncheckedCreateWithoutTreasureHuntInput
        >
      | RewardCreateWithoutTreasureHuntInput[]
      | RewardUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | RewardCreateOrConnectWithoutTreasureHuntInput
      | RewardCreateOrConnectWithoutTreasureHuntInput[];
    upsert?:
      | RewardUpsertWithWhereUniqueWithoutTreasureHuntInput
      | RewardUpsertWithWhereUniqueWithoutTreasureHuntInput[];
    createMany?: RewardCreateManyTreasureHuntInputEnvelope;
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    update?:
      | RewardUpdateWithWhereUniqueWithoutTreasureHuntInput
      | RewardUpdateWithWhereUniqueWithoutTreasureHuntInput[];
    updateMany?:
      | RewardUpdateManyWithWhereWithoutTreasureHuntInput
      | RewardUpdateManyWithWhereWithoutTreasureHuntInput[];
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[];
  };

  export type ArtefactUpdateManyWithoutHuntNestedInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutHuntInput,
          ArtefactUncheckedCreateWithoutHuntInput
        >
      | ArtefactCreateWithoutHuntInput[]
      | ArtefactUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutHuntInput
      | ArtefactCreateOrConnectWithoutHuntInput[];
    upsert?:
      | ArtefactUpsertWithWhereUniqueWithoutHuntInput
      | ArtefactUpsertWithWhereUniqueWithoutHuntInput[];
    createMany?: ArtefactCreateManyHuntInputEnvelope;
    set?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    disconnect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    delete?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    update?:
      | ArtefactUpdateWithWhereUniqueWithoutHuntInput
      | ArtefactUpdateWithWhereUniqueWithoutHuntInput[];
    updateMany?:
      | ArtefactUpdateManyWithWhereWithoutHuntInput
      | ArtefactUpdateManyWithWhereWithoutHuntInput[];
    deleteMany?: ArtefactScalarWhereInput | ArtefactScalarWhereInput[];
  };

  export type LeaderboardEntryUpdateManyWithoutHuntNestedInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutHuntInput,
          LeaderboardEntryUncheckedCreateWithoutHuntInput
        >
      | LeaderboardEntryCreateWithoutHuntInput[]
      | LeaderboardEntryUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutHuntInput
      | LeaderboardEntryCreateOrConnectWithoutHuntInput[];
    upsert?:
      | LeaderboardEntryUpsertWithWhereUniqueWithoutHuntInput
      | LeaderboardEntryUpsertWithWhereUniqueWithoutHuntInput[];
    createMany?: LeaderboardEntryCreateManyHuntInputEnvelope;
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[];
    disconnect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    delete?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    update?:
      | LeaderboardEntryUpdateWithWhereUniqueWithoutHuntInput
      | LeaderboardEntryUpdateWithWhereUniqueWithoutHuntInput[];
    updateMany?:
      | LeaderboardEntryUpdateManyWithWhereWithoutHuntInput
      | LeaderboardEntryUpdateManyWithWhereWithoutHuntInput[];
    deleteMany?:
      | LeaderboardEntryScalarWhereInput
      | LeaderboardEntryScalarWhereInput[];
  };

  export type ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput = {
    create?:
      | XOR<
          ParticipationCreateWithoutTreasureHuntInput,
          ParticipationUncheckedCreateWithoutTreasureHuntInput
        >
      | ParticipationCreateWithoutTreasureHuntInput[]
      | ParticipationUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | ParticipationCreateOrConnectWithoutTreasureHuntInput
      | ParticipationCreateOrConnectWithoutTreasureHuntInput[];
    upsert?:
      | ParticipationUpsertWithWhereUniqueWithoutTreasureHuntInput
      | ParticipationUpsertWithWhereUniqueWithoutTreasureHuntInput[];
    createMany?: ParticipationCreateManyTreasureHuntInputEnvelope;
    set?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    disconnect?:
      | ParticipationWhereUniqueInput
      | ParticipationWhereUniqueInput[];
    delete?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    connect?: ParticipationWhereUniqueInput | ParticipationWhereUniqueInput[];
    update?:
      | ParticipationUpdateWithWhereUniqueWithoutTreasureHuntInput
      | ParticipationUpdateWithWhereUniqueWithoutTreasureHuntInput[];
    updateMany?:
      | ParticipationUpdateManyWithWhereWithoutTreasureHuntInput
      | ParticipationUpdateManyWithWhereWithoutTreasureHuntInput[];
    deleteMany?:
      | ParticipationScalarWhereInput
      | ParticipationScalarWhereInput[];
  };

  export type HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput = {
    create?:
      | XOR<
          HuntStepCreateWithoutTreasureHuntInput,
          HuntStepUncheckedCreateWithoutTreasureHuntInput
        >
      | HuntStepCreateWithoutTreasureHuntInput[]
      | HuntStepUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | HuntStepCreateOrConnectWithoutTreasureHuntInput
      | HuntStepCreateOrConnectWithoutTreasureHuntInput[];
    upsert?:
      | HuntStepUpsertWithWhereUniqueWithoutTreasureHuntInput
      | HuntStepUpsertWithWhereUniqueWithoutTreasureHuntInput[];
    createMany?: HuntStepCreateManyTreasureHuntInputEnvelope;
    set?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    disconnect?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    delete?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    connect?: HuntStepWhereUniqueInput | HuntStepWhereUniqueInput[];
    update?:
      | HuntStepUpdateWithWhereUniqueWithoutTreasureHuntInput
      | HuntStepUpdateWithWhereUniqueWithoutTreasureHuntInput[];
    updateMany?:
      | HuntStepUpdateManyWithWhereWithoutTreasureHuntInput
      | HuntStepUpdateManyWithWhereWithoutTreasureHuntInput[];
    deleteMany?: HuntStepScalarWhereInput | HuntStepScalarWhereInput[];
  };

  export type RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput = {
    create?:
      | XOR<
          RewardCreateWithoutTreasureHuntInput,
          RewardUncheckedCreateWithoutTreasureHuntInput
        >
      | RewardCreateWithoutTreasureHuntInput[]
      | RewardUncheckedCreateWithoutTreasureHuntInput[];
    connectOrCreate?:
      | RewardCreateOrConnectWithoutTreasureHuntInput
      | RewardCreateOrConnectWithoutTreasureHuntInput[];
    upsert?:
      | RewardUpsertWithWhereUniqueWithoutTreasureHuntInput
      | RewardUpsertWithWhereUniqueWithoutTreasureHuntInput[];
    createMany?: RewardCreateManyTreasureHuntInputEnvelope;
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[];
    update?:
      | RewardUpdateWithWhereUniqueWithoutTreasureHuntInput
      | RewardUpdateWithWhereUniqueWithoutTreasureHuntInput[];
    updateMany?:
      | RewardUpdateManyWithWhereWithoutTreasureHuntInput
      | RewardUpdateManyWithWhereWithoutTreasureHuntInput[];
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[];
  };

  export type ArtefactUncheckedUpdateManyWithoutHuntNestedInput = {
    create?:
      | XOR<
          ArtefactCreateWithoutHuntInput,
          ArtefactUncheckedCreateWithoutHuntInput
        >
      | ArtefactCreateWithoutHuntInput[]
      | ArtefactUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | ArtefactCreateOrConnectWithoutHuntInput
      | ArtefactCreateOrConnectWithoutHuntInput[];
    upsert?:
      | ArtefactUpsertWithWhereUniqueWithoutHuntInput
      | ArtefactUpsertWithWhereUniqueWithoutHuntInput[];
    createMany?: ArtefactCreateManyHuntInputEnvelope;
    set?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    disconnect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    delete?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    connect?: ArtefactWhereUniqueInput | ArtefactWhereUniqueInput[];
    update?:
      | ArtefactUpdateWithWhereUniqueWithoutHuntInput
      | ArtefactUpdateWithWhereUniqueWithoutHuntInput[];
    updateMany?:
      | ArtefactUpdateManyWithWhereWithoutHuntInput
      | ArtefactUpdateManyWithWhereWithoutHuntInput[];
    deleteMany?: ArtefactScalarWhereInput | ArtefactScalarWhereInput[];
  };

  export type LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput = {
    create?:
      | XOR<
          LeaderboardEntryCreateWithoutHuntInput,
          LeaderboardEntryUncheckedCreateWithoutHuntInput
        >
      | LeaderboardEntryCreateWithoutHuntInput[]
      | LeaderboardEntryUncheckedCreateWithoutHuntInput[];
    connectOrCreate?:
      | LeaderboardEntryCreateOrConnectWithoutHuntInput
      | LeaderboardEntryCreateOrConnectWithoutHuntInput[];
    upsert?:
      | LeaderboardEntryUpsertWithWhereUniqueWithoutHuntInput
      | LeaderboardEntryUpsertWithWhereUniqueWithoutHuntInput[];
    createMany?: LeaderboardEntryCreateManyHuntInputEnvelope;
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[];
    disconnect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    delete?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    connect?:
      | LeaderboardEntryWhereUniqueInput
      | LeaderboardEntryWhereUniqueInput[];
    update?:
      | LeaderboardEntryUpdateWithWhereUniqueWithoutHuntInput
      | LeaderboardEntryUpdateWithWhereUniqueWithoutHuntInput[];
    updateMany?:
      | LeaderboardEntryUpdateManyWithWhereWithoutHuntInput
      | LeaderboardEntryUpdateManyWithWhereWithoutHuntInput[];
    deleteMany?:
      | LeaderboardEntryScalarWhereInput
      | LeaderboardEntryScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<
      UserCreateWithoutParticipationsInput,
      UserUncheckedCreateWithoutParticipationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutParticipationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type TreasureHuntCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<
      TreasureHuntCreateWithoutParticipantsInput,
      TreasureHuntUncheckedCreateWithoutParticipantsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutParticipantsInput;
    connect?: TreasureHuntWhereUniqueInput;
  };

  export type EnumParticipationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ParticipationStatus;
  };

  export type UserUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<
      UserCreateWithoutParticipationsInput,
      UserUncheckedCreateWithoutParticipationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutParticipationsInput;
    upsert?: UserUpsertWithoutParticipationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutParticipationsInput,
        UserUpdateWithoutParticipationsInput
      >,
      UserUncheckedUpdateWithoutParticipationsInput
    >;
  };

  export type TreasureHuntUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<
      TreasureHuntCreateWithoutParticipantsInput,
      TreasureHuntUncheckedCreateWithoutParticipantsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutParticipantsInput;
    upsert?: TreasureHuntUpsertWithoutParticipantsInput;
    connect?: TreasureHuntWhereUniqueInput;
    update?: XOR<
      XOR<
        TreasureHuntUpdateToOneWithWhereWithoutParticipantsInput,
        TreasureHuntUpdateWithoutParticipantsInput
      >,
      TreasureHuntUncheckedUpdateWithoutParticipantsInput
    >;
  };

  export type UserCreateNestedOneWithoutCollectedArtefactsInput = {
    create?: XOR<
      UserCreateWithoutCollectedArtefactsInput,
      UserUncheckedCreateWithoutCollectedArtefactsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCollectedArtefactsInput;
    connect?: UserWhereUniqueInput;
  };

  export type TreasureHuntCreateNestedOneWithoutArtefactsInput = {
    create?: XOR<
      TreasureHuntCreateWithoutArtefactsInput,
      TreasureHuntUncheckedCreateWithoutArtefactsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutArtefactsInput;
    connect?: TreasureHuntWhereUniqueInput;
  };

  export type CraftCreateNestedManyWithoutResultInput = {
    create?:
      | XOR<
          CraftCreateWithoutResultInput,
          CraftUncheckedCreateWithoutResultInput
        >
      | CraftCreateWithoutResultInput[]
      | CraftUncheckedCreateWithoutResultInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutResultInput
      | CraftCreateOrConnectWithoutResultInput[];
    createMany?: CraftCreateManyResultInputEnvelope;
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
  };

  export type CraftMaterialCreateNestedManyWithoutArtefactInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutArtefactInput,
          CraftMaterialUncheckedCreateWithoutArtefactInput
        >
      | CraftMaterialCreateWithoutArtefactInput[]
      | CraftMaterialUncheckedCreateWithoutArtefactInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutArtefactInput
      | CraftMaterialCreateOrConnectWithoutArtefactInput[];
    createMany?: CraftMaterialCreateManyArtefactInputEnvelope;
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
  };

  export type CraftUncheckedCreateNestedManyWithoutResultInput = {
    create?:
      | XOR<
          CraftCreateWithoutResultInput,
          CraftUncheckedCreateWithoutResultInput
        >
      | CraftCreateWithoutResultInput[]
      | CraftUncheckedCreateWithoutResultInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutResultInput
      | CraftCreateOrConnectWithoutResultInput[];
    createMany?: CraftCreateManyResultInputEnvelope;
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
  };

  export type CraftMaterialUncheckedCreateNestedManyWithoutArtefactInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutArtefactInput,
          CraftMaterialUncheckedCreateWithoutArtefactInput
        >
      | CraftMaterialCreateWithoutArtefactInput[]
      | CraftMaterialUncheckedCreateWithoutArtefactInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutArtefactInput
      | CraftMaterialCreateOrConnectWithoutArtefactInput[];
    createMany?: CraftMaterialCreateManyArtefactInputEnvelope;
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
  };

  export type EnumArtefactRarityFieldUpdateOperationsInput = {
    set?: $Enums.ArtefactRarity;
  };

  export type EnumArtefactSourceFieldUpdateOperationsInput = {
    set?: $Enums.ArtefactSource;
  };

  export type UserUpdateOneRequiredWithoutCollectedArtefactsNestedInput = {
    create?: XOR<
      UserCreateWithoutCollectedArtefactsInput,
      UserUncheckedCreateWithoutCollectedArtefactsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCollectedArtefactsInput;
    upsert?: UserUpsertWithoutCollectedArtefactsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCollectedArtefactsInput,
        UserUpdateWithoutCollectedArtefactsInput
      >,
      UserUncheckedUpdateWithoutCollectedArtefactsInput
    >;
  };

  export type TreasureHuntUpdateOneWithoutArtefactsNestedInput = {
    create?: XOR<
      TreasureHuntCreateWithoutArtefactsInput,
      TreasureHuntUncheckedCreateWithoutArtefactsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutArtefactsInput;
    upsert?: TreasureHuntUpsertWithoutArtefactsInput;
    disconnect?: TreasureHuntWhereInput | boolean;
    delete?: TreasureHuntWhereInput | boolean;
    connect?: TreasureHuntWhereUniqueInput;
    update?: XOR<
      XOR<
        TreasureHuntUpdateToOneWithWhereWithoutArtefactsInput,
        TreasureHuntUpdateWithoutArtefactsInput
      >,
      TreasureHuntUncheckedUpdateWithoutArtefactsInput
    >;
  };

  export type CraftUpdateManyWithoutResultNestedInput = {
    create?:
      | XOR<
          CraftCreateWithoutResultInput,
          CraftUncheckedCreateWithoutResultInput
        >
      | CraftCreateWithoutResultInput[]
      | CraftUncheckedCreateWithoutResultInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutResultInput
      | CraftCreateOrConnectWithoutResultInput[];
    upsert?:
      | CraftUpsertWithWhereUniqueWithoutResultInput
      | CraftUpsertWithWhereUniqueWithoutResultInput[];
    createMany?: CraftCreateManyResultInputEnvelope;
    set?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    disconnect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    delete?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    update?:
      | CraftUpdateWithWhereUniqueWithoutResultInput
      | CraftUpdateWithWhereUniqueWithoutResultInput[];
    updateMany?:
      | CraftUpdateManyWithWhereWithoutResultInput
      | CraftUpdateManyWithWhereWithoutResultInput[];
    deleteMany?: CraftScalarWhereInput | CraftScalarWhereInput[];
  };

  export type CraftMaterialUpdateManyWithoutArtefactNestedInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutArtefactInput,
          CraftMaterialUncheckedCreateWithoutArtefactInput
        >
      | CraftMaterialCreateWithoutArtefactInput[]
      | CraftMaterialUncheckedCreateWithoutArtefactInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutArtefactInput
      | CraftMaterialCreateOrConnectWithoutArtefactInput[];
    upsert?:
      | CraftMaterialUpsertWithWhereUniqueWithoutArtefactInput
      | CraftMaterialUpsertWithWhereUniqueWithoutArtefactInput[];
    createMany?: CraftMaterialCreateManyArtefactInputEnvelope;
    set?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    disconnect?:
      | CraftMaterialWhereUniqueInput
      | CraftMaterialWhereUniqueInput[];
    delete?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    update?:
      | CraftMaterialUpdateWithWhereUniqueWithoutArtefactInput
      | CraftMaterialUpdateWithWhereUniqueWithoutArtefactInput[];
    updateMany?:
      | CraftMaterialUpdateManyWithWhereWithoutArtefactInput
      | CraftMaterialUpdateManyWithWhereWithoutArtefactInput[];
    deleteMany?:
      | CraftMaterialScalarWhereInput
      | CraftMaterialScalarWhereInput[];
  };

  export type CraftUncheckedUpdateManyWithoutResultNestedInput = {
    create?:
      | XOR<
          CraftCreateWithoutResultInput,
          CraftUncheckedCreateWithoutResultInput
        >
      | CraftCreateWithoutResultInput[]
      | CraftUncheckedCreateWithoutResultInput[];
    connectOrCreate?:
      | CraftCreateOrConnectWithoutResultInput
      | CraftCreateOrConnectWithoutResultInput[];
    upsert?:
      | CraftUpsertWithWhereUniqueWithoutResultInput
      | CraftUpsertWithWhereUniqueWithoutResultInput[];
    createMany?: CraftCreateManyResultInputEnvelope;
    set?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    disconnect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    delete?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    connect?: CraftWhereUniqueInput | CraftWhereUniqueInput[];
    update?:
      | CraftUpdateWithWhereUniqueWithoutResultInput
      | CraftUpdateWithWhereUniqueWithoutResultInput[];
    updateMany?:
      | CraftUpdateManyWithWhereWithoutResultInput
      | CraftUpdateManyWithWhereWithoutResultInput[];
    deleteMany?: CraftScalarWhereInput | CraftScalarWhereInput[];
  };

  export type CraftMaterialUncheckedUpdateManyWithoutArtefactNestedInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutArtefactInput,
          CraftMaterialUncheckedCreateWithoutArtefactInput
        >
      | CraftMaterialCreateWithoutArtefactInput[]
      | CraftMaterialUncheckedCreateWithoutArtefactInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutArtefactInput
      | CraftMaterialCreateOrConnectWithoutArtefactInput[];
    upsert?:
      | CraftMaterialUpsertWithWhereUniqueWithoutArtefactInput
      | CraftMaterialUpsertWithWhereUniqueWithoutArtefactInput[];
    createMany?: CraftMaterialCreateManyArtefactInputEnvelope;
    set?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    disconnect?:
      | CraftMaterialWhereUniqueInput
      | CraftMaterialWhereUniqueInput[];
    delete?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    update?:
      | CraftMaterialUpdateWithWhereUniqueWithoutArtefactInput
      | CraftMaterialUpdateWithWhereUniqueWithoutArtefactInput[];
    updateMany?:
      | CraftMaterialUpdateManyWithWhereWithoutArtefactInput
      | CraftMaterialUpdateManyWithWhereWithoutArtefactInput[];
    deleteMany?:
      | CraftMaterialScalarWhereInput
      | CraftMaterialScalarWhereInput[];
  };

  export type TreasureHuntCreateNestedOneWithoutStepsInput = {
    create?: XOR<
      TreasureHuntCreateWithoutStepsInput,
      TreasureHuntUncheckedCreateWithoutStepsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutStepsInput;
    connect?: TreasureHuntWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type TreasureHuntUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<
      TreasureHuntCreateWithoutStepsInput,
      TreasureHuntUncheckedCreateWithoutStepsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutStepsInput;
    upsert?: TreasureHuntUpsertWithoutStepsInput;
    connect?: TreasureHuntWhereUniqueInput;
    update?: XOR<
      XOR<
        TreasureHuntUpdateToOneWithWhereWithoutStepsInput,
        TreasureHuntUpdateWithoutStepsInput
      >,
      TreasureHuntUncheckedUpdateWithoutStepsInput
    >;
  };

  export type TreasureHuntCreateNestedOneWithoutRewardsInput = {
    create?: XOR<
      TreasureHuntCreateWithoutRewardsInput,
      TreasureHuntUncheckedCreateWithoutRewardsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutRewardsInput;
    connect?: TreasureHuntWhereUniqueInput;
  };

  export type EnumRewardTypeFieldUpdateOperationsInput = {
    set?: $Enums.RewardType;
  };

  export type TreasureHuntUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<
      TreasureHuntCreateWithoutRewardsInput,
      TreasureHuntUncheckedCreateWithoutRewardsInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutRewardsInput;
    upsert?: TreasureHuntUpsertWithoutRewardsInput;
    connect?: TreasureHuntWhereUniqueInput;
    update?: XOR<
      XOR<
        TreasureHuntUpdateToOneWithWhereWithoutRewardsInput,
        TreasureHuntUpdateWithoutRewardsInput
      >,
      TreasureHuntUncheckedUpdateWithoutRewardsInput
    >;
  };

  export type UserCreateNestedOneWithoutVirtualCurrencyInput = {
    create?: XOR<
      UserCreateWithoutVirtualCurrencyInput,
      UserUncheckedCreateWithoutVirtualCurrencyInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutVirtualCurrencyInput;
    connect?: UserWhereUniqueInput;
  };

  export type TransactionHistoryCreateNestedManyWithoutVirtualCurrencyInput = {
    create?:
      | XOR<
          TransactionHistoryCreateWithoutVirtualCurrencyInput,
          TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput
        >
      | TransactionHistoryCreateWithoutVirtualCurrencyInput[]
      | TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput[];
    connectOrCreate?:
      | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput
      | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput[];
    createMany?: TransactionHistoryCreateManyVirtualCurrencyInputEnvelope;
    connect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
  };

  export type TransactionHistoryUncheckedCreateNestedManyWithoutVirtualCurrencyInput =
    {
      create?:
        | XOR<
            TransactionHistoryCreateWithoutVirtualCurrencyInput,
            TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput
          >
        | TransactionHistoryCreateWithoutVirtualCurrencyInput[]
        | TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput[];
      connectOrCreate?:
        | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput
        | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput[];
      createMany?: TransactionHistoryCreateManyVirtualCurrencyInputEnvelope;
      connect?:
        | TransactionHistoryWhereUniqueInput
        | TransactionHistoryWhereUniqueInput[];
    };

  export type EnumCurrencySourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.CurrencySourceType;
  };

  export type UserUpdateOneRequiredWithoutVirtualCurrencyNestedInput = {
    create?: XOR<
      UserCreateWithoutVirtualCurrencyInput,
      UserUncheckedCreateWithoutVirtualCurrencyInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutVirtualCurrencyInput;
    upsert?: UserUpsertWithoutVirtualCurrencyInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutVirtualCurrencyInput,
        UserUpdateWithoutVirtualCurrencyInput
      >,
      UserUncheckedUpdateWithoutVirtualCurrencyInput
    >;
  };

  export type TransactionHistoryUpdateManyWithoutVirtualCurrencyNestedInput = {
    create?:
      | XOR<
          TransactionHistoryCreateWithoutVirtualCurrencyInput,
          TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput
        >
      | TransactionHistoryCreateWithoutVirtualCurrencyInput[]
      | TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput[];
    connectOrCreate?:
      | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput
      | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput[];
    upsert?:
      | TransactionHistoryUpsertWithWhereUniqueWithoutVirtualCurrencyInput
      | TransactionHistoryUpsertWithWhereUniqueWithoutVirtualCurrencyInput[];
    createMany?: TransactionHistoryCreateManyVirtualCurrencyInputEnvelope;
    set?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    disconnect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    delete?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    connect?:
      | TransactionHistoryWhereUniqueInput
      | TransactionHistoryWhereUniqueInput[];
    update?:
      | TransactionHistoryUpdateWithWhereUniqueWithoutVirtualCurrencyInput
      | TransactionHistoryUpdateWithWhereUniqueWithoutVirtualCurrencyInput[];
    updateMany?:
      | TransactionHistoryUpdateManyWithWhereWithoutVirtualCurrencyInput
      | TransactionHistoryUpdateManyWithWhereWithoutVirtualCurrencyInput[];
    deleteMany?:
      | TransactionHistoryScalarWhereInput
      | TransactionHistoryScalarWhereInput[];
  };

  export type TransactionHistoryUncheckedUpdateManyWithoutVirtualCurrencyNestedInput =
    {
      create?:
        | XOR<
            TransactionHistoryCreateWithoutVirtualCurrencyInput,
            TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput
          >
        | TransactionHistoryCreateWithoutVirtualCurrencyInput[]
        | TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput[];
      connectOrCreate?:
        | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput
        | TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput[];
      upsert?:
        | TransactionHistoryUpsertWithWhereUniqueWithoutVirtualCurrencyInput
        | TransactionHistoryUpsertWithWhereUniqueWithoutVirtualCurrencyInput[];
      createMany?: TransactionHistoryCreateManyVirtualCurrencyInputEnvelope;
      set?:
        | TransactionHistoryWhereUniqueInput
        | TransactionHistoryWhereUniqueInput[];
      disconnect?:
        | TransactionHistoryWhereUniqueInput
        | TransactionHistoryWhereUniqueInput[];
      delete?:
        | TransactionHistoryWhereUniqueInput
        | TransactionHistoryWhereUniqueInput[];
      connect?:
        | TransactionHistoryWhereUniqueInput
        | TransactionHistoryWhereUniqueInput[];
      update?:
        | TransactionHistoryUpdateWithWhereUniqueWithoutVirtualCurrencyInput
        | TransactionHistoryUpdateWithWhereUniqueWithoutVirtualCurrencyInput[];
      updateMany?:
        | TransactionHistoryUpdateManyWithWhereWithoutVirtualCurrencyInput
        | TransactionHistoryUpdateManyWithWhereWithoutVirtualCurrencyInput[];
      deleteMany?:
        | TransactionHistoryScalarWhereInput
        | TransactionHistoryScalarWhereInput[];
    };

  export type VirtualCurrencyCreateNestedOneWithoutTransactionHistoryInput = {
    create?: XOR<
      VirtualCurrencyCreateWithoutTransactionHistoryInput,
      VirtualCurrencyUncheckedCreateWithoutTransactionHistoryInput
    >;
    connectOrCreate?: VirtualCurrencyCreateOrConnectWithoutTransactionHistoryInput;
    connect?: VirtualCurrencyWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTransactionHistoryInput = {
    create?: XOR<
      UserCreateWithoutTransactionHistoryInput,
      UserUncheckedCreateWithoutTransactionHistoryInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTransactionHistoryInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType;
  };

  export type VirtualCurrencyUpdateOneRequiredWithoutTransactionHistoryNestedInput =
    {
      create?: XOR<
        VirtualCurrencyCreateWithoutTransactionHistoryInput,
        VirtualCurrencyUncheckedCreateWithoutTransactionHistoryInput
      >;
      connectOrCreate?: VirtualCurrencyCreateOrConnectWithoutTransactionHistoryInput;
      upsert?: VirtualCurrencyUpsertWithoutTransactionHistoryInput;
      connect?: VirtualCurrencyWhereUniqueInput;
      update?: XOR<
        XOR<
          VirtualCurrencyUpdateToOneWithWhereWithoutTransactionHistoryInput,
          VirtualCurrencyUpdateWithoutTransactionHistoryInput
        >,
        VirtualCurrencyUncheckedUpdateWithoutTransactionHistoryInput
      >;
    };

  export type UserUpdateOneRequiredWithoutTransactionHistoryNestedInput = {
    create?: XOR<
      UserCreateWithoutTransactionHistoryInput,
      UserUncheckedCreateWithoutTransactionHistoryInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTransactionHistoryInput;
    upsert?: UserUpsertWithoutTransactionHistoryInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTransactionHistoryInput,
        UserUpdateWithoutTransactionHistoryInput
      >,
      UserUncheckedUpdateWithoutTransactionHistoryInput
    >;
  };

  export type UserCreateNestedOneWithoutCraftInput = {
    create?: XOR<
      UserCreateWithoutCraftInput,
      UserUncheckedCreateWithoutCraftInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCraftInput;
    connect?: UserWhereUniqueInput;
  };

  export type ArtefactCreateNestedOneWithoutCraftInput = {
    create?: XOR<
      ArtefactCreateWithoutCraftInput,
      ArtefactUncheckedCreateWithoutCraftInput
    >;
    connectOrCreate?: ArtefactCreateOrConnectWithoutCraftInput;
    connect?: ArtefactWhereUniqueInput;
  };

  export type CraftMaterialCreateNestedManyWithoutCraftInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutCraftInput,
          CraftMaterialUncheckedCreateWithoutCraftInput
        >
      | CraftMaterialCreateWithoutCraftInput[]
      | CraftMaterialUncheckedCreateWithoutCraftInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutCraftInput
      | CraftMaterialCreateOrConnectWithoutCraftInput[];
    createMany?: CraftMaterialCreateManyCraftInputEnvelope;
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
  };

  export type CraftMaterialUncheckedCreateNestedManyWithoutCraftInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutCraftInput,
          CraftMaterialUncheckedCreateWithoutCraftInput
        >
      | CraftMaterialCreateWithoutCraftInput[]
      | CraftMaterialUncheckedCreateWithoutCraftInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutCraftInput
      | CraftMaterialCreateOrConnectWithoutCraftInput[];
    createMany?: CraftMaterialCreateManyCraftInputEnvelope;
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutCraftNestedInput = {
    create?: XOR<
      UserCreateWithoutCraftInput,
      UserUncheckedCreateWithoutCraftInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCraftInput;
    upsert?: UserUpsertWithoutCraftInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCraftInput,
        UserUpdateWithoutCraftInput
      >,
      UserUncheckedUpdateWithoutCraftInput
    >;
  };

  export type ArtefactUpdateOneRequiredWithoutCraftNestedInput = {
    create?: XOR<
      ArtefactCreateWithoutCraftInput,
      ArtefactUncheckedCreateWithoutCraftInput
    >;
    connectOrCreate?: ArtefactCreateOrConnectWithoutCraftInput;
    upsert?: ArtefactUpsertWithoutCraftInput;
    connect?: ArtefactWhereUniqueInput;
    update?: XOR<
      XOR<
        ArtefactUpdateToOneWithWhereWithoutCraftInput,
        ArtefactUpdateWithoutCraftInput
      >,
      ArtefactUncheckedUpdateWithoutCraftInput
    >;
  };

  export type CraftMaterialUpdateManyWithoutCraftNestedInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutCraftInput,
          CraftMaterialUncheckedCreateWithoutCraftInput
        >
      | CraftMaterialCreateWithoutCraftInput[]
      | CraftMaterialUncheckedCreateWithoutCraftInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutCraftInput
      | CraftMaterialCreateOrConnectWithoutCraftInput[];
    upsert?:
      | CraftMaterialUpsertWithWhereUniqueWithoutCraftInput
      | CraftMaterialUpsertWithWhereUniqueWithoutCraftInput[];
    createMany?: CraftMaterialCreateManyCraftInputEnvelope;
    set?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    disconnect?:
      | CraftMaterialWhereUniqueInput
      | CraftMaterialWhereUniqueInput[];
    delete?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    update?:
      | CraftMaterialUpdateWithWhereUniqueWithoutCraftInput
      | CraftMaterialUpdateWithWhereUniqueWithoutCraftInput[];
    updateMany?:
      | CraftMaterialUpdateManyWithWhereWithoutCraftInput
      | CraftMaterialUpdateManyWithWhereWithoutCraftInput[];
    deleteMany?:
      | CraftMaterialScalarWhereInput
      | CraftMaterialScalarWhereInput[];
  };

  export type CraftMaterialUncheckedUpdateManyWithoutCraftNestedInput = {
    create?:
      | XOR<
          CraftMaterialCreateWithoutCraftInput,
          CraftMaterialUncheckedCreateWithoutCraftInput
        >
      | CraftMaterialCreateWithoutCraftInput[]
      | CraftMaterialUncheckedCreateWithoutCraftInput[];
    connectOrCreate?:
      | CraftMaterialCreateOrConnectWithoutCraftInput
      | CraftMaterialCreateOrConnectWithoutCraftInput[];
    upsert?:
      | CraftMaterialUpsertWithWhereUniqueWithoutCraftInput
      | CraftMaterialUpsertWithWhereUniqueWithoutCraftInput[];
    createMany?: CraftMaterialCreateManyCraftInputEnvelope;
    set?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    disconnect?:
      | CraftMaterialWhereUniqueInput
      | CraftMaterialWhereUniqueInput[];
    delete?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    connect?: CraftMaterialWhereUniqueInput | CraftMaterialWhereUniqueInput[];
    update?:
      | CraftMaterialUpdateWithWhereUniqueWithoutCraftInput
      | CraftMaterialUpdateWithWhereUniqueWithoutCraftInput[];
    updateMany?:
      | CraftMaterialUpdateManyWithWhereWithoutCraftInput
      | CraftMaterialUpdateManyWithWhereWithoutCraftInput[];
    deleteMany?:
      | CraftMaterialScalarWhereInput
      | CraftMaterialScalarWhereInput[];
  };

  export type CraftCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<
      CraftCreateWithoutMaterialsInput,
      CraftUncheckedCreateWithoutMaterialsInput
    >;
    connectOrCreate?: CraftCreateOrConnectWithoutMaterialsInput;
    connect?: CraftWhereUniqueInput;
  };

  export type ArtefactCreateNestedOneWithoutCraftMaterialInput = {
    create?: XOR<
      ArtefactCreateWithoutCraftMaterialInput,
      ArtefactUncheckedCreateWithoutCraftMaterialInput
    >;
    connectOrCreate?: ArtefactCreateOrConnectWithoutCraftMaterialInput;
    connect?: ArtefactWhereUniqueInput;
  };

  export type CraftUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<
      CraftCreateWithoutMaterialsInput,
      CraftUncheckedCreateWithoutMaterialsInput
    >;
    connectOrCreate?: CraftCreateOrConnectWithoutMaterialsInput;
    upsert?: CraftUpsertWithoutMaterialsInput;
    connect?: CraftWhereUniqueInput;
    update?: XOR<
      XOR<
        CraftUpdateToOneWithWhereWithoutMaterialsInput,
        CraftUpdateWithoutMaterialsInput
      >,
      CraftUncheckedUpdateWithoutMaterialsInput
    >;
  };

  export type ArtefactUpdateOneRequiredWithoutCraftMaterialNestedInput = {
    create?: XOR<
      ArtefactCreateWithoutCraftMaterialInput,
      ArtefactUncheckedCreateWithoutCraftMaterialInput
    >;
    connectOrCreate?: ArtefactCreateOrConnectWithoutCraftMaterialInput;
    upsert?: ArtefactUpsertWithoutCraftMaterialInput;
    connect?: ArtefactWhereUniqueInput;
    update?: XOR<
      XOR<
        ArtefactUpdateToOneWithWhereWithoutCraftMaterialInput,
        ArtefactUpdateWithoutCraftMaterialInput
      >,
      ArtefactUncheckedUpdateWithoutCraftMaterialInput
    >;
  };

  export type UserCreateNestedOneWithoutLeaderboardEntryInput = {
    create?: XOR<
      UserCreateWithoutLeaderboardEntryInput,
      UserUncheckedCreateWithoutLeaderboardEntryInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntryInput;
    connect?: UserWhereUniqueInput;
  };

  export type TreasureHuntCreateNestedOneWithoutLeaderboardEntryInput = {
    create?: XOR<
      TreasureHuntCreateWithoutLeaderboardEntryInput,
      TreasureHuntUncheckedCreateWithoutLeaderboardEntryInput
    >;
    connectOrCreate?: TreasureHuntCreateOrConnectWithoutLeaderboardEntryInput;
    connect?: TreasureHuntWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutLeaderboardEntryNestedInput = {
    create?: XOR<
      UserCreateWithoutLeaderboardEntryInput,
      UserUncheckedCreateWithoutLeaderboardEntryInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntryInput;
    upsert?: UserUpsertWithoutLeaderboardEntryInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutLeaderboardEntryInput,
        UserUpdateWithoutLeaderboardEntryInput
      >,
      UserUncheckedUpdateWithoutLeaderboardEntryInput
    >;
  };

  export type TreasureHuntUpdateOneRequiredWithoutLeaderboardEntryNestedInput =
    {
      create?: XOR<
        TreasureHuntCreateWithoutLeaderboardEntryInput,
        TreasureHuntUncheckedCreateWithoutLeaderboardEntryInput
      >;
      connectOrCreate?: TreasureHuntCreateOrConnectWithoutLeaderboardEntryInput;
      upsert?: TreasureHuntUpsertWithoutLeaderboardEntryInput;
      connect?: TreasureHuntWhereUniqueInput;
      update?: XOR<
        XOR<
          TreasureHuntUpdateToOneWithWhereWithoutLeaderboardEntryInput,
          TreasureHuntUpdateWithoutLeaderboardEntryInput
        >,
        TreasureHuntUncheckedUpdateWithoutLeaderboardEntryInput
      >;
    };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedEnumHuntModeFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntMode | EnumHuntModeFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    not?: NestedEnumHuntModeFilter<$PrismaModel> | $Enums.HuntMode;
  };

  export type NestedEnumHuntStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntStatus | EnumHuntStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumHuntStatusFilter<$PrismaModel> | $Enums.HuntStatus;
  };

  export type NestedEnumHuntModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntMode | EnumHuntModeFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntMode[] | ListEnumHuntModeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumHuntModeWithAggregatesFilter<$PrismaModel>
      | $Enums.HuntMode;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHuntModeFilter<$PrismaModel>;
    _max?: NestedEnumHuntModeFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumHuntStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HuntStatus | EnumHuntStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HuntStatus[] | ListEnumHuntStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumHuntStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.HuntStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHuntStatusFilter<$PrismaModel>;
    _max?: NestedEnumHuntStatusFilter<$PrismaModel>;
  };

  export type NestedEnumParticipationStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ParticipationStatus
      | EnumParticipationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumParticipationStatusFilter<$PrismaModel>
      | $Enums.ParticipationStatus;
  };

  export type NestedEnumParticipationStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ParticipationStatus
      | EnumParticipationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ParticipationStatus[]
      | ListEnumParticipationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumParticipationStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ParticipationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumParticipationStatusFilter<$PrismaModel>;
    _max?: NestedEnumParticipationStatusFilter<$PrismaModel>;
  };

  export type NestedEnumArtefactRarityFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ArtefactRarity
      | EnumArtefactRarityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    not?: NestedEnumArtefactRarityFilter<$PrismaModel> | $Enums.ArtefactRarity;
  };

  export type NestedEnumArtefactSourceFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ArtefactSource
      | EnumArtefactSourceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    not?: NestedEnumArtefactSourceFilter<$PrismaModel> | $Enums.ArtefactSource;
  };

  export type NestedEnumArtefactRarityWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ArtefactRarity
      | EnumArtefactRarityFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactRarity[]
      | ListEnumArtefactRarityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumArtefactRarityWithAggregatesFilter<$PrismaModel>
      | $Enums.ArtefactRarity;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumArtefactRarityFilter<$PrismaModel>;
    _max?: NestedEnumArtefactRarityFilter<$PrismaModel>;
  };

  export type NestedEnumArtefactSourceWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ArtefactSource
      | EnumArtefactSourceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ArtefactSource[]
      | ListEnumArtefactSourceFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumArtefactSourceWithAggregatesFilter<$PrismaModel>
      | $Enums.ArtefactSource;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumArtefactSourceFilter<$PrismaModel>;
    _max?: NestedEnumArtefactSourceFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType;
  };

  export type NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.RewardType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>;
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>;
  };

  export type NestedEnumCurrencySourceTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CurrencySourceType
      | EnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CurrencySourceType[]
      | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CurrencySourceType[]
      | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCurrencySourceTypeFilter<$PrismaModel>
      | $Enums.CurrencySourceType;
  };

  export type NestedEnumCurrencySourceTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.CurrencySourceType
      | EnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CurrencySourceType[]
      | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CurrencySourceType[]
      | ListEnumCurrencySourceTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCurrencySourceTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.CurrencySourceType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCurrencySourceTypeFilter<$PrismaModel>;
    _max?: NestedEnumCurrencySourceTypeFilter<$PrismaModel>;
  };

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeFilter<$PrismaModel>
      | $Enums.TransactionType;
  };

  export type NestedEnumTransactionTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.TransactionType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>;
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>;
  };

  export type SessionCreateWithoutUserInput = {
    id: string;
    expiresAt: Date | string;
    token: string;
    createdAt: Date | string;
    updatedAt: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string;
    expiresAt: Date | string;
    token: string;
    createdAt: Date | string;
    updatedAt: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountCreateWithoutUserInput = {
    id: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ParticipationCreateWithoutUserInput = {
    id?: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
    treasureHunt: TreasureHuntCreateNestedOneWithoutParticipantsInput;
  };

  export type ParticipationUncheckedCreateWithoutUserInput = {
    id?: string;
    huntId: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
  };

  export type ParticipationCreateOrConnectWithoutUserInput = {
    where: ParticipationWhereUniqueInput;
    create: XOR<
      ParticipationCreateWithoutUserInput,
      ParticipationUncheckedCreateWithoutUserInput
    >;
  };

  export type ParticipationCreateManyUserInputEnvelope = {
    data: ParticipationCreateManyUserInput | ParticipationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TreasureHuntCreateWithoutCreatedByInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardUncheckedCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactUncheckedCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntCreateOrConnectWithoutCreatedByInput = {
    where: TreasureHuntWhereUniqueInput;
    create: XOR<
      TreasureHuntCreateWithoutCreatedByInput,
      TreasureHuntUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type TreasureHuntCreateManyCreatedByInputEnvelope = {
    data:
      | TreasureHuntCreateManyCreatedByInput
      | TreasureHuntCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type ArtefactCreateWithoutUserInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    foundAt?: Date | string;
    hunt?: TreasureHuntCreateNestedOneWithoutArtefactsInput;
    Craft?: CraftCreateNestedManyWithoutResultInput;
    CraftMaterial?: CraftMaterialCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactUncheckedCreateWithoutUserInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    huntId?: string | null;
    foundAt?: Date | string;
    Craft?: CraftUncheckedCreateNestedManyWithoutResultInput;
    CraftMaterial?: CraftMaterialUncheckedCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactCreateOrConnectWithoutUserInput = {
    where: ArtefactWhereUniqueInput;
    create: XOR<
      ArtefactCreateWithoutUserInput,
      ArtefactUncheckedCreateWithoutUserInput
    >;
  };

  export type ArtefactCreateManyUserInputEnvelope = {
    data: ArtefactCreateManyUserInput | ArtefactCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type VirtualCurrencyCreateWithoutUserInput = {
    id?: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutVirtualCurrencyInput;
  };

  export type VirtualCurrencyUncheckedCreateWithoutUserInput = {
    id?: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutVirtualCurrencyInput;
  };

  export type VirtualCurrencyCreateOrConnectWithoutUserInput = {
    where: VirtualCurrencyWhereUniqueInput;
    create: XOR<
      VirtualCurrencyCreateWithoutUserInput,
      VirtualCurrencyUncheckedCreateWithoutUserInput
    >;
  };

  export type VirtualCurrencyCreateManyUserInputEnvelope = {
    data:
      | VirtualCurrencyCreateManyUserInput
      | VirtualCurrencyCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TransactionHistoryCreateWithoutUserInput = {
    id?: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    virtualCurrency: VirtualCurrencyCreateNestedOneWithoutTransactionHistoryInput;
  };

  export type TransactionHistoryUncheckedCreateWithoutUserInput = {
    id?: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    virtualCurrencyId: string;
  };

  export type TransactionHistoryCreateOrConnectWithoutUserInput = {
    where: TransactionHistoryWhereUniqueInput;
    create: XOR<
      TransactionHistoryCreateWithoutUserInput,
      TransactionHistoryUncheckedCreateWithoutUserInput
    >;
  };

  export type TransactionHistoryCreateManyUserInputEnvelope = {
    data:
      | TransactionHistoryCreateManyUserInput
      | TransactionHistoryCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CraftCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    result: ArtefactCreateNestedOneWithoutCraftInput;
    materials?: CraftMaterialCreateNestedManyWithoutCraftInput;
  };

  export type CraftUncheckedCreateWithoutUserInput = {
    id?: string;
    resultId: string;
    createdAt?: Date | string;
    materials?: CraftMaterialUncheckedCreateNestedManyWithoutCraftInput;
  };

  export type CraftCreateOrConnectWithoutUserInput = {
    where: CraftWhereUniqueInput;
    create: XOR<
      CraftCreateWithoutUserInput,
      CraftUncheckedCreateWithoutUserInput
    >;
  };

  export type CraftCreateManyUserInputEnvelope = {
    data: CraftCreateManyUserInput | CraftCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type LeaderboardEntryCreateWithoutUserInput = {
    id?: string;
    rank: number;
    score: number;
    completedAt: Date | string;
    hunt: TreasureHuntCreateNestedOneWithoutLeaderboardEntryInput;
  };

  export type LeaderboardEntryUncheckedCreateWithoutUserInput = {
    id?: string;
    huntId: string;
    rank: number;
    score: number;
    completedAt: Date | string;
  };

  export type LeaderboardEntryCreateOrConnectWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput;
    create: XOR<
      LeaderboardEntryCreateWithoutUserInput,
      LeaderboardEntryUncheckedCreateWithoutUserInput
    >;
  };

  export type LeaderboardEntryCreateManyUserInputEnvelope = {
    data:
      | LeaderboardEntryCreateManyUserInput
      | LeaderboardEntryCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<
      SessionUpdateManyMutationInput,
      SessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<"Session"> | string;
    expiresAt?: DateTimeFilter<"Session"> | Date | string;
    token?: StringFilter<"Session"> | string;
    createdAt?: DateTimeFilter<"Session"> | Date | string;
    updatedAt?: DateTimeFilter<"Session"> | Date | string;
    ipAddress?: StringNullableFilter<"Session"> | string | null;
    userAgent?: StringNullableFilter<"Session"> | string | null;
    userId?: StringFilter<"Session"> | string;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<
      AccountUpdateManyMutationInput,
      AccountUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<"Account"> | string;
    accountId?: StringFilter<"Account"> | string;
    providerId?: StringFilter<"Account"> | string;
    userId?: StringFilter<"Account"> | string;
    accessToken?: StringNullableFilter<"Account"> | string | null;
    refreshToken?: StringNullableFilter<"Account"> | string | null;
    idToken?: StringNullableFilter<"Account"> | string | null;
    accessTokenExpiresAt?:
      | DateTimeNullableFilter<"Account">
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | DateTimeNullableFilter<"Account">
      | Date
      | string
      | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    password?: StringNullableFilter<"Account"> | string | null;
    createdAt?: DateTimeFilter<"Account"> | Date | string;
    updatedAt?: DateTimeFilter<"Account"> | Date | string;
  };

  export type ParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: ParticipationWhereUniqueInput;
    update: XOR<
      ParticipationUpdateWithoutUserInput,
      ParticipationUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ParticipationCreateWithoutUserInput,
      ParticipationUncheckedCreateWithoutUserInput
    >;
  };

  export type ParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: ParticipationWhereUniqueInput;
    data: XOR<
      ParticipationUpdateWithoutUserInput,
      ParticipationUncheckedUpdateWithoutUserInput
    >;
  };

  export type ParticipationUpdateManyWithWhereWithoutUserInput = {
    where: ParticipationScalarWhereInput;
    data: XOR<
      ParticipationUpdateManyMutationInput,
      ParticipationUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ParticipationScalarWhereInput = {
    AND?: ParticipationScalarWhereInput | ParticipationScalarWhereInput[];
    OR?: ParticipationScalarWhereInput[];
    NOT?: ParticipationScalarWhereInput | ParticipationScalarWhereInput[];
    id?: StringFilter<"Participation"> | string;
    userId?: StringFilter<"Participation"> | string;
    huntId?: StringFilter<"Participation"> | string;
    status?:
      | EnumParticipationStatusFilter<"Participation">
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFilter<"Participation"> | Date | string;
  };

  export type TreasureHuntUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TreasureHuntWhereUniqueInput;
    update: XOR<
      TreasureHuntUpdateWithoutCreatedByInput,
      TreasureHuntUncheckedUpdateWithoutCreatedByInput
    >;
    create: XOR<
      TreasureHuntCreateWithoutCreatedByInput,
      TreasureHuntUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type TreasureHuntUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TreasureHuntWhereUniqueInput;
    data: XOR<
      TreasureHuntUpdateWithoutCreatedByInput,
      TreasureHuntUncheckedUpdateWithoutCreatedByInput
    >;
  };

  export type TreasureHuntUpdateManyWithWhereWithoutCreatedByInput = {
    where: TreasureHuntScalarWhereInput;
    data: XOR<
      TreasureHuntUpdateManyMutationInput,
      TreasureHuntUncheckedUpdateManyWithoutCreatedByInput
    >;
  };

  export type TreasureHuntScalarWhereInput = {
    AND?: TreasureHuntScalarWhereInput | TreasureHuntScalarWhereInput[];
    OR?: TreasureHuntScalarWhereInput[];
    NOT?: TreasureHuntScalarWhereInput | TreasureHuntScalarWhereInput[];
    id?: StringFilter<"TreasureHunt"> | string;
    title?: StringFilter<"TreasureHunt"> | string;
    description?: StringNullableFilter<"TreasureHunt"> | string | null;
    createdById?: StringFilter<"TreasureHunt"> | string;
    startDate?: DateTimeNullableFilter<"TreasureHunt"> | Date | string | null;
    endDate?: DateTimeNullableFilter<"TreasureHunt"> | Date | string | null;
    location?: StringNullableFilter<"TreasureHunt"> | string | null;
    mode?: EnumHuntModeFilter<"TreasureHunt"> | $Enums.HuntMode;
    fee?: IntNullableFilter<"TreasureHunt"> | number | null;
    mapStyle?: StringNullableFilter<"TreasureHunt"> | string | null;
    isFinished?: BoolFilter<"TreasureHunt"> | boolean;
    status?: EnumHuntStatusFilter<"TreasureHunt"> | $Enums.HuntStatus;
    createdAt?: DateTimeFilter<"TreasureHunt"> | Date | string;
    updatedAt?: DateTimeFilter<"TreasureHunt"> | Date | string;
  };

  export type ArtefactUpsertWithWhereUniqueWithoutUserInput = {
    where: ArtefactWhereUniqueInput;
    update: XOR<
      ArtefactUpdateWithoutUserInput,
      ArtefactUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ArtefactCreateWithoutUserInput,
      ArtefactUncheckedCreateWithoutUserInput
    >;
  };

  export type ArtefactUpdateWithWhereUniqueWithoutUserInput = {
    where: ArtefactWhereUniqueInput;
    data: XOR<
      ArtefactUpdateWithoutUserInput,
      ArtefactUncheckedUpdateWithoutUserInput
    >;
  };

  export type ArtefactUpdateManyWithWhereWithoutUserInput = {
    where: ArtefactScalarWhereInput;
    data: XOR<
      ArtefactUpdateManyMutationInput,
      ArtefactUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ArtefactScalarWhereInput = {
    AND?: ArtefactScalarWhereInput | ArtefactScalarWhereInput[];
    OR?: ArtefactScalarWhereInput[];
    NOT?: ArtefactScalarWhereInput | ArtefactScalarWhereInput[];
    id?: StringFilter<"Artefact"> | string;
    name?: StringFilter<"Artefact"> | string;
    rarity?: EnumArtefactRarityFilter<"Artefact"> | $Enums.ArtefactRarity;
    description?: StringNullableFilter<"Artefact"> | string | null;
    imageUrl?: StringNullableFilter<"Artefact"> | string | null;
    isHidden?: BoolFilter<"Artefact"> | boolean;
    source?: EnumArtefactSourceFilter<"Artefact"> | $Enums.ArtefactSource;
    userId?: StringFilter<"Artefact"> | string;
    huntId?: StringNullableFilter<"Artefact"> | string | null;
    foundAt?: DateTimeFilter<"Artefact"> | Date | string;
  };

  export type VirtualCurrencyUpsertWithWhereUniqueWithoutUserInput = {
    where: VirtualCurrencyWhereUniqueInput;
    update: XOR<
      VirtualCurrencyUpdateWithoutUserInput,
      VirtualCurrencyUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      VirtualCurrencyCreateWithoutUserInput,
      VirtualCurrencyUncheckedCreateWithoutUserInput
    >;
  };

  export type VirtualCurrencyUpdateWithWhereUniqueWithoutUserInput = {
    where: VirtualCurrencyWhereUniqueInput;
    data: XOR<
      VirtualCurrencyUpdateWithoutUserInput,
      VirtualCurrencyUncheckedUpdateWithoutUserInput
    >;
  };

  export type VirtualCurrencyUpdateManyWithWhereWithoutUserInput = {
    where: VirtualCurrencyScalarWhereInput;
    data: XOR<
      VirtualCurrencyUpdateManyMutationInput,
      VirtualCurrencyUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type VirtualCurrencyScalarWhereInput = {
    AND?: VirtualCurrencyScalarWhereInput | VirtualCurrencyScalarWhereInput[];
    OR?: VirtualCurrencyScalarWhereInput[];
    NOT?: VirtualCurrencyScalarWhereInput | VirtualCurrencyScalarWhereInput[];
    id?: StringFilter<"VirtualCurrency"> | string;
    userId?: StringFilter<"VirtualCurrency"> | string;
    amount?: IntFilter<"VirtualCurrency"> | number;
    type?:
      | EnumCurrencySourceTypeFilter<"VirtualCurrency">
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFilter<"VirtualCurrency"> | Date | string;
    updatedAt?: DateTimeFilter<"VirtualCurrency"> | Date | string;
  };

  export type TransactionHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionHistoryWhereUniqueInput;
    update: XOR<
      TransactionHistoryUpdateWithoutUserInput,
      TransactionHistoryUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TransactionHistoryCreateWithoutUserInput,
      TransactionHistoryUncheckedCreateWithoutUserInput
    >;
  };

  export type TransactionHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionHistoryWhereUniqueInput;
    data: XOR<
      TransactionHistoryUpdateWithoutUserInput,
      TransactionHistoryUncheckedUpdateWithoutUserInput
    >;
  };

  export type TransactionHistoryUpdateManyWithWhereWithoutUserInput = {
    where: TransactionHistoryScalarWhereInput;
    data: XOR<
      TransactionHistoryUpdateManyMutationInput,
      TransactionHistoryUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type TransactionHistoryScalarWhereInput = {
    AND?:
      | TransactionHistoryScalarWhereInput
      | TransactionHistoryScalarWhereInput[];
    OR?: TransactionHistoryScalarWhereInput[];
    NOT?:
      | TransactionHistoryScalarWhereInput
      | TransactionHistoryScalarWhereInput[];
    id?: StringFilter<"TransactionHistory"> | string;
    userId?: StringFilter<"TransactionHistory"> | string;
    transactionId?: StringFilter<"TransactionHistory"> | string;
    stripeSessionId?:
      | StringNullableFilter<"TransactionHistory">
      | string
      | null;
    amount?: IntFilter<"TransactionHistory"> | number;
    transactionType?:
      | EnumTransactionTypeFilter<"TransactionHistory">
      | $Enums.TransactionType;
    description?: StringNullableFilter<"TransactionHistory"> | string | null;
    createdAt?: DateTimeFilter<"TransactionHistory"> | Date | string;
    virtualCurrencyId?: StringFilter<"TransactionHistory"> | string;
  };

  export type CraftUpsertWithWhereUniqueWithoutUserInput = {
    where: CraftWhereUniqueInput;
    update: XOR<
      CraftUpdateWithoutUserInput,
      CraftUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CraftCreateWithoutUserInput,
      CraftUncheckedCreateWithoutUserInput
    >;
  };

  export type CraftUpdateWithWhereUniqueWithoutUserInput = {
    where: CraftWhereUniqueInput;
    data: XOR<
      CraftUpdateWithoutUserInput,
      CraftUncheckedUpdateWithoutUserInput
    >;
  };

  export type CraftUpdateManyWithWhereWithoutUserInput = {
    where: CraftScalarWhereInput;
    data: XOR<
      CraftUpdateManyMutationInput,
      CraftUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type CraftScalarWhereInput = {
    AND?: CraftScalarWhereInput | CraftScalarWhereInput[];
    OR?: CraftScalarWhereInput[];
    NOT?: CraftScalarWhereInput | CraftScalarWhereInput[];
    id?: StringFilter<"Craft"> | string;
    userId?: StringFilter<"Craft"> | string;
    resultId?: StringFilter<"Craft"> | string;
    createdAt?: DateTimeFilter<"Craft"> | Date | string;
  };

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput;
    update: XOR<
      LeaderboardEntryUpdateWithoutUserInput,
      LeaderboardEntryUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      LeaderboardEntryCreateWithoutUserInput,
      LeaderboardEntryUncheckedCreateWithoutUserInput
    >;
  };

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput;
    data: XOR<
      LeaderboardEntryUpdateWithoutUserInput,
      LeaderboardEntryUncheckedUpdateWithoutUserInput
    >;
  };

  export type LeaderboardEntryUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardEntryScalarWhereInput;
    data: XOR<
      LeaderboardEntryUpdateManyMutationInput,
      LeaderboardEntryUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type LeaderboardEntryScalarWhereInput = {
    AND?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[];
    OR?: LeaderboardEntryScalarWhereInput[];
    NOT?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[];
    id?: StringFilter<"LeaderboardEntry"> | string;
    userId?: StringFilter<"LeaderboardEntry"> | string;
    huntId?: StringFilter<"LeaderboardEntry"> | string;
    rank?: IntFilter<"LeaderboardEntry"> | number;
    score?: IntFilter<"LeaderboardEntry"> | number;
    completedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutCreatedChassesInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCreatedChassesInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCreatedChassesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCreatedChassesInput,
      UserUncheckedCreateWithoutCreatedChassesInput
    >;
  };

  export type ParticipationCreateWithoutTreasureHuntInput = {
    id?: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
    user: UserCreateNestedOneWithoutParticipationsInput;
  };

  export type ParticipationUncheckedCreateWithoutTreasureHuntInput = {
    id?: string;
    userId: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
  };

  export type ParticipationCreateOrConnectWithoutTreasureHuntInput = {
    where: ParticipationWhereUniqueInput;
    create: XOR<
      ParticipationCreateWithoutTreasureHuntInput,
      ParticipationUncheckedCreateWithoutTreasureHuntInput
    >;
  };

  export type ParticipationCreateManyTreasureHuntInputEnvelope = {
    data:
      | ParticipationCreateManyTreasureHuntInput
      | ParticipationCreateManyTreasureHuntInput[];
    skipDuplicates?: boolean;
  };

  export type HuntStepCreateWithoutTreasureHuntInput = {
    id?: string;
    description: string;
    stepOrder: number;
    createdAt?: Date | string;
  };

  export type HuntStepUncheckedCreateWithoutTreasureHuntInput = {
    id?: string;
    description: string;
    stepOrder: number;
    createdAt?: Date | string;
  };

  export type HuntStepCreateOrConnectWithoutTreasureHuntInput = {
    where: HuntStepWhereUniqueInput;
    create: XOR<
      HuntStepCreateWithoutTreasureHuntInput,
      HuntStepUncheckedCreateWithoutTreasureHuntInput
    >;
  };

  export type HuntStepCreateManyTreasureHuntInputEnvelope = {
    data:
      | HuntStepCreateManyTreasureHuntInput
      | HuntStepCreateManyTreasureHuntInput[];
    skipDuplicates?: boolean;
  };

  export type RewardCreateWithoutTreasureHuntInput = {
    id?: string;
    type: $Enums.RewardType;
    value: number;
    description?: string | null;
  };

  export type RewardUncheckedCreateWithoutTreasureHuntInput = {
    id?: string;
    type: $Enums.RewardType;
    value: number;
    description?: string | null;
  };

  export type RewardCreateOrConnectWithoutTreasureHuntInput = {
    where: RewardWhereUniqueInput;
    create: XOR<
      RewardCreateWithoutTreasureHuntInput,
      RewardUncheckedCreateWithoutTreasureHuntInput
    >;
  };

  export type RewardCreateManyTreasureHuntInputEnvelope = {
    data:
      | RewardCreateManyTreasureHuntInput
      | RewardCreateManyTreasureHuntInput[];
    skipDuplicates?: boolean;
  };

  export type ArtefactCreateWithoutHuntInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    foundAt?: Date | string;
    user: UserCreateNestedOneWithoutCollectedArtefactsInput;
    Craft?: CraftCreateNestedManyWithoutResultInput;
    CraftMaterial?: CraftMaterialCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactUncheckedCreateWithoutHuntInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    foundAt?: Date | string;
    Craft?: CraftUncheckedCreateNestedManyWithoutResultInput;
    CraftMaterial?: CraftMaterialUncheckedCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactCreateOrConnectWithoutHuntInput = {
    where: ArtefactWhereUniqueInput;
    create: XOR<
      ArtefactCreateWithoutHuntInput,
      ArtefactUncheckedCreateWithoutHuntInput
    >;
  };

  export type ArtefactCreateManyHuntInputEnvelope = {
    data: ArtefactCreateManyHuntInput | ArtefactCreateManyHuntInput[];
    skipDuplicates?: boolean;
  };

  export type LeaderboardEntryCreateWithoutHuntInput = {
    id?: string;
    rank: number;
    score: number;
    completedAt: Date | string;
    user: UserCreateNestedOneWithoutLeaderboardEntryInput;
  };

  export type LeaderboardEntryUncheckedCreateWithoutHuntInput = {
    id?: string;
    userId: string;
    rank: number;
    score: number;
    completedAt: Date | string;
  };

  export type LeaderboardEntryCreateOrConnectWithoutHuntInput = {
    where: LeaderboardEntryWhereUniqueInput;
    create: XOR<
      LeaderboardEntryCreateWithoutHuntInput,
      LeaderboardEntryUncheckedCreateWithoutHuntInput
    >;
  };

  export type LeaderboardEntryCreateManyHuntInputEnvelope = {
    data:
      | LeaderboardEntryCreateManyHuntInput
      | LeaderboardEntryCreateManyHuntInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCreatedChassesInput = {
    update: XOR<
      UserUpdateWithoutCreatedChassesInput,
      UserUncheckedUpdateWithoutCreatedChassesInput
    >;
    create: XOR<
      UserCreateWithoutCreatedChassesInput,
      UserUncheckedCreateWithoutCreatedChassesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCreatedChassesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCreatedChassesInput,
      UserUncheckedUpdateWithoutCreatedChassesInput
    >;
  };

  export type UserUpdateWithoutCreatedChassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedChassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ParticipationUpsertWithWhereUniqueWithoutTreasureHuntInput = {
    where: ParticipationWhereUniqueInput;
    update: XOR<
      ParticipationUpdateWithoutTreasureHuntInput,
      ParticipationUncheckedUpdateWithoutTreasureHuntInput
    >;
    create: XOR<
      ParticipationCreateWithoutTreasureHuntInput,
      ParticipationUncheckedCreateWithoutTreasureHuntInput
    >;
  };

  export type ParticipationUpdateWithWhereUniqueWithoutTreasureHuntInput = {
    where: ParticipationWhereUniqueInput;
    data: XOR<
      ParticipationUpdateWithoutTreasureHuntInput,
      ParticipationUncheckedUpdateWithoutTreasureHuntInput
    >;
  };

  export type ParticipationUpdateManyWithWhereWithoutTreasureHuntInput = {
    where: ParticipationScalarWhereInput;
    data: XOR<
      ParticipationUpdateManyMutationInput,
      ParticipationUncheckedUpdateManyWithoutTreasureHuntInput
    >;
  };

  export type HuntStepUpsertWithWhereUniqueWithoutTreasureHuntInput = {
    where: HuntStepWhereUniqueInput;
    update: XOR<
      HuntStepUpdateWithoutTreasureHuntInput,
      HuntStepUncheckedUpdateWithoutTreasureHuntInput
    >;
    create: XOR<
      HuntStepCreateWithoutTreasureHuntInput,
      HuntStepUncheckedCreateWithoutTreasureHuntInput
    >;
  };

  export type HuntStepUpdateWithWhereUniqueWithoutTreasureHuntInput = {
    where: HuntStepWhereUniqueInput;
    data: XOR<
      HuntStepUpdateWithoutTreasureHuntInput,
      HuntStepUncheckedUpdateWithoutTreasureHuntInput
    >;
  };

  export type HuntStepUpdateManyWithWhereWithoutTreasureHuntInput = {
    where: HuntStepScalarWhereInput;
    data: XOR<
      HuntStepUpdateManyMutationInput,
      HuntStepUncheckedUpdateManyWithoutTreasureHuntInput
    >;
  };

  export type HuntStepScalarWhereInput = {
    AND?: HuntStepScalarWhereInput | HuntStepScalarWhereInput[];
    OR?: HuntStepScalarWhereInput[];
    NOT?: HuntStepScalarWhereInput | HuntStepScalarWhereInput[];
    id?: StringFilter<"HuntStep"> | string;
    description?: StringFilter<"HuntStep"> | string;
    huntId?: StringFilter<"HuntStep"> | string;
    stepOrder?: IntFilter<"HuntStep"> | number;
    createdAt?: DateTimeFilter<"HuntStep"> | Date | string;
  };

  export type RewardUpsertWithWhereUniqueWithoutTreasureHuntInput = {
    where: RewardWhereUniqueInput;
    update: XOR<
      RewardUpdateWithoutTreasureHuntInput,
      RewardUncheckedUpdateWithoutTreasureHuntInput
    >;
    create: XOR<
      RewardCreateWithoutTreasureHuntInput,
      RewardUncheckedCreateWithoutTreasureHuntInput
    >;
  };

  export type RewardUpdateWithWhereUniqueWithoutTreasureHuntInput = {
    where: RewardWhereUniqueInput;
    data: XOR<
      RewardUpdateWithoutTreasureHuntInput,
      RewardUncheckedUpdateWithoutTreasureHuntInput
    >;
  };

  export type RewardUpdateManyWithWhereWithoutTreasureHuntInput = {
    where: RewardScalarWhereInput;
    data: XOR<
      RewardUpdateManyMutationInput,
      RewardUncheckedUpdateManyWithoutTreasureHuntInput
    >;
  };

  export type RewardScalarWhereInput = {
    AND?: RewardScalarWhereInput | RewardScalarWhereInput[];
    OR?: RewardScalarWhereInput[];
    NOT?: RewardScalarWhereInput | RewardScalarWhereInput[];
    id?: StringFilter<"Reward"> | string;
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType;
    value?: IntFilter<"Reward"> | number;
    description?: StringNullableFilter<"Reward"> | string | null;
    huntId?: StringFilter<"Reward"> | string;
  };

  export type ArtefactUpsertWithWhereUniqueWithoutHuntInput = {
    where: ArtefactWhereUniqueInput;
    update: XOR<
      ArtefactUpdateWithoutHuntInput,
      ArtefactUncheckedUpdateWithoutHuntInput
    >;
    create: XOR<
      ArtefactCreateWithoutHuntInput,
      ArtefactUncheckedCreateWithoutHuntInput
    >;
  };

  export type ArtefactUpdateWithWhereUniqueWithoutHuntInput = {
    where: ArtefactWhereUniqueInput;
    data: XOR<
      ArtefactUpdateWithoutHuntInput,
      ArtefactUncheckedUpdateWithoutHuntInput
    >;
  };

  export type ArtefactUpdateManyWithWhereWithoutHuntInput = {
    where: ArtefactScalarWhereInput;
    data: XOR<
      ArtefactUpdateManyMutationInput,
      ArtefactUncheckedUpdateManyWithoutHuntInput
    >;
  };

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutHuntInput = {
    where: LeaderboardEntryWhereUniqueInput;
    update: XOR<
      LeaderboardEntryUpdateWithoutHuntInput,
      LeaderboardEntryUncheckedUpdateWithoutHuntInput
    >;
    create: XOR<
      LeaderboardEntryCreateWithoutHuntInput,
      LeaderboardEntryUncheckedCreateWithoutHuntInput
    >;
  };

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutHuntInput = {
    where: LeaderboardEntryWhereUniqueInput;
    data: XOR<
      LeaderboardEntryUpdateWithoutHuntInput,
      LeaderboardEntryUncheckedUpdateWithoutHuntInput
    >;
  };

  export type LeaderboardEntryUpdateManyWithWhereWithoutHuntInput = {
    where: LeaderboardEntryScalarWhereInput;
    data: XOR<
      LeaderboardEntryUpdateManyMutationInput,
      LeaderboardEntryUncheckedUpdateManyWithoutHuntInput
    >;
  };

  export type UserCreateWithoutParticipationsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutParticipationsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutParticipationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutParticipationsInput,
      UserUncheckedCreateWithoutParticipationsInput
    >;
  };

  export type TreasureHuntCreateWithoutParticipantsInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedChassesInput;
    steps?: HuntStepCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateWithoutParticipantsInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    steps?: HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardUncheckedCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactUncheckedCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntCreateOrConnectWithoutParticipantsInput = {
    where: TreasureHuntWhereUniqueInput;
    create: XOR<
      TreasureHuntCreateWithoutParticipantsInput,
      TreasureHuntUncheckedCreateWithoutParticipantsInput
    >;
  };

  export type UserUpsertWithoutParticipationsInput = {
    update: XOR<
      UserUpdateWithoutParticipationsInput,
      UserUncheckedUpdateWithoutParticipationsInput
    >;
    create: XOR<
      UserCreateWithoutParticipationsInput,
      UserUncheckedCreateWithoutParticipationsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutParticipationsInput,
      UserUncheckedUpdateWithoutParticipationsInput
    >;
  };

  export type UserUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type TreasureHuntUpsertWithoutParticipantsInput = {
    update: XOR<
      TreasureHuntUpdateWithoutParticipantsInput,
      TreasureHuntUncheckedUpdateWithoutParticipantsInput
    >;
    create: XOR<
      TreasureHuntCreateWithoutParticipantsInput,
      TreasureHuntUncheckedCreateWithoutParticipantsInput
    >;
    where?: TreasureHuntWhereInput;
  };

  export type TreasureHuntUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TreasureHuntWhereInput;
    data: XOR<
      TreasureHuntUpdateWithoutParticipantsInput,
      TreasureHuntUncheckedUpdateWithoutParticipantsInput
    >;
  };

  export type TreasureHuntUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedChassesNestedInput;
    steps?: HuntStepUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    steps?: HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUncheckedUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type UserCreateWithoutCollectedArtefactsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCollectedArtefactsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCollectedArtefactsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCollectedArtefactsInput,
      UserUncheckedCreateWithoutCollectedArtefactsInput
    >;
  };

  export type TreasureHuntCreateWithoutArtefactsInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedChassesInput;
    participants?: ParticipationCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardCreateNestedManyWithoutTreasureHuntInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateWithoutArtefactsInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardUncheckedCreateNestedManyWithoutTreasureHuntInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntCreateOrConnectWithoutArtefactsInput = {
    where: TreasureHuntWhereUniqueInput;
    create: XOR<
      TreasureHuntCreateWithoutArtefactsInput,
      TreasureHuntUncheckedCreateWithoutArtefactsInput
    >;
  };

  export type CraftCreateWithoutResultInput = {
    id?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutCraftInput;
    materials?: CraftMaterialCreateNestedManyWithoutCraftInput;
  };

  export type CraftUncheckedCreateWithoutResultInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    materials?: CraftMaterialUncheckedCreateNestedManyWithoutCraftInput;
  };

  export type CraftCreateOrConnectWithoutResultInput = {
    where: CraftWhereUniqueInput;
    create: XOR<
      CraftCreateWithoutResultInput,
      CraftUncheckedCreateWithoutResultInput
    >;
  };

  export type CraftCreateManyResultInputEnvelope = {
    data: CraftCreateManyResultInput | CraftCreateManyResultInput[];
    skipDuplicates?: boolean;
  };

  export type CraftMaterialCreateWithoutArtefactInput = {
    id?: string;
    craft: CraftCreateNestedOneWithoutMaterialsInput;
  };

  export type CraftMaterialUncheckedCreateWithoutArtefactInput = {
    id?: string;
    craftId: string;
  };

  export type CraftMaterialCreateOrConnectWithoutArtefactInput = {
    where: CraftMaterialWhereUniqueInput;
    create: XOR<
      CraftMaterialCreateWithoutArtefactInput,
      CraftMaterialUncheckedCreateWithoutArtefactInput
    >;
  };

  export type CraftMaterialCreateManyArtefactInputEnvelope = {
    data:
      | CraftMaterialCreateManyArtefactInput
      | CraftMaterialCreateManyArtefactInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCollectedArtefactsInput = {
    update: XOR<
      UserUpdateWithoutCollectedArtefactsInput,
      UserUncheckedUpdateWithoutCollectedArtefactsInput
    >;
    create: XOR<
      UserCreateWithoutCollectedArtefactsInput,
      UserUncheckedCreateWithoutCollectedArtefactsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCollectedArtefactsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCollectedArtefactsInput,
      UserUncheckedUpdateWithoutCollectedArtefactsInput
    >;
  };

  export type UserUpdateWithoutCollectedArtefactsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCollectedArtefactsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type TreasureHuntUpsertWithoutArtefactsInput = {
    update: XOR<
      TreasureHuntUpdateWithoutArtefactsInput,
      TreasureHuntUncheckedUpdateWithoutArtefactsInput
    >;
    create: XOR<
      TreasureHuntCreateWithoutArtefactsInput,
      TreasureHuntUncheckedCreateWithoutArtefactsInput
    >;
    where?: TreasureHuntWhereInput;
  };

  export type TreasureHuntUpdateToOneWithWhereWithoutArtefactsInput = {
    where?: TreasureHuntWhereInput;
    data: XOR<
      TreasureHuntUpdateWithoutArtefactsInput,
      TreasureHuntUncheckedUpdateWithoutArtefactsInput
    >;
  };

  export type TreasureHuntUpdateWithoutArtefactsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedChassesNestedInput;
    participants?: ParticipationUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUpdateManyWithoutTreasureHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateWithoutArtefactsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type CraftUpsertWithWhereUniqueWithoutResultInput = {
    where: CraftWhereUniqueInput;
    update: XOR<
      CraftUpdateWithoutResultInput,
      CraftUncheckedUpdateWithoutResultInput
    >;
    create: XOR<
      CraftCreateWithoutResultInput,
      CraftUncheckedCreateWithoutResultInput
    >;
  };

  export type CraftUpdateWithWhereUniqueWithoutResultInput = {
    where: CraftWhereUniqueInput;
    data: XOR<
      CraftUpdateWithoutResultInput,
      CraftUncheckedUpdateWithoutResultInput
    >;
  };

  export type CraftUpdateManyWithWhereWithoutResultInput = {
    where: CraftScalarWhereInput;
    data: XOR<
      CraftUpdateManyMutationInput,
      CraftUncheckedUpdateManyWithoutResultInput
    >;
  };

  export type CraftMaterialUpsertWithWhereUniqueWithoutArtefactInput = {
    where: CraftMaterialWhereUniqueInput;
    update: XOR<
      CraftMaterialUpdateWithoutArtefactInput,
      CraftMaterialUncheckedUpdateWithoutArtefactInput
    >;
    create: XOR<
      CraftMaterialCreateWithoutArtefactInput,
      CraftMaterialUncheckedCreateWithoutArtefactInput
    >;
  };

  export type CraftMaterialUpdateWithWhereUniqueWithoutArtefactInput = {
    where: CraftMaterialWhereUniqueInput;
    data: XOR<
      CraftMaterialUpdateWithoutArtefactInput,
      CraftMaterialUncheckedUpdateWithoutArtefactInput
    >;
  };

  export type CraftMaterialUpdateManyWithWhereWithoutArtefactInput = {
    where: CraftMaterialScalarWhereInput;
    data: XOR<
      CraftMaterialUpdateManyMutationInput,
      CraftMaterialUncheckedUpdateManyWithoutArtefactInput
    >;
  };

  export type CraftMaterialScalarWhereInput = {
    AND?: CraftMaterialScalarWhereInput | CraftMaterialScalarWhereInput[];
    OR?: CraftMaterialScalarWhereInput[];
    NOT?: CraftMaterialScalarWhereInput | CraftMaterialScalarWhereInput[];
    id?: StringFilter<"CraftMaterial"> | string;
    craftId?: StringFilter<"CraftMaterial"> | string;
    artefactId?: StringFilter<"CraftMaterial"> | string;
  };

  export type TreasureHuntCreateWithoutStepsInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedChassesInput;
    participants?: ParticipationCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateWithoutStepsInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardUncheckedCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactUncheckedCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntCreateOrConnectWithoutStepsInput = {
    where: TreasureHuntWhereUniqueInput;
    create: XOR<
      TreasureHuntCreateWithoutStepsInput,
      TreasureHuntUncheckedCreateWithoutStepsInput
    >;
  };

  export type TreasureHuntUpsertWithoutStepsInput = {
    update: XOR<
      TreasureHuntUpdateWithoutStepsInput,
      TreasureHuntUncheckedUpdateWithoutStepsInput
    >;
    create: XOR<
      TreasureHuntCreateWithoutStepsInput,
      TreasureHuntUncheckedCreateWithoutStepsInput
    >;
    where?: TreasureHuntWhereInput;
  };

  export type TreasureHuntUpdateToOneWithWhereWithoutStepsInput = {
    where?: TreasureHuntWhereInput;
    data: XOR<
      TreasureHuntUpdateWithoutStepsInput,
      TreasureHuntUncheckedUpdateWithoutStepsInput
    >;
  };

  export type TreasureHuntUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedChassesNestedInput;
    participants?: ParticipationUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUncheckedUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntCreateWithoutRewardsInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedChassesInput;
    participants?: ParticipationCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateWithoutRewardsInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactUncheckedCreateNestedManyWithoutHuntInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntCreateOrConnectWithoutRewardsInput = {
    where: TreasureHuntWhereUniqueInput;
    create: XOR<
      TreasureHuntCreateWithoutRewardsInput,
      TreasureHuntUncheckedCreateWithoutRewardsInput
    >;
  };

  export type TreasureHuntUpsertWithoutRewardsInput = {
    update: XOR<
      TreasureHuntUpdateWithoutRewardsInput,
      TreasureHuntUncheckedUpdateWithoutRewardsInput
    >;
    create: XOR<
      TreasureHuntCreateWithoutRewardsInput,
      TreasureHuntUncheckedCreateWithoutRewardsInput
    >;
    where?: TreasureHuntWhereInput;
  };

  export type TreasureHuntUpdateToOneWithWhereWithoutRewardsInput = {
    where?: TreasureHuntWhereInput;
    data: XOR<
      TreasureHuntUpdateWithoutRewardsInput,
      TreasureHuntUncheckedUpdateWithoutRewardsInput
    >;
  };

  export type TreasureHuntUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedChassesNestedInput;
    participants?: ParticipationUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUncheckedUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type UserCreateWithoutVirtualCurrencyInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutVirtualCurrencyInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutVirtualCurrencyInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutVirtualCurrencyInput,
      UserUncheckedCreateWithoutVirtualCurrencyInput
    >;
  };

  export type TransactionHistoryCreateWithoutVirtualCurrencyInput = {
    id?: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutTransactionHistoryInput;
  };

  export type TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput = {
    id?: string;
    userId: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
  };

  export type TransactionHistoryCreateOrConnectWithoutVirtualCurrencyInput = {
    where: TransactionHistoryWhereUniqueInput;
    create: XOR<
      TransactionHistoryCreateWithoutVirtualCurrencyInput,
      TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput
    >;
  };

  export type TransactionHistoryCreateManyVirtualCurrencyInputEnvelope = {
    data:
      | TransactionHistoryCreateManyVirtualCurrencyInput
      | TransactionHistoryCreateManyVirtualCurrencyInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutVirtualCurrencyInput = {
    update: XOR<
      UserUpdateWithoutVirtualCurrencyInput,
      UserUncheckedUpdateWithoutVirtualCurrencyInput
    >;
    create: XOR<
      UserCreateWithoutVirtualCurrencyInput,
      UserUncheckedCreateWithoutVirtualCurrencyInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutVirtualCurrencyInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutVirtualCurrencyInput,
      UserUncheckedUpdateWithoutVirtualCurrencyInput
    >;
  };

  export type UserUpdateWithoutVirtualCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutVirtualCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type TransactionHistoryUpsertWithWhereUniqueWithoutVirtualCurrencyInput =
    {
      where: TransactionHistoryWhereUniqueInput;
      update: XOR<
        TransactionHistoryUpdateWithoutVirtualCurrencyInput,
        TransactionHistoryUncheckedUpdateWithoutVirtualCurrencyInput
      >;
      create: XOR<
        TransactionHistoryCreateWithoutVirtualCurrencyInput,
        TransactionHistoryUncheckedCreateWithoutVirtualCurrencyInput
      >;
    };

  export type TransactionHistoryUpdateWithWhereUniqueWithoutVirtualCurrencyInput =
    {
      where: TransactionHistoryWhereUniqueInput;
      data: XOR<
        TransactionHistoryUpdateWithoutVirtualCurrencyInput,
        TransactionHistoryUncheckedUpdateWithoutVirtualCurrencyInput
      >;
    };

  export type TransactionHistoryUpdateManyWithWhereWithoutVirtualCurrencyInput =
    {
      where: TransactionHistoryScalarWhereInput;
      data: XOR<
        TransactionHistoryUpdateManyMutationInput,
        TransactionHistoryUncheckedUpdateManyWithoutVirtualCurrencyInput
      >;
    };

  export type VirtualCurrencyCreateWithoutTransactionHistoryInput = {
    id?: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutVirtualCurrencyInput;
  };

  export type VirtualCurrencyUncheckedCreateWithoutTransactionHistoryInput = {
    id?: string;
    userId: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VirtualCurrencyCreateOrConnectWithoutTransactionHistoryInput = {
    where: VirtualCurrencyWhereUniqueInput;
    create: XOR<
      VirtualCurrencyCreateWithoutTransactionHistoryInput,
      VirtualCurrencyUncheckedCreateWithoutTransactionHistoryInput
    >;
  };

  export type UserCreateWithoutTransactionHistoryInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTransactionHistoryInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTransactionHistoryInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTransactionHistoryInput,
      UserUncheckedCreateWithoutTransactionHistoryInput
    >;
  };

  export type VirtualCurrencyUpsertWithoutTransactionHistoryInput = {
    update: XOR<
      VirtualCurrencyUpdateWithoutTransactionHistoryInput,
      VirtualCurrencyUncheckedUpdateWithoutTransactionHistoryInput
    >;
    create: XOR<
      VirtualCurrencyCreateWithoutTransactionHistoryInput,
      VirtualCurrencyUncheckedCreateWithoutTransactionHistoryInput
    >;
    where?: VirtualCurrencyWhereInput;
  };

  export type VirtualCurrencyUpdateToOneWithWhereWithoutTransactionHistoryInput =
    {
      where?: VirtualCurrencyWhereInput;
      data: XOR<
        VirtualCurrencyUpdateWithoutTransactionHistoryInput,
        VirtualCurrencyUncheckedUpdateWithoutTransactionHistoryInput
      >;
    };

  export type VirtualCurrencyUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutVirtualCurrencyNestedInput;
  };

  export type VirtualCurrencyUncheckedUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutTransactionHistoryInput = {
    update: XOR<
      UserUpdateWithoutTransactionHistoryInput,
      UserUncheckedUpdateWithoutTransactionHistoryInput
    >;
    create: XOR<
      UserCreateWithoutTransactionHistoryInput,
      UserUncheckedCreateWithoutTransactionHistoryInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTransactionHistoryInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTransactionHistoryInput,
      UserUncheckedUpdateWithoutTransactionHistoryInput
    >;
  };

  export type UserUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutCraftInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCraftInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCraftInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCraftInput,
      UserUncheckedCreateWithoutCraftInput
    >;
  };

  export type ArtefactCreateWithoutCraftInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    foundAt?: Date | string;
    user: UserCreateNestedOneWithoutCollectedArtefactsInput;
    hunt?: TreasureHuntCreateNestedOneWithoutArtefactsInput;
    CraftMaterial?: CraftMaterialCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactUncheckedCreateWithoutCraftInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    huntId?: string | null;
    foundAt?: Date | string;
    CraftMaterial?: CraftMaterialUncheckedCreateNestedManyWithoutArtefactInput;
  };

  export type ArtefactCreateOrConnectWithoutCraftInput = {
    where: ArtefactWhereUniqueInput;
    create: XOR<
      ArtefactCreateWithoutCraftInput,
      ArtefactUncheckedCreateWithoutCraftInput
    >;
  };

  export type CraftMaterialCreateWithoutCraftInput = {
    id?: string;
    artefact: ArtefactCreateNestedOneWithoutCraftMaterialInput;
  };

  export type CraftMaterialUncheckedCreateWithoutCraftInput = {
    id?: string;
    artefactId: string;
  };

  export type CraftMaterialCreateOrConnectWithoutCraftInput = {
    where: CraftMaterialWhereUniqueInput;
    create: XOR<
      CraftMaterialCreateWithoutCraftInput,
      CraftMaterialUncheckedCreateWithoutCraftInput
    >;
  };

  export type CraftMaterialCreateManyCraftInputEnvelope = {
    data:
      | CraftMaterialCreateManyCraftInput
      | CraftMaterialCreateManyCraftInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCraftInput = {
    update: XOR<
      UserUpdateWithoutCraftInput,
      UserUncheckedUpdateWithoutCraftInput
    >;
    create: XOR<
      UserCreateWithoutCraftInput,
      UserUncheckedCreateWithoutCraftInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCraftInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCraftInput,
      UserUncheckedUpdateWithoutCraftInput
    >;
  };

  export type UserUpdateWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ArtefactUpsertWithoutCraftInput = {
    update: XOR<
      ArtefactUpdateWithoutCraftInput,
      ArtefactUncheckedUpdateWithoutCraftInput
    >;
    create: XOR<
      ArtefactCreateWithoutCraftInput,
      ArtefactUncheckedCreateWithoutCraftInput
    >;
    where?: ArtefactWhereInput;
  };

  export type ArtefactUpdateToOneWithWhereWithoutCraftInput = {
    where?: ArtefactWhereInput;
    data: XOR<
      ArtefactUpdateWithoutCraftInput,
      ArtefactUncheckedUpdateWithoutCraftInput
    >;
  };

  export type ArtefactUpdateWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCollectedArtefactsNestedInput;
    hunt?: TreasureHuntUpdateOneWithoutArtefactsNestedInput;
    CraftMaterial?: CraftMaterialUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactUncheckedUpdateWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: NullableStringFieldUpdateOperationsInput | string | null;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    CraftMaterial?: CraftMaterialUncheckedUpdateManyWithoutArtefactNestedInput;
  };

  export type CraftMaterialUpsertWithWhereUniqueWithoutCraftInput = {
    where: CraftMaterialWhereUniqueInput;
    update: XOR<
      CraftMaterialUpdateWithoutCraftInput,
      CraftMaterialUncheckedUpdateWithoutCraftInput
    >;
    create: XOR<
      CraftMaterialCreateWithoutCraftInput,
      CraftMaterialUncheckedCreateWithoutCraftInput
    >;
  };

  export type CraftMaterialUpdateWithWhereUniqueWithoutCraftInput = {
    where: CraftMaterialWhereUniqueInput;
    data: XOR<
      CraftMaterialUpdateWithoutCraftInput,
      CraftMaterialUncheckedUpdateWithoutCraftInput
    >;
  };

  export type CraftMaterialUpdateManyWithWhereWithoutCraftInput = {
    where: CraftMaterialScalarWhereInput;
    data: XOR<
      CraftMaterialUpdateManyMutationInput,
      CraftMaterialUncheckedUpdateManyWithoutCraftInput
    >;
  };

  export type CraftCreateWithoutMaterialsInput = {
    id?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutCraftInput;
    result: ArtefactCreateNestedOneWithoutCraftInput;
  };

  export type CraftUncheckedCreateWithoutMaterialsInput = {
    id?: string;
    userId: string;
    resultId: string;
    createdAt?: Date | string;
  };

  export type CraftCreateOrConnectWithoutMaterialsInput = {
    where: CraftWhereUniqueInput;
    create: XOR<
      CraftCreateWithoutMaterialsInput,
      CraftUncheckedCreateWithoutMaterialsInput
    >;
  };

  export type ArtefactCreateWithoutCraftMaterialInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    foundAt?: Date | string;
    user: UserCreateNestedOneWithoutCollectedArtefactsInput;
    hunt?: TreasureHuntCreateNestedOneWithoutArtefactsInput;
    Craft?: CraftCreateNestedManyWithoutResultInput;
  };

  export type ArtefactUncheckedCreateWithoutCraftMaterialInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    huntId?: string | null;
    foundAt?: Date | string;
    Craft?: CraftUncheckedCreateNestedManyWithoutResultInput;
  };

  export type ArtefactCreateOrConnectWithoutCraftMaterialInput = {
    where: ArtefactWhereUniqueInput;
    create: XOR<
      ArtefactCreateWithoutCraftMaterialInput,
      ArtefactUncheckedCreateWithoutCraftMaterialInput
    >;
  };

  export type CraftUpsertWithoutMaterialsInput = {
    update: XOR<
      CraftUpdateWithoutMaterialsInput,
      CraftUncheckedUpdateWithoutMaterialsInput
    >;
    create: XOR<
      CraftCreateWithoutMaterialsInput,
      CraftUncheckedCreateWithoutMaterialsInput
    >;
    where?: CraftWhereInput;
  };

  export type CraftUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: CraftWhereInput;
    data: XOR<
      CraftUpdateWithoutMaterialsInput,
      CraftUncheckedUpdateWithoutMaterialsInput
    >;
  };

  export type CraftUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCraftNestedInput;
    result?: ArtefactUpdateOneRequiredWithoutCraftNestedInput;
  };

  export type CraftUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    resultId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ArtefactUpsertWithoutCraftMaterialInput = {
    update: XOR<
      ArtefactUpdateWithoutCraftMaterialInput,
      ArtefactUncheckedUpdateWithoutCraftMaterialInput
    >;
    create: XOR<
      ArtefactCreateWithoutCraftMaterialInput,
      ArtefactUncheckedCreateWithoutCraftMaterialInput
    >;
    where?: ArtefactWhereInput;
  };

  export type ArtefactUpdateToOneWithWhereWithoutCraftMaterialInput = {
    where?: ArtefactWhereInput;
    data: XOR<
      ArtefactUpdateWithoutCraftMaterialInput,
      ArtefactUncheckedUpdateWithoutCraftMaterialInput
    >;
  };

  export type ArtefactUpdateWithoutCraftMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCollectedArtefactsNestedInput;
    hunt?: TreasureHuntUpdateOneWithoutArtefactsNestedInput;
    Craft?: CraftUpdateManyWithoutResultNestedInput;
  };

  export type ArtefactUncheckedUpdateWithoutCraftMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    userId?: StringFieldUpdateOperationsInput | string;
    huntId?: NullableStringFieldUpdateOperationsInput | string | null;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Craft?: CraftUncheckedUpdateManyWithoutResultNestedInput;
  };

  export type UserCreateWithoutLeaderboardEntryInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    participations?: ParticipationCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutUserInput;
    Craft?: CraftCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutLeaderboardEntryInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified: boolean;
    image?: string | null;
    stripeCustomerId?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
    nickname?: string | null;
    role?: $Enums.UserRole;
    isMfaEnabled?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    participations?: ParticipationUncheckedCreateNestedManyWithoutUserInput;
    createdChasses?: TreasureHuntUncheckedCreateNestedManyWithoutCreatedByInput;
    collectedArtefacts?: ArtefactUncheckedCreateNestedManyWithoutUserInput;
    virtualCurrency?: VirtualCurrencyUncheckedCreateNestedManyWithoutUserInput;
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutUserInput;
    Craft?: CraftUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutLeaderboardEntryInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutLeaderboardEntryInput,
      UserUncheckedCreateWithoutLeaderboardEntryInput
    >;
  };

  export type TreasureHuntCreateWithoutLeaderboardEntryInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedChassesInput;
    participants?: ParticipationCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntUncheckedCreateWithoutLeaderboardEntryInput = {
    id?: string;
    title: string;
    description?: string | null;
    createdById: string;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: ParticipationUncheckedCreateNestedManyWithoutTreasureHuntInput;
    steps?: HuntStepUncheckedCreateNestedManyWithoutTreasureHuntInput;
    rewards?: RewardUncheckedCreateNestedManyWithoutTreasureHuntInput;
    artefacts?: ArtefactUncheckedCreateNestedManyWithoutHuntInput;
  };

  export type TreasureHuntCreateOrConnectWithoutLeaderboardEntryInput = {
    where: TreasureHuntWhereUniqueInput;
    create: XOR<
      TreasureHuntCreateWithoutLeaderboardEntryInput,
      TreasureHuntUncheckedCreateWithoutLeaderboardEntryInput
    >;
  };

  export type UserUpsertWithoutLeaderboardEntryInput = {
    update: XOR<
      UserUpdateWithoutLeaderboardEntryInput,
      UserUncheckedUpdateWithoutLeaderboardEntryInput
    >;
    create: XOR<
      UserCreateWithoutLeaderboardEntryInput,
      UserUncheckedCreateWithoutLeaderboardEntryInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntryInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutLeaderboardEntryInput,
      UserUncheckedUpdateWithoutLeaderboardEntryInput
    >;
  };

  export type UserUpdateWithoutLeaderboardEntryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUpdateManyWithoutUserNestedInput;
    Craft?: CraftUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutLeaderboardEntryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    nickname?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    isMfaEnabled?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    participations?: ParticipationUncheckedUpdateManyWithoutUserNestedInput;
    createdChasses?: TreasureHuntUncheckedUpdateManyWithoutCreatedByNestedInput;
    collectedArtefacts?: ArtefactUncheckedUpdateManyWithoutUserNestedInput;
    virtualCurrency?: VirtualCurrencyUncheckedUpdateManyWithoutUserNestedInput;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutUserNestedInput;
    Craft?: CraftUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type TreasureHuntUpsertWithoutLeaderboardEntryInput = {
    update: XOR<
      TreasureHuntUpdateWithoutLeaderboardEntryInput,
      TreasureHuntUncheckedUpdateWithoutLeaderboardEntryInput
    >;
    create: XOR<
      TreasureHuntCreateWithoutLeaderboardEntryInput,
      TreasureHuntUncheckedCreateWithoutLeaderboardEntryInput
    >;
    where?: TreasureHuntWhereInput;
  };

  export type TreasureHuntUpdateToOneWithWhereWithoutLeaderboardEntryInput = {
    where?: TreasureHuntWhereInput;
    data: XOR<
      TreasureHuntUpdateWithoutLeaderboardEntryInput,
      TreasureHuntUncheckedUpdateWithoutLeaderboardEntryInput
    >;
  };

  export type TreasureHuntUpdateWithoutLeaderboardEntryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedChassesNestedInput;
    participants?: ParticipationUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateWithoutLeaderboardEntryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdById?: StringFieldUpdateOperationsInput | string;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type SessionCreateManyUserInput = {
    id: string;
    expiresAt: Date | string;
    token: string;
    createdAt: Date | string;
    updatedAt: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
  };

  export type AccountCreateManyUserInput = {
    id: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt: Date | string;
    updatedAt: Date | string;
  };

  export type ParticipationCreateManyUserInput = {
    id?: string;
    huntId: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
  };

  export type TreasureHuntCreateManyCreatedByInput = {
    id?: string;
    title: string;
    description?: string | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    location?: string | null;
    mode?: $Enums.HuntMode;
    fee?: number | null;
    mapStyle?: string | null;
    isFinished?: boolean;
    status?: $Enums.HuntStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ArtefactCreateManyUserInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    huntId?: string | null;
    foundAt?: Date | string;
  };

  export type VirtualCurrencyCreateManyUserInput = {
    id?: string;
    amount: number;
    type?: $Enums.CurrencySourceType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TransactionHistoryCreateManyUserInput = {
    id?: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
    virtualCurrencyId: string;
  };

  export type CraftCreateManyUserInput = {
    id?: string;
    resultId: string;
    createdAt?: Date | string;
  };

  export type LeaderboardEntryCreateManyUserInput = {
    id?: string;
    huntId: string;
    rank: number;
    score: number;
    completedAt: Date | string;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    refreshTokenExpiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    treasureHunt?: TreasureHuntUpdateOneRequiredWithoutParticipantsNestedInput;
  };

  export type ParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TreasureHuntUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: ParticipationUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    steps?: HuntStepUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    rewards?: RewardUncheckedUpdateManyWithoutTreasureHuntNestedInput;
    artefacts?: ArtefactUncheckedUpdateManyWithoutHuntNestedInput;
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutHuntNestedInput;
  };

  export type TreasureHuntUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    location?: NullableStringFieldUpdateOperationsInput | string | null;
    mode?: EnumHuntModeFieldUpdateOperationsInput | $Enums.HuntMode;
    fee?: NullableIntFieldUpdateOperationsInput | number | null;
    mapStyle?: NullableStringFieldUpdateOperationsInput | string | null;
    isFinished?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumHuntStatusFieldUpdateOperationsInput | $Enums.HuntStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ArtefactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hunt?: TreasureHuntUpdateOneWithoutArtefactsNestedInput;
    Craft?: CraftUpdateManyWithoutResultNestedInput;
    CraftMaterial?: CraftMaterialUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    huntId?: NullableStringFieldUpdateOperationsInput | string | null;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Craft?: CraftUncheckedUpdateManyWithoutResultNestedInput;
    CraftMaterial?: CraftMaterialUncheckedUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    huntId?: NullableStringFieldUpdateOperationsInput | string | null;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VirtualCurrencyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    transactionHistory?: TransactionHistoryUpdateManyWithoutVirtualCurrencyNestedInput;
  };

  export type VirtualCurrencyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutVirtualCurrencyNestedInput;
  };

  export type VirtualCurrencyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    type?:
      | EnumCurrencySourceTypeFieldUpdateOperationsInput
      | $Enums.CurrencySourceType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TransactionHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    virtualCurrency?: VirtualCurrencyUpdateOneRequiredWithoutTransactionHistoryNestedInput;
  };

  export type TransactionHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    virtualCurrencyId?: StringFieldUpdateOperationsInput | string;
  };

  export type TransactionHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    virtualCurrencyId?: StringFieldUpdateOperationsInput | string;
  };

  export type CraftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    result?: ArtefactUpdateOneRequiredWithoutCraftNestedInput;
    materials?: CraftMaterialUpdateManyWithoutCraftNestedInput;
  };

  export type CraftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    resultId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    materials?: CraftMaterialUncheckedUpdateManyWithoutCraftNestedInput;
  };

  export type CraftUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    resultId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hunt?: TreasureHuntUpdateOneRequiredWithoutLeaderboardEntryNestedInput;
  };

  export type LeaderboardEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    huntId?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationCreateManyTreasureHuntInput = {
    id?: string;
    userId: string;
    status?: $Enums.ParticipationStatus;
    joinDate?: Date | string;
  };

  export type HuntStepCreateManyTreasureHuntInput = {
    id?: string;
    description: string;
    stepOrder: number;
    createdAt?: Date | string;
  };

  export type RewardCreateManyTreasureHuntInput = {
    id?: string;
    type: $Enums.RewardType;
    value: number;
    description?: string | null;
  };

  export type ArtefactCreateManyHuntInput = {
    id?: string;
    name: string;
    rarity: $Enums.ArtefactRarity;
    description?: string | null;
    imageUrl?: string | null;
    isHidden?: boolean;
    source: $Enums.ArtefactSource;
    userId: string;
    foundAt?: Date | string;
  };

  export type LeaderboardEntryCreateManyHuntInput = {
    id?: string;
    userId: string;
    rank: number;
    score: number;
    completedAt: Date | string;
  };

  export type ParticipationUpdateWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutParticipationsNestedInput;
  };

  export type ParticipationUncheckedUpdateWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ParticipationUncheckedUpdateManyWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipationStatusFieldUpdateOperationsInput
      | $Enums.ParticipationStatus;
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HuntStepUpdateWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HuntStepUncheckedUpdateWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HuntStepUncheckedUpdateManyWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    stepOrder?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RewardUpdateWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RewardUncheckedUpdateWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RewardUncheckedUpdateManyWithoutTreasureHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType;
    value?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ArtefactUpdateWithoutHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCollectedArtefactsNestedInput;
    Craft?: CraftUpdateManyWithoutResultNestedInput;
    CraftMaterial?: CraftMaterialUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactUncheckedUpdateWithoutHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    userId?: StringFieldUpdateOperationsInput | string;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Craft?: CraftUncheckedUpdateManyWithoutResultNestedInput;
    CraftMaterial?: CraftMaterialUncheckedUpdateManyWithoutArtefactNestedInput;
  };

  export type ArtefactUncheckedUpdateManyWithoutHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    rarity?:
      | EnumArtefactRarityFieldUpdateOperationsInput
      | $Enums.ArtefactRarity;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isHidden?: BoolFieldUpdateOperationsInput | boolean;
    source?:
      | EnumArtefactSourceFieldUpdateOperationsInput
      | $Enums.ArtefactSource;
    userId?: StringFieldUpdateOperationsInput | string;
    foundAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardEntryUpdateWithoutHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutLeaderboardEntryNestedInput;
  };

  export type LeaderboardEntryUncheckedUpdateWithoutHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardEntryUncheckedUpdateManyWithoutHuntInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    rank?: IntFieldUpdateOperationsInput | number;
    score?: IntFieldUpdateOperationsInput | number;
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CraftCreateManyResultInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type CraftMaterialCreateManyArtefactInput = {
    id?: string;
    craftId: string;
  };

  export type CraftUpdateWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCraftNestedInput;
    materials?: CraftMaterialUpdateManyWithoutCraftNestedInput;
  };

  export type CraftUncheckedUpdateWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    materials?: CraftMaterialUncheckedUpdateManyWithoutCraftNestedInput;
  };

  export type CraftUncheckedUpdateManyWithoutResultInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CraftMaterialUpdateWithoutArtefactInput = {
    id?: StringFieldUpdateOperationsInput | string;
    craft?: CraftUpdateOneRequiredWithoutMaterialsNestedInput;
  };

  export type CraftMaterialUncheckedUpdateWithoutArtefactInput = {
    id?: StringFieldUpdateOperationsInput | string;
    craftId?: StringFieldUpdateOperationsInput | string;
  };

  export type CraftMaterialUncheckedUpdateManyWithoutArtefactInput = {
    id?: StringFieldUpdateOperationsInput | string;
    craftId?: StringFieldUpdateOperationsInput | string;
  };

  export type TransactionHistoryCreateManyVirtualCurrencyInput = {
    id?: string;
    userId: string;
    transactionId?: string;
    stripeSessionId?: string | null;
    amount: number;
    transactionType?: $Enums.TransactionType;
    description?: string | null;
    createdAt?: Date | string;
  };

  export type TransactionHistoryUpdateWithoutVirtualCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTransactionHistoryNestedInput;
  };

  export type TransactionHistoryUncheckedUpdateWithoutVirtualCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    transactionId?: StringFieldUpdateOperationsInput | string;
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null;
    amount?: IntFieldUpdateOperationsInput | number;
    transactionType?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TransactionHistoryUncheckedUpdateManyWithoutVirtualCurrencyInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      userId?: StringFieldUpdateOperationsInput | string;
      transactionId?: StringFieldUpdateOperationsInput | string;
      stripeSessionId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      amount?: IntFieldUpdateOperationsInput | number;
      transactionType?:
        | EnumTransactionTypeFieldUpdateOperationsInput
        | $Enums.TransactionType;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type CraftMaterialCreateManyCraftInput = {
    id?: string;
    artefactId: string;
  };

  export type CraftMaterialUpdateWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    artefact?: ArtefactUpdateOneRequiredWithoutCraftMaterialNestedInput;
  };

  export type CraftMaterialUncheckedUpdateWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    artefactId?: StringFieldUpdateOperationsInput | string;
  };

  export type CraftMaterialUncheckedUpdateManyWithoutCraftInput = {
    id?: StringFieldUpdateOperationsInput | string;
    artefactId?: StringFieldUpdateOperationsInput | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
